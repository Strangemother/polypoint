
================================================================================
FILE: 30k.js
================================================================================

/*
title: 30k particles
categories: raw
---

A raw demo of 30k particles applied to the canvas
 */
;(function(){


var NUM_PARTICLES = ( ( ROWS = 100 ) * ( COLS = 300 ) ),
    THICKNESS = Math.pow( 80, 2 ),
    SPACING = 3,
    MARGIN = 100,
    COLOR = 220,
    DRAG = 0.95,
    EASE = 0.25,

    /*

    used for sine approximation, but Math.sin in Chrome is still fast enough :)
    http://jsperf.com/math-sin-vs-sine-approximation

    B = 4 / Math.PI,
    C = -4 / Math.pow( Math.PI, 2 ),
    P = 0.225,

    */

    container,
    particle,
    canvas,
    mouse,
    stats,
    list,
    ctx,
    tog,
    man,
    dx, dy,
    mx, my,
    d, t, f,
    a, b,
    i, n,
    w, h,
    p, s,
    r, c
    ;

particle = {
  vx: 0,
  vy: 0,
  x: 0,
  y: 0
};

function init() {

  // container = document.getElementById( 'container' );
  canvas = document.getElementById( 'playspace' );

  ctx = canvas.getContext( '2d' );
  man = false;
  tog = true;

  list = [];

  w = canvas.width = COLS * SPACING + MARGIN * 2;
  h = canvas.height = ROWS * SPACING + MARGIN * 2;

  // container.style.marginLeft = Math.round( w * -0.5 ) + 'px';
  // container.style.marginTop = Math.round( h * -0.5 ) + 'px';

  for ( i = 0; i < NUM_PARTICLES; i++ ) {

    p = Object.create( particle );
    p.x = p.ox = MARGIN + SPACING * ( i % COLS );
    p.y = p.oy = MARGIN + SPACING * Math.floor( i / COLS );

    list[i] = p;
  }

  canvas.addEventListener( 'mousemove', function(e) {

    bounds = canvas.getBoundingClientRect();
    mx = e.clientX - bounds.left;
    my = e.clientY - bounds.top;
    man = true;

  });
}

function step() {

  if ( tog = !tog ) {

    if ( !man ) {

      t = +new Date() * 0.001;
      mx = w * 0.5 + ( Math.cos( t * 2.1 ) * Math.cos( t * 0.9 ) * w * 0.45 );
      my = h * 0.5 + ( Math.sin( t * 3.2 ) * Math.tan( Math.sin( t * 0.8 ) ) * h * 0.45 );


================================================================================
END: 30k.js
================================================================================



================================================================================
FILE: a-late.js
================================================================================

/*

title: A Fancy title, with _formatting_.
files:
    stage
    point
tags: example
    another
    beta
    alpha
category: emitter
---

A very long description. A stage will adapt to its global size.

    #playspace {
        height: 100%;
        width: 100%;
        border: solid 1px;
    }

When resizing the page, the `canvas` element dimensions will change.
The Stage will adapt after the resize event.
An example of creating basic interactive controls. For these examples the page
utilises "Petite Vue" for minimal HTML templating

The function `addControl` emits an event for the _mini app_ to collect

*/

================================================================================
END: a-late.js
================================================================================



================================================================================
FILE: anchor-line.js
================================================================================

/*
title: Example
categories: basic
    dragging
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    stroke
    ../point_src/constrain-distance.js
---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.speed = 1
        this.tick = 0
        this.size = 100
        this.points = new PointList(
                        [250 , 150]
                        , [250 , 170]
                        , [250 , 190]
                    ).cast()
        this.dragging.add(...this.points)
    }

    draw(ctx){
        this.clear(ctx)
        this.tick += 1
        let ps = this.points
        let size = this.size + (ps[1].radius *2)
        // ps[1].lookAt(ps[0], 2)
        ps[1].leash(ps[0], size)

        ps[2].xy = ps[1].project(ps[0].distanceTo(ps[1]) - size)
        ps[0].pen.fill(ctx, 'red')
        ps[1].pen.indicator(ctx, 'green')
        ps[2].pen.fill(ctx, 'green')
        ps.pen.quadCurve(ctx)
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: anchor-line.js
================================================================================



================================================================================
FILE: angle-point.js
================================================================================

/*
---
title: Calculate Angles
category: angles
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/protractor.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/mirror.js
    ../point_src/stage.js
    ../point_src/text/label.js
    ../point_src/text/alpha.js
---

This example presents a the angle value between two points (their rotation).

*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.indicatorPoint = new Point({x:200,y:200, radius: 100})
        this.linePoint = new Point(100,100)
        this.targetPoint = this.indicatorPoint.project()

        this.dragging.addPoints(this.indicatorPoint, this.linePoint, this.targetPoint)


        let h = new Label(this.ctx, {
            fontSize: 50
            , textAlign: "center"
            // , fontName: '"lexend deca"'
        })

        // h.fillStyle = 'orange'
        h.position = new Point(300, 200)
        this.label = h;
    }

    updateText() {
        let a = this.indicatorPoint; // looks at targetPoint
        let b = this.linePoint;
        let rot = calculateAngle360(a, b, a.rotation)
        // let rot = invertClockRotation(calculateAngle180(a, b, a.rotation))
        // let rot = calculateAngle180(a, b, a.rotation)
        // let rot = calculateInverseAngle180(a, b, a.rotation)
        this.label.text = rot.toFixed(0)
    }

    onMouseup(e) {
        this.linePoint.color = undefined
    }

    draw(ctx){
        this.clear(ctx)

        let a = this.indicatorPoint;
        let b = this.linePoint;
        // a.rotation -= .1;
        a.pen.indicator(ctx)
        // a.pen.indicator(ctx)
        a.pen.line(ctx, b)
        a.lookAt(this.targetPoint)

        this.targetPoint.pen.fill(ctx, '#8822cc')
        b.pen.fill(ctx, '#99ddff')
        // this.linePoint.pen.indicator(ctx, {color: this.linePoint.color})

        this.updateText()
        this.label.writeText(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: angle-point.js
================================================================================



================================================================================
FILE: angle-value.js
================================================================================

/*
---
title: Angle Values
category: angles
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/protractor.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/angle.js
    ../point_src/text/label.js
 */

aa = new Angle(20, 'tau')
ab = new Angle(20).tau

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.a = new Point({x:200, y:200, radius: 100, rotation: 0})
        this.b = new Point({x:200, y:200, radius: 100, rotation: 270})
        this.dragging.addPoints(this.a, this.b)

        let h = new Label(this.ctx, {
            fontSize: 50
            , textAlign: "center"
            // , fontName: '"lexend deca"'
        })

        // h.fillStyle = 'orange'
        h.position = new Point(300, 200)
        this.label = h;
        this.angle = new Angle(0, 'deg')
    }

    draw(ctx){
        this.clear(ctx)
        let a = this.a;
        let b = this.b;
        a.rotation += .3
        b.rotation += .5

        // let rads = ((b.radians - a.radians) + Math.PI2) % Math.PI2
        let rads = calculateAngleDiff(b,a)
        this.angle.value = rads
        let rot = this.angle.deg // radiansToDegrees(rads)
        // let rot = calculateInverseAngle180(a, b, a.rotation)

        a.pen.indicator(ctx)
        b.pen.indicator(ctx)

        let size = 20

        // a.pen.rect(ctx, 10, 10, 'red')
        const acute90 = function(t, l, col='red', val=90){

            let step = t.project(l)
            step.rotation += val
            let stepB = step.project(l)
            stepB.rotation += val
            let stepC = stepB.project(l)
            step.pen.line(ctx, stepB, col, 2)
            stepB.pen.line(ctx, stepC, col, 2)
            return stepB
        }

        const continue90 = function(t, l, col='red', val=90){

            let step = t.project(l)
            // step.rotation += 90
            let stepB = step.project(l)
            stepB.rotation += val
            let stepC = stepB.project(l)
            step.pen.line(ctx, stepB, col, 2)
            stepB.pen.line(ctx, stepC, col, 2)
            return stepB
        }

        let primaryColor = '#CCC'
        let secondaryColor = '#444'

        if(~~rot % 90 == 0) {
            let r = a
            let f = acute90
            let count = (rot / 90) - 1
            for (var i = 0; i < count; i++) {
                count[i]
                r = f(r, size, primaryColor)


================================================================================
END: angle-value.js
================================================================================



================================================================================
FILE: apple-motion-algo.js
================================================================================

/*
title: Brownian Within a Point
categories: brownian
    random
---


files:
    head
    point
    stage
    mouse
    dragging
    stroke
    ../point_src/random.js


---


The stepMotion function:

```js
(t)=>stepMotion(t, .01, 0.5, .6, 8)
```
+ **t**: time delta: 0-1
+ anticipation: `.1`
+ midpoint: `.5`
+ oscilation: `.1`
+ damping: `.001`

---

An implementation of https://jcgt.org/published/0011/03/02/paper.pdf


    // KinematicTimingCurve.c

    // Smooth timing curve value
    float Xs(float t, float ta, float tmid) {
        float tam = ta - tmid - tmid; // ta - 2tmid

        float xa = (2.0*t*(ta - t) / (ta*tmid + tam));
        float xd = ((t - 2.0)*t*tam + (ta - 2.0)*tmid*tmid);
        xd /= ((tmid-1.0)*(ta*tmid + tam));

        return t<tmid ? xa : xd;
    }

    // Overshoot timing curve value
    float Xo(float t, float ta, float tmid, float B) {
    // terms independent of t: can be precomputed
        float tma = tmid - ta;
        float td = 1.0 - tmid;
        float amp = td*(tmid + tma)/(tmid*tma*B*M_PI);

    // time-dependent terms
        float xa = t*(t - ta) / (tmid*tma);

    // really only needed if t>tmid
        float xd = amp * sin(B*M_PI*(t - tmid)/td);
        xd *= exp(-(t - tmid)*(B/(4.0*td)));
        xd += 1.0;
        return t<tmid ? xa : xd;
    }

    // Timing curve with anticipation ta, midpoint tmid, and bounces B
    float KinematicTiming(float t, float ta, float tmid, int B) {
        return B>=1 ? Xo(t,ta,tmid,float(B)) : Xs(t,ta,tmid);
    }

*/

// class MainStage extends Stage {
//     canvas = 'playspace'
//     updateSpeed = 10
//     mounted(){
//         this.point = new Point()

//     }

//     draw(ctx) {
//         this.clear(ctx)
//         this.point.pen.fill(ctx, '#ddd')
//     }
// }

// stage = MainStage.go(/*{ loop: true }*/)



/* Apple Paper
*/

// // Smooth timing curve value
// const Xs = function(t, ta, tmid) {
//     let tam = ta - tmid - tmid; // ta - 2tmid

//     let xa = (2.0*t*(ta - t) / (ta*tmid + tam));
//     let xd = ((t - 2.0)*t*tam + (ta - 2.0)*tmid*tmid);


================================================================================
END: apple-motion-algo.js
================================================================================



================================================================================
FILE: arc-angles.js
================================================================================

/*
---
title: Arc Angle
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
 */

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.a = new Point({x:200, y:200, radius: 100, rotation: 0})
        this.b = new Point({x:200, y:200, radius: 100, rotation: 270})
        this.dragging.addPoints(this.a, this.b)

    }

    draw(ctx){
        this.clear(ctx)
        let a = this.a;
        let b = this.b;
        // a.rotation += .3
        // b.rotation += .5

        let primaryColor = '#CCC'
        let secondaryColor = '#444'
        let size = 30


        /* Draw an arc from rotation of `a` to rotation `b` */
        a.pen.arc(ctx, b, primaryColor, size, 2, 0)
        a.pen.arc(ctx, b, secondaryColor, size-10, 2, 1)

        b.pen.arc(ctx, a, secondaryColor, size, 2, 0)

        a.pen.indicator(ctx)
        b.pen.indicator(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: arc-angles.js
================================================================================



================================================================================
FILE: arc-circumcircle.js
================================================================================

/*
---
title: Arc Angle
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
 */

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:150, radius: 20, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:350, y:150})
        this.dragging.addPoints(this.centerPoint, this.fromPoint, this.toPoint)
    }

    draw(ctx){
        this.clear(ctx)

        ctx.fillStyle = '#555'
        ctx.strokeStyle = 'orange'


        this.centerPoint.pen.indicator(ctx)
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        this.drawF(ctx)
    }

    drawF(ctx){

        let res = getArcCenter(this.fromPoint, this.toPoint, this.centerPoint)
        let c = Point.from(res)
        // c.pen.indicator(ctx)
        // penArcPlot(arcPlot, ctx, 'red')
        let arcPlot = arcFromTo(c, this.fromPoint, this.toPoint)

        penArcPlot(arcPlot, ctx, 'orange')

        let arcPlot2 = arcFromTo(c, this.fromPoint, this.toPoint, 1)
        penArcPlot(arcPlot2, ctx, 'purple')
        Point.from(res).update({radius: 4}).pen.fill(ctx)
        // drawArcPlot(arcPlot, ctx, 'orange')

    }
}

function getArcCenter(A, B, C) {
    /* the circumcircle,
    draw an arc that fits all three.
    */
  const D = 2 * (A.x * (B.y - C.y) +
                 B.x * (C.y - A.y) +
                 C.x * (A.y - B.y));

  if (D === 0) return null; // points are colinear; no circle

  const Ux = (
    ((A.x ** 2 + A.y ** 2) * (B.y - C.y) +
     (B.x ** 2 + B.y ** 2) * (C.y - A.y) +
     (C.x ** 2 + C.y ** 2) * (A.y - B.y)) / D
  );

  const Uy = (
    ((A.x ** 2 + A.y ** 2) * (C.x - B.x) +
     (B.x ** 2 + B.y ** 2) * (A.x - C.x) +
     (C.x ** 2 + C.y ** 2) * (B.x - A.x)) / D
  );

  return { x: Ux, y: Uy, radius: Math.hypot(A.x - Ux, A.y - Uy)};
}


;stage = MainStage.go();

================================================================================
END: arc-circumcircle.js
================================================================================



================================================================================
FILE: arc-draw-example.js
================================================================================

/*
---
title: Arc Angle
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
 */

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:200, radius: 100, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:350, y:150})
        this.dragging.addPoints(this.centerPoint
                                , this.fromPoint
                                , this.toPoint)

    }

    draw(ctx){
        this.clear(ctx)
        // a.rotation += .3
        // b.rotation += .5
        ctx.fillStyle = '#555'
        ctx.strokeStyle = 'orange'

        let primaryColor = '#CCC'
        let secondaryColor = '#444'
        let size = 30

        /* Draw an arc from rotation of `a` to rotation `b` */
        // centerPoint.pen.arc(ctx, b, primaryColor, size, 2, 0)
        // let a = this.a;
        // let b = this.b;
        // a.pen.arc(ctx, b, secondaryColor, size-10, 2, 1)
        // b.pen.arc(ctx, a, secondaryColor, size, 2, 0)


        this.centerPoint.pen.indicator(ctx)
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        // this.drawA(ctx)
        // this.drawB(ctx)
        // this.drawC(ctx)
        // this.drawD(ctx)
        // this.drawE(ctx)
        this.drawF(ctx)
    }

    drawA(ctx){

        let arcPlot = arcFromTo(this.centerPoint, this.fromPoint, this.toPoint)

        penArcPlot(arcPlot, ctx, 'orange')
        /* Get the arc angle drawn */
        let rads = getArcPlotAngle(arcPlot)
        /* Write the degrees at the center. */
        arcPlot.point.text.string(ctx, ~~rads)

    }

    drawB(ctx){

        let arcPlot = arcSweep(this.centerPoint, Math.PI * .5)

        penArcPlot(arcPlot, ctx, 'red')
        /* Get the arc angle drawn */
        let rads = getArcPlotAngle(arcPlot)
        /* Write the degrees at the center. */
        arcPlot.point.text.string(ctx, ~~rads)

    }

    drawC(ctx){

        // let arcPlot = arcFromTo(this.centerPoint, this.fromPoint, this.toPoint)
        /* Get the arc angle drawn */


================================================================================
END: arc-draw-example.js
================================================================================



================================================================================
FILE: arc-earth-horizon.js
================================================================================

/*
---
title: Arc Three Point.
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
---

Draw an arc to another point _through_ a third point.

*/

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:150, radius: 20, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:950, y:300})
        this.dragging.addPoints(this.centerPoint, this.fromPoint, this.toPoint)
        this.size = 6_378_000 //713_000 // 845_000
        this.size = 713_000 // 845_000
    }

    draw(ctx){
        this.clear(ctx)

        ctx.fillStyle = '#555'

        this.centerPoint.pen.circle(ctx, undefined, '#555')
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        ctx.strokeStyle = '#555'
        // this.fromPoint.pen.line(ctx, this.toPoint, {color: '#666'})
        ctx.strokeStyle = 'orange'
        // this.drawF(ctx)

        const earthRadius = this.size; // scale to pixels if needed
        let from = this.fromPoint;
        let to = this.toPoint;

        let bulge = visualBulge(from, to, earthRadius)
        if (bulge > 0.25) {
            // draw the arc (use previous code)
            ctx.strokeStyle = 'red'
            this.drawH(ctx)
        } else {
            // draw a straight line
            ctx.strokeStyle = 'orange'
            ctx.beginPath();
            ctx.moveTo(this.fromPoint.x, this.fromPoint.y);
            ctx.lineTo(this.toPoint.x, this.toPoint.y);
            ctx.stroke();
        }
    }

    drawG(ctx) {
        const earthRadius = this.size; // in meters, or pixels if scaled
        let from = this.fromPoint;
        let to = this.toPoint;

        const arcCenter = getEarthArcCenter(from, to, earthRadius);
        if (!arcCenter) return;

        // let startRadians = Math.atan2(from.y - arcCenter.cy, from.x - arcCenter.cx);
        // let toRadians = Math.atan2(to.y - arcCenter.cy, to.x - arcCenter.cx);

        let start = Math.atan2(from.y - arcCenter.cy, from.x - arcCenter.cx);
        let end   = Math.atan2(to.y   - arcCenter.cy, to.x   - arcCenter.cx);

        // Ensure we always draw the minor arc (shortest path)
        let angleDiff = (end - start + Math.PI * 2) % (Math.PI * 2);
        if (angleDiff > Math.PI) {
            [start, end] = [end, start]; // swap to go the shorter way
        }

        // Calculate smallest angular difference
        let delta = (end - start + Math.PI * 2) % (Math.PI * 2);
        const anticlockwise = delta > Math.PI; // use CCW if the CW path is longer


================================================================================
END: arc-earth-horizon.js
================================================================================



================================================================================
FILE: arc-fromto.js
================================================================================

/*
---
title: Arc Angle
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
 */

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:200, radius: 100, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:350, y:150})
        this.dragging.addPoints(this.centerPoint
                                , this.fromPoint
                                , this.toPoint)

    }

    draw(ctx){
        this.clear(ctx)
        // a.rotation += .3
        // b.rotation += .5
        ctx.fillStyle = '#555'
        ctx.strokeStyle = 'orange'

        let primaryColor = '#CCC'
        let secondaryColor = '#444'
        let size = 30

        /* Draw an arc from rotation of `a` to rotation `b` */
        // centerPoint.pen.arc(ctx, b, primaryColor, size, 2, 0)
        // let a = this.a;
        // let b = this.b;
        // a.pen.arc(ctx, b, secondaryColor, size-10, 2, 1)
        // b.pen.arc(ctx, a, secondaryColor, size, 2, 0)


        this.centerPoint.pen.indicator(ctx)
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        this.drawA(ctx)
        // this.drawB(ctx)
        // this.drawC(ctx)
        // this.drawD(ctx)
        // this.drawE(ctx)
        // this.drawF(ctx)
    }

    drawA(ctx){

        let arcPlot = arcFromTo(this.centerPoint, this.fromPoint, this.toPoint)

        penArcPlot(arcPlot, ctx, 'orange')
        /* Get the arc angle drawn */
        let rads = getArcPlotAngle(arcPlot)
        /* Write the degrees at the center. */
        arcPlot.point.text.string(ctx, ~~rads)

    }

}


;stage = MainStage.go();

================================================================================
END: arc-fromto.js
================================================================================



================================================================================
FILE: arc-line.js
================================================================================

/*
---
title: Arc Angle
category: angles
    arcs
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/curve-extras.js
 */

aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.a = new Point({x:200, y:200, radius: 20, rotation: 0})
        this.b = new Point({x:100, y:200, radius: 20, rotation: 270})
        this.c = new Point({x:200, y:300, radius: 20, rotation: 282})
        this.d = new Point({x:130, y:130, radius: 20, rotation: 282})

        this.lineA = new Line(this.a, this.b)
        this.lineB = new Line(this.c, this.d)

        this.dragging.addPoints(this.a, this.b, this.c, this.d)

    }

    draw(ctx){
        this.clear(ctx)
        let a = this.a;
        let b = this.b;
        let c = this.c;
        let d = this.d;

        let primaryColor = '#CCC'
        let secondaryColor = '#444'
        let size = 30


        a.pen.indicator(ctx)
        b.pen.indicator(ctx, {color: 'red'})
        c.pen.indicator(ctx, {color: 'red'})
        d.pen.indicator(ctx)

        /* Draw an arc from rotation of `a` to rotation `b` */
        a.pen.arc(ctx, b, primaryColor, size, 2, 0)
        // a.pen.arc(ctx, b, secondaryColor, size, 2, 1)

        this.lineA.render(ctx)
        this.lineB.render(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: arc-line.js
================================================================================



================================================================================
FILE: arc-point-line-alt.js
================================================================================

/*
title: Arc Point Line Alt
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    stroke
    ../point_src/catenary-curve.js
    ../point_src/bisector.js
*/

const arcLine = function(ctx, points) {
    ctx.beginPath();
    // midPoint.pen.indicator(ctx)

    let startPoint = points[0]

    ctx.moveTo(startPoint.x, startPoint.y);

    let previousPoint = startPoint;
    let pl = points.length;

    // debugger;
    for (var i = 0; i < pl; i++) {
        let p = points[i]
        // if(previousPoint) {
            // if(i == pl-1) {
                // end point
                // ctx.lineTo(p.x, p.y);
            // } else {
                let toPoint = p;
                let r = previousPoint.radius
                ctx.arcTo(previousPoint.x, previousPoint.y, toPoint.x, toPoint.y, r);
            // }
        // }
        previousPoint = p
        // this.drawArc(ctx, midPoint, pointC, pointD)
    }
    let last = points[pl-1]
    ctx.lineTo(last.x, last.y);

    // ctx.stroke();
}



class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        // this.point = new Point(50, 50)
        const r = 200
        const shareSize = 15

        const pointA = new Point({ x: 100, y: 300 });
        const pointB = new Point({ x: 300, y: 300 });
        const pointC = new Point({ x: 400, y: 500, radius: 20 });
        const pointD = new Point({ x: 600, y: 300, radius: 10 });
        // 45

        this.points = new PointList(
                // this.center.add(-r, 0)
                pointA
                // , this.center.add(0, r * -.5)
                , pointB
                // , this.center.add(r, 0)
                , pointC
                , pointD
            )

        this.points[1].radius = 30
        this.points[0].radius = this.points[1].radius = shareSize
        this.points[0].color = "hsl(299deg 62% 44%)"
        this.points[1].color = "hsl(244deg 71% 56%)"

        this.near = this.center.copy()


        // this.dis = new Distances
        // this.dis.addPoints(this.center, this.point0, this.point1)
        this.dis = new Dragging
        this.dis.initDragging(this)
        this.dis.onDragMove = this.onDragMove.bind(this)
        // this.dis.onDragEnd = this.onDragEnd.bind(this)
        this.dis.addPoints(...this.points)

    }


    drawArc(ctx, startPoint, midPoint, endPoint, r=midPoint.radius) {
      // ctx.moveTo(startPoint.x, startPoint.y);
      ctx.arcTo(midPoint.x, midPoint.y, endPoint.x, endPoint.y, r);
      // ctx.lineTo(endPoint.x, endPoint.y);
    }



================================================================================
END: arc-point-line-alt.js
================================================================================



================================================================================
FILE: arc-pointlist-another-alt.js
================================================================================

/*
title: Arc Pointlist Another Alt
*/
const arcLoop = function(ctx, points) {

    /*
    From start point, project of radius towards the next.
    Then arcTo until exausted.
    */
    //
    let pl = points.length;
    let startPoint = points.first()
    let nextPoint = points[1]

    let last = points[pl-1]

    // ctx.arc(last.x, last.y, last.radius, 0, 1);
    startPoint.turnTo(last)
    // startPoint.rotation = 90
    let start = startPoint.project()

    ctx.strokeStyle = 'red'

    ctx.beginPath();
    // ctx.moveTo(startPoint.x, startPoint.y);

    let previousPoint = start

    for (var i = 0; i < pl; i++) {
        let p = points[i]
        let nextPoint = points[i+1]
        if(nextPoint == undefined) {
            nextPoint = points[0]
        }

        let toPoint = p;
        let r = p.radius
        // p.rotation -= 90
        // toPoint = p.project()
        // ctx.moveTo(toPoint.x, toPoint.y);
        // p.rotation += 180
        // toPoint = p.project()
        // ctx.arcTo(previousPoint.x, previousPoint.y, toPoint.x, toPoint.y, r);
        p.turnTo(previousPoint)
        p.rotation += 90
        let v1 = p.radians
        // let v1 = p.lookAt(previousPoint)
        p.lookAt(nextPoint)
        p.rotation -= 90
        let v2 = p.radians

        /* Draw an arc ay position {x y}, at a radius, from angle A to B.
        e.g. Spin like a clock-hand from 10 to 3 */
        ctx.arc(toPoint.x, toPoint.y, r, v1, v2);
        previousPoint = p
    }


    startPoint.turnTo(last)
    startPoint.rotation += 90
    start = startPoint.project()

    ctx.lineTo(start.x, start.y);
    // ctx.arcTo(startPoint.x, startPoint.y, midPoint.x, midPoint.y, startPoint.radius);
    // ctx.arcTo(midPoint.x, midPoint.y, nextPoint.x, nextPoint.y, startPoint.radius);

}


/*
Test is the midPoint creates an concave angle relative to the two given points.
 */
const isConcave = function(previousPoint, p, nextPoint) {
    return calculateAngle(p, nextPoint) > 180
    // return obtuseBisect(previousPoint, p, nextPoint) > -1
}

const lineLoop = function(ctx, points) {

    /*
    From start point, project of radius towards the next.
    Then arcTo until exausted.
    */
    //
    let pl = points.length;
    let startPoint = points.first()
    let nextPoint = points[1]

    let last = points[pl-1]

    // ctx.arc(last.x, last.y, last.radius, 0, 1);
    startPoint.lookAt(last)
    // startPoint.rotation = 90
    let start = startPoint.project()

    ctx.strokeStyle = 'red'

    ctx.beginPath();
    // ctx.moveTo(startPoint.x, startPoint.y);



================================================================================
END: arc-pointlist-another-alt.js
================================================================================



================================================================================
FILE: arc-radial-alt.js
================================================================================

/*
---
title: Arc Angle
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
 */

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:200, radius: 100, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:350, y:150})
        this.dragging.addPoints(this.centerPoint
                                , this.fromPoint
                                , this.toPoint)

    }

    draw(ctx){
        this.clear(ctx)
        // a.rotation += .3
        // b.rotation += .5
        ctx.fillStyle = '#555'
        ctx.strokeStyle = 'orange'

        let primaryColor = '#CCC'
        let secondaryColor = '#444'
        let size = 30

        /* Draw an arc from rotation of `a` to rotation `b` */
        // centerPoint.pen.arc(ctx, b, primaryColor, size, 2, 0)
        // let a = this.a;
        // let b = this.b;
        // a.pen.arc(ctx, b, secondaryColor, size-10, 2, 1)
        // b.pen.arc(ctx, a, secondaryColor, size, 2, 0)


        this.centerPoint.pen.indicator(ctx)
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        // this.drawA(ctx)
        // this.drawB(ctx)
        // this.drawC(ctx)
        this.drawD(ctx)
        // this.drawE(ctx)
        // this.drawF(ctx)
    }

    drawD(ctx){

        // let arcPlot = arcFromTo(this.centerPoint, this.fromPoint, this.toPoint)
        /* Get the arc angle drawn */
        let dis = Math.min(200, this.fromPoint.distanceTo(this.toPoint))
        let p2 = getRadiusPlot(this.fromPoint, this.toPoint, dis)
        if(!p2) {return}
        // Point.from(p2[1]).pen.indicator(ctx)
        let c = Point.from(p2[0])
        let c2 = Point.from(p2[1])
        c.radius = c2.radius = dis
        c.pen.circle(ctx, {color: "#333"})
        c2.pen.circle(ctx, {color: "#333"})

        ctx.beginPath()

        let arcPlot = arcFromTo(c, this.fromPoint, this.toPoint)
        penArcPlot(arcPlot, ctx, 'orange')
        // drawArcPlot(arcPlot, ctx, 'orange')

        // let arcPlot2 = arcFromTo(c2, this.fromPoint, this.toPoint)
        let arcPlot2 = arcFromTo(c2, this.toPoint, this.fromPoint, 1)
        // let arcPlot2 = arcFromTo(c2, this.toPoint, this.fromPoint)
        penArcPlot(arcPlot2, ctx, 'orange')
        // drawArcPlot(arcPlot2, ctx, 'orange')
        // ctx.fill()

        // ctx.stroke()


================================================================================
END: arc-radial-alt.js
================================================================================



================================================================================
FILE: arc-radial-polygon.js
================================================================================

/*
---
title: Arc Angle
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
 */

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:200, radius: 100, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:350, y:150})
        this.dragging.addPoints(this.centerPoint
                                , this.fromPoint
                                , this.toPoint)

    }

    draw(ctx){
        this.clear(ctx)
        // a.rotation += .3
        // b.rotation += .5
        ctx.fillStyle = '#555'
        ctx.strokeStyle = 'orange'

        let primaryColor = '#CCC'
        let secondaryColor = '#444'
        let size = 30

        /* Draw an arc from rotation of `a` to rotation `b` */
        // centerPoint.pen.arc(ctx, b, primaryColor, size, 2, 0)
        // let a = this.a;
        // let b = this.b;
        // a.pen.arc(ctx, b, secondaryColor, size-10, 2, 1)
        // b.pen.arc(ctx, a, secondaryColor, size, 2, 0)


        this.centerPoint.pen.indicator(ctx)
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        // this.drawA(ctx)
        // this.drawB(ctx)
        // this.drawC(ctx)
        // this.drawD(ctx)
        this.drawE(ctx)
        // this.drawF(ctx)
    }

    drawA(ctx){

        let arcPlot = arcFromTo(this.centerPoint, this.fromPoint, this.toPoint)

        penArcPlot(arcPlot, ctx, 'orange')
        /* Get the arc angle drawn */
        let rads = getArcPlotAngle(arcPlot)
        /* Write the degrees at the center. */
        arcPlot.point.text.string(ctx, ~~rads)

    }

    drawB(ctx){

        let arcPlot = arcSweep(this.centerPoint, Math.PI * .5)

        penArcPlot(arcPlot, ctx, 'red')
        /* Get the arc angle drawn */
        let rads = getArcPlotAngle(arcPlot)
        /* Write the degrees at the center. */
        arcPlot.point.text.string(ctx, ~~rads)

    }

    drawC(ctx){

        // let arcPlot = arcFromTo(this.centerPoint, this.fromPoint, this.toPoint)
        /* Get the arc angle drawn */


================================================================================
END: arc-radial-polygon.js
================================================================================



================================================================================
FILE: arc-radial.js
================================================================================

/*
---
title: Arc Angle
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
 */

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:200, radius: 100, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:350, y:150})
        this.dragging.addPoints(this.centerPoint
                                , this.fromPoint
                                , this.toPoint)

    }

    draw(ctx){
        this.clear(ctx)
        // a.rotation += .3
        // b.rotation += .5
        ctx.fillStyle = '#555'
        ctx.strokeStyle = 'orange'

        let primaryColor = '#CCC'
        let secondaryColor = '#444'
        let size = 30

        /* Draw an arc from rotation of `a` to rotation `b` */
        // centerPoint.pen.arc(ctx, b, primaryColor, size, 2, 0)
        // let a = this.a;
        // let b = this.b;
        // a.pen.arc(ctx, b, secondaryColor, size-10, 2, 1)
        // b.pen.arc(ctx, a, secondaryColor, size, 2, 0)


        this.centerPoint.pen.indicator(ctx)
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        // this.drawA(ctx)
        // this.drawB(ctx)
        this.drawC(ctx)
        // this.drawD(ctx)
        // this.drawE(ctx)
        // this.drawF(ctx)
    }


    drawC(ctx){

        // let arcPlot = arcFromTo(this.centerPoint, this.fromPoint, this.toPoint)
        /* Get the arc angle drawn */
        let dis = Math.min(200, this.fromPoint.distanceTo(this.toPoint))
        let p2 = getRadiusPlot(this.fromPoint, this.toPoint, dis)
        if(!p2) {return}
        // Point.from(p2[1]).pen.indicator(ctx)
        let c = Point.from(p2[0])
        let c2 = Point.from(p2[1])
        c.radius = c2.radius = dis
        c.pen.circle(ctx, {color: "#333"})
        c2.pen.circle(ctx, {color: "#333"})

        let arcPlot = arcFromTo(c, this.fromPoint, this.toPoint)
        penArcPlot(arcPlot, ctx, 'orange')

        // let arcPlot2 = arcFromTo(c2, this.fromPoint, this.toPoint)
        // penArcPlot(arcPlot2, ctx, 'orange')

        let arcPlot2 = arcFromTo(c2, this.toPoint, this.fromPoint)
        penArcPlot(arcPlot2, ctx, 'orange')

    }

}



================================================================================
END: arc-radial.js
================================================================================



================================================================================
FILE: arc-sweep.js
================================================================================

/*
---
title: Arc Angle
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
 */

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:200, radius: 100, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:350, y:150})
        this.dragging.addPoints(this.centerPoint
                                , this.fromPoint
                                , this.toPoint)

    }

    draw(ctx){
        this.clear(ctx)
        ctx.fillStyle = '#555'
        ctx.strokeStyle = 'orange'

        this.centerPoint.pen.indicator(ctx)
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        // this.drawA(ctx)
        this.drawB(ctx)
    }

    drawB(ctx){

        let arcPlot = arcSweep(this.centerPoint, Math.PI * .5)

        penArcPlot(arcPlot, ctx, 'red')
        /* Get the arc angle drawn */
        let rads = getArcPlotAngle(arcPlot)
        /* Write the degrees at the center. */
        arcPlot.point.text.string(ctx, ~~rads)

    }

}



;stage = MainStage.go();

================================================================================
END: arc-sweep.js
================================================================================



================================================================================
FILE: arc-three-point.js
================================================================================

/*
---
title: Arc Three Point.
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
---

Draw an arc to another point _through_ a third point.

*/

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:150, radius: 20, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:350, y:150})
        this.dragging.addPoints(this.centerPoint, this.fromPoint, this.toPoint)
    }

    draw(ctx){
        this.clear(ctx)

        ctx.fillStyle = '#555'
        ctx.strokeStyle = 'orange'

        this.centerPoint.pen.circle(ctx, undefined, '#555')
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        this.drawF(ctx)
    }

    drawF(ctx){

        let cap = this.toPoint.arc.to(this.fromPoint, this.centerPoint)

        ctx.beginPath();
        ctx.arc(cap.cx, cap.cy, cap.radius, cap.startRadians, cap.toRadians);
        ctx.stroke();

        ctx.fillStyle = '#ddd'
        this.centerPoint.text.string(ctx, ~~cap.radius)
    }
}


;stage = MainStage.go();

================================================================================
END: arc-three-point.js
================================================================================



================================================================================
FILE: arrangement-linear-manual.js
================================================================================

/*
title: Linear Arrangement
categories: arrange
files:
    head
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    stage
    point
    pointlist
    ../point_src/distances.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/dragging.js
    stroke
    ../point_src/relative.js
    ../point_src/automouse.js
    ../point_src/collisionbox.js

*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted() {
        let spread = 80
        this.pointA = PointList.generate.list(3, spread, [100,100 + spread]);
        this.pointB = PointList.generate.list(5, spread, [250,100]);
        this.pointC = PointList.generate.list(3, spread, [400,100 + spread]);
        this.pointA.each.radius = this.pointB.each.radius = this.pointC.each.radius = 15
        // this.dragging.add(...this.pointA);
    }

    draw(ctx) {
        this.clear(ctx);
        this.pointA.pen.circle(ctx, undefined, 'purple', 2);
        this.pointB.pen.circle(ctx, undefined, 'purple', 2);
        this.pointC.pen.circle(ctx, undefined, 'purple', 2);
    }

}

stage = MainStage.go()


================================================================================
END: arrangement-linear-manual.js
================================================================================



================================================================================
FILE: ball-bearing.js
================================================================================

/*
title: Ball Bearing
categories: ball
    constraint
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/rel.js
    dragging
    ../point_src/constrain-distance.js


Simulate collisions using a _string_. Here we replicate one of those
little balls inside a circle
*/

// var gravity = {x: 0, y:-0.05}; // Gravity constant for helium balloon.
var gravity = {x: 0, y:1}; // Gravity constant

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        // this.mouse.position.vy = this.mouse.position.vx = 0

        this.pin = new Point({ x: 200, y: 200, radius: 140, vx: 0, vy: 0})
        this.point = new Point({ x: 300, y: 100, vx: 0, vy: 0})
        this.dragging.add(this.pin, this.point)
    }

    draw(ctx) {
        this.clear(ctx);

        let pin = this.pin
        let other = this.point
        let settings = {
            gravity
            , forceMultiplier: .9
            , dotDamping: .17
            , damping: .98
            , distance: pin.radius - other.radius - 2
        }

        settings = {
            gravity
            , forceMultiplier: 1
            // , dotDamping: .17
            // , damping: .98
            , distance: pin.radius - other.radius - 2
        }

        pin.constraint.string(other, settings)
        pin.pen.circle(ctx, {color:'red'})
        other.pen.indicator(ctx)

    }
}

const stage = MainStage.go()


================================================================================
END: ball-bearing.js
================================================================================



================================================================================
FILE: balloon-2.js
================================================================================

/*
title: Better Balloon
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
    ../point_src/rope.js
---

The _other_ balloon example uses one rope with negative gravity.

In this version there are two ropes. One (hidden) rope connecting the balloon
and the pin, and a second (rendered) rope, with the two pinned ends matching
the balloon rope - with _correct_ gravity.

*/

// const distance = 5;
const gravity2D = {x:0, y:-8.9};
// const gravity = 0.35;
const friction = 0.9;


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })
    }

    /*  GPT 4.5 absolutely knocked it out the park.*/
    mounted() {
        this.numPoints = 20;
        this.segmentLength = 10;
        this.gravity = -.31;
        this.gravity2D = gravity2D

        let initPos = this.center.copy()
        this.points = this.ropePoints(initPos, this.numPoints * .5)
        this.points2 = this.ropePoints(initPos, this.numPoints)
        let penUlt = this.points[this.points.length - 3]
        // penUlt.invMass = 200
        let lastPoint = this.points.last()
        lastPoint.invMass = .2
        lastPoint.radius = 60

        this.ropeReactor = new RopeReactor()
        this.ropeReactor2 = new RopeReactor()

        this.points[0].copy(initPos.add(10,100))
        this.points2[0].copy(initPos.add(10,100))


        this.ropeReactor2.pin(0)
        this.ropeReactor.pin(0)
        this.ropeReactor2.pin(this.points2.length-1, this.points[this.points.length - 3])
        // this.ropeReactor2.pin(5)

        this.dragging.add(
                this.points[0]
                // , this.points2[0]
                , lastPoint
            )
    }

    ropePoints(initPos, numPoints){
        let points = Array.from({ length: numPoints }, () => ({
            x: initPos.x,
            y: initPos.y,
            oldX: initPos.x,
            oldY: initPos.y,
        }));
        // points[9].invMass = .01
        return new PointList(...points).cast()
    }

    draw(ctx) {
        this.clear(ctx);

        /* A viscous fluid, applied through 2d invMass*/
        // this.applyPhysics2(this.points, this.gravity2D, [1, this.points.length-1]);
        let ropeReactor = this.ropeReactor
        let ropeReactor2 = this.ropeReactor2
        this.points2[0].xy = this.points[0].xy


        /* Rope like mass physics.*/
        ropeReactor.applyPhysics(this.points, this.gravity);
        ropeReactor2.applyPhysics(this.points2, -this.gravity);


================================================================================
END: balloon-2.js
================================================================================



================================================================================
FILE: balloon-3.js
================================================================================

/*
title: Better Balloon
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    ../point_src/collisionbox.js
    dragging
    ../point_src/random.js
    ../point_src/rope.js
    ../theatre/objects/balloon.js

---

The _other_ balloon example uses one rope with negative gravity.

In this version there are two ropes. One (hidden) rope connecting the balloon
and the pin, and a second (rendered) rope, with the two pinned ends matching
the balloon rope - with _correct_ gravity.

*/

// const distance = 5;
// const gravity2D = {x:0, y:8.9};
// const gravity = 0.35;
// const friction = 0.9;

class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        this.balloon = new Balloon({
            // gravity: .3
            // invMass: -13
             color: '#44BB22'
            , knotColor: '#229900'
            , ropeColor: '#aaa'
            , position: this.center.copy()
        })

        // this.balloon.mounted(this.center.copy())

        this.balloon2 = new Balloon()
        this.balloon2.mounted(this.center.copy().add(50))

        this.balloon3 = new Balloon()
        this.balloon3.mounted(this.center.copy().add(-50))

        this.collisionBox = new CollisionBox([
                            this.balloon.head
                            , this.balloon2.head
                            , this.balloon3.head
                        ])

        this.dragging.add(
            this.balloon.handle
            , this.balloon2.handle
            , this.balloon3.handle
            // , this.points2[0]
            // , lastPoint
        )
    }

    draw(ctx) {
        this.clear(ctx);

        ctx.fillStyle = '#999'
        ctx.font = 'normal 30px lexend deca'
        ctx.textAlign = 'center'
        this.collisionBox.shuffle()

        this.balloon.draw(ctx)
        this.balloon2.draw(ctx)
        this.balloon3.draw(ctx)
    }

}


;stage = MainStage.go();

================================================================================
END: balloon-3.js
================================================================================



================================================================================
FILE: balloon.js
================================================================================

/*
title: Pinnable Rope
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
    ../point_src/rope.js
---

A very pinnable verlet constraint chain for a rope-like catenary solution.

*/

// const distance = 5;
const gravity2D = {x:0, y:-8.9};
// const gravity = 0.35;
const friction = 0.9;



class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })
    }

    /*  GPT 4.5 absolutely knocked it out the park.*/
    mounted() {
        this.numPoints = 15;
        this.segmentLength = 20;
        this.gravity = -.31;
        this.gravity2D = gravity2D

        let initPos = this.center.copy()
        this.points = Array.from({ length: this.numPoints }, () => ({
            x: initPos.x,
            y: initPos.y,
            oldX: initPos.x,
            oldY: initPos.y,
        }));
        // this.points[9].invMass = .01
        this.points = new PointList(...this.points).cast()
        let lastPoint = this.points.last()
        lastPoint.invMass = .2
        this.dragging.add(this.points[0], lastPoint)
        lastPoint.radius = 80
        this.ropeReactor = new RopeReactor()
        // this.ropeReactor.mouse = this.mouse
        this.points[0].copy(initPos.add(10,100))
        this.ropeReactor.pin(0)
    }

    draw(ctx) {
        this.clear(ctx);

        /* A viscous fluid, applied through 2d invMass*/
        // this.applyPhysics2(this.points, this.gravity2D, [1, this.points.length-1]);
        let ropeReactor = this.ropeReactor
        /* Rope like mass physics.*/
        ropeReactor.applyPhysics(this.points, this.gravity);
        // ropeReactor.applyPhysics2(this.points, this.gravity2D)

        /* Different solving methods */
        // this.solveConstraints1(this.points, this.segmentLength);
        // this.solveConstraints2(this.points, this.segmentLength);
        ropeReactor.solveConstraints3(this.points, this.segmentLength);
        ctx.fillStyle = '#999'
        ctx.font = 'normal 30px lexend deca'
        ctx.textAlign = 'center'
        // this.points.pen.indicator(ctx);
        this.points.pen.quadCurve(ctx, '#AAA');
        let penUlt = this.points[this.points.length - 5]
        let last = this.points.last()
        this.points[0].pen.indicator(ctx)
        last.lookAt(penUlt)//, Math.PI *.5)
        // last.pen.indicator(ctx)
        let color = '#990000'
        // penUlt.pen.indicator(ctx)
        last.pen.fill(ctx, {color: color})
        last.pen.indicator(ctx, {color: '#770000'})
        penUlt.pen.fill(ctx, color)
        // last.text.label(ctx, 'Polypoint')
    }

}


;stage = MainStage.go();

================================================================================
END: balloon.js
================================================================================



================================================================================
FILE: bilko-twelve.js
================================================================================

/*
title: Egg 2
src_dir: ../point_src/
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
---

 */
class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        let size = 200
        let spin = .44
        // let pj = this.projectionLength = size * ((Math.sin(spin) + Math.cos(spin) ) * .5)
        this.createPoints(size)

        this.dragging.add(...this.points, ...this.controlPoints)

        // this.lineStroke = new Stroke({
        //     color: '#fff'
        //     , width: 2
        //     , dash: [7, 4]
        // })

        // this.lineStroke2 = new Stroke({
        //     color: '#CCC'
        //     , width: 2
        //     , dash: [7, 4]
        // })

        // this.events.wake()
    }

    createPoints(width=200) {
        let x = 400
            , x2 = width + x
            , y = 300

        this.points = new PointList(
            new Point(x, y, 100)
            , new Point(x2, y, 100)
        )

        // this.eggPoints = new PointList(
        //     new Point(x, y, pj)
        //     , new Point(x2, y, pj)

        //     , new Point(x, y, pj, 90)
        //     , new Point(x2, y, pj, 90)
        // )


        this.controlPoints = new PointList(
            this.points[0].project()
            , this.points[1].project()
            // , this.eggPoints[2].project()
            // , this.eggPoints[3].project()
        )

        let stage = this;
        this.controlPoints.forEach((p,i)=>{

            p.onDragStart = function() {
                // console.log('Drag start')
                this._release = true;
            }

            p.onDragMove = function() {
                // console.log('Drag move')
                stage.controlPointsDistances[i] = stage.controlPoints[i].distance2D(
                        stage.points[i])

            }

            p.onDragEnd = function() {
                // console.log('Drag end')
                stage.controlPointsDistances[i] = stage.controlPoints[i].distance2D(
                        stage.points[i])


================================================================================
END: bilko-twelve.js
================================================================================



================================================================================
FILE: bisect-example.js
================================================================================

/*
title: Bisector
categories: bisect
files:
    head
    point
    stage
    pointlist
    mouse
    dragging
    ../point_src/bisector.js
---

In this example the mid-point always looks through the bisect of the two
plot points.

    let rads = acuteBisect(
            pointA,
            midPoint,
            pointB
        );
    midPoint.radians = rads;
*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true

    mounted(){
        let a = this.pa = new Point(150, 150, 20, 90)
        let b = this.pb = new Point(400, 250, 20, 90)
        let m = this.mid = new Point(200, 300, 60, 100)
        this.dragging.add(a,b, m)
    }

    coupling() {
    }

    draw(ctx){
        this.clear(ctx)
        this.mid.radians = acuteBisect(this.pa, this.mid, this.pb)
        this.pa.pen.fill(ctx, '#AA33CC')
        this.pb.pen.fill(ctx, '#AA33CC')
        this.mid.pen.indicator(ctx)
    }
}

;stage = MainStage.go();

================================================================================
END: bisect-example.js
================================================================================



================================================================================
FILE: blob-example.js
================================================================================

/*
title: Blob
category: soft-body
files:
    ../point_src/math.js
    head
    ../point_src/point-content.js
    pointlist
    point
    mouse
    stage
    dragging
    ../point_src/table.js

A Soft-body block point, with options to configure how blobby it should be.
(selection `f` is my favourite)
*/
let canvas, ctx;
let render, init;
let blob;


// const elasticityDefault = 0.0001;
// const frictionDefault = 0.065;
// const frictionDefault = 0.0085;
// const numPointsDefault = 32;

// const numPointsDefault = 8
// const elasticityDefault = 0.004;
// const frictionDefault = 0.04;

let oldMousePoint = { x: 0, y: 0};
let hover = false;


let keys = [
      "radius"
    , "elasticity"
    , "friction"
    , "numPoints"
]

const confTable = new Table(keys, {
      'default': [50, .0004,  0.04, 32,]
      , 'd':     [150, .0004,  0.04, 32,]
      , 'a':     [150, .0001,  0.065, 8,]
      , 'b':     [150, .0001,  0.065, 32,]
      , 'c':     [150, .0004,  0.086, 36,]
      , 'e':     [150, .0004,  0.04, 14,]
      , 'f':     [150, .004,  0.04, 24,]
      , 'g':     [150, .0001,  0.0084, 34,]
      , 'h':     [150, .0006,  0.0054, 34,]
      , 'i':     [150, .0009,  0.0084, 5,]
      , 'j':     [150, .001,  0.0054, 45,]
})


var settings = confTable.get('j')

// const elasticityDefault = settings.elasticity
// const frictionDefault = settings.friction
// const numPointsDefault = settings.numPoints


addControl('slider', {
    field: 'range'
    , stage: this
    , onchange(ev) {
        /*slider changed. */
        // debugger;
        let sval = ev.currentTarget.value
        this.stage.offset = parseFloat(sval) * .01
    }
})

addControl('choice', {
    field: 'select'
    , options: confTable.getKeys()
    , stage: this
    , onchange(ev) {
        let sval = ev.currentTarget.value
        settings = confTable.get(sval)
        console.log('change settings', sval)
        stage.mounted()
    }
})


class MyStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.center.radius = settings.radius
        blob = new Blob(this.center);
        blob.canvas = this.canvas;
        blob.init();
        // this.events.wake()
    }

    onMousemove(e) {



================================================================================
END: blob-example.js
================================================================================



================================================================================
FILE: blur-example.js
================================================================================

/*
title: Blur Example
files:
    head
    point
    stage
    dragging
    pointlist
    point
    mouse
    stroke
    ../point_src/text/beta.js
---

*/

class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        // let p = new Point(400, 400, 140)

        this.point = new Point({x: 250, y: 150 , radius: 100})
        this.dragging.add(this.point)
    }

    firstDraw(ctx){
        this.clear(ctx)
        ctx.strokeStyle = ctx.fillStyle = '#ddd'
        ctx.font = '50px sans-serif'

        let p = this.dragging.getPoint();
        if(p) { p.pen.circle(ctx) }

        // ctx.filter = 'blur(4px)'
        this.point.text.string(ctx, 'text.string')

        // ctx.filter = newull
        ctx.fillStyle = 'red'
        this.point.pen.indicator(ctx)


    }

}


stage = MainStage.go();


================================================================================
END: blur-example.js
================================================================================



================================================================================
FILE: brain.js
================================================================================

/*
title: Brain.js Neural Network Library
*/

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.brain = {}));
}(this, (function (exports) { 'use strict';

    /**
     * Relu Activation, aka Rectified Linear Unit Activation
     * @description https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
     */
    function activate$3(weight) {
        return Math.max(0, weight);
    }
    /**
     * Relu derivative
     */
    function measure$3(weight, delta) {
        if (weight <= 0) {
            return 0;
        }
        return delta;
    }

    var relu$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activate: activate$3,
        measure: measure$3
    });

    /**
     * sigmoid activation
     */
    function activate$2(value) {
        return 1 / (1 + Math.exp(-value));
    }
    /**
     * sigmoid derivative
     */
    function measure$2(weight, error) {
        return weight * (1 - weight) * error;
    }

    var sigmoid$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activate: activate$2,
        measure: measure$2
    });

    /**
     * Hyperbolic tan
     */
    function activate$1(weight) {
        return Math.tanh(weight);
    }
    /**
     * @description grad for z = tanh(x) is (1 - z^2)
     */
    function measure$1(weight, error) {
        return (1 - weight * weight) * error;
    }

    var tanh$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activate: activate$1,
        measure: measure$1
    });

    /**
     * Leaky Relu Activation, aka Leaky Rectified Linear Unit Activation
     * @description https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
     */
    function activate(weight) {
        return weight > 0 ? weight : 0.01 * weight;
    }
    /**
     * Leaky Relu derivative
     */
    function measure(weight, error) {
        return weight > 0 ? error : 0.01 * error;
    }

    var leakyRelu$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activate: activate,
        measure: measure
    });

    var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        relu: relu$2,
        sigmoid: sigmoid$2,
        tanh: tanh$2,
        leakyRelu: leakyRelu$1
    });

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};


================================================================================
END: brain.js
================================================================================



================================================================================
FILE: bridged-line.js
================================================================================

/*
title: Example
categories: basic
    dragging
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    stroke
    ../point_src/constrain-distance.js
    ../point_src/split.js
---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
                        [250 , 50, 20]
                        , [250 , 170, 20, -90]
                        , [250 , 290, 20]
                    ).cast()
        this.dragging.add(...this.points)
    }

    draw(ctx){
        this.clear(ctx)
        this.tick += 1
        let ps = this.points
        let tips = ps[1].split(2, Math.PI, Math.PI*.5)

        // ps[0].pen.line(ctx, tips[0])
        // tips[1].pen.line(ctx, ps[2])

        ;(new PointList(ps[0], ...tips, ps[2])).pen.quadCurve(ctx, undefined,)

        tips.pen.indicator(ctx, 'green')
        ps.pen.indicator(ctx, 'green')

        // ps.pen.line(ctx, 'green')
        // ps.pen.quadCurve(ctx)
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: bridged-line.js
================================================================================



================================================================================
FILE: bridged-loop.js
================================================================================

/*
title: Example
categories: basic
    dragging
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    stroke
    ../point_src/constrain-distance.js
    ../point_src/split.js
---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
                        [250 , 50, 20, 40]
                        , [250 , 170, 20, -90]
                        , [250 , 290, 20, -90]
                    ).cast()
        this.dragging.add(...this.points)
    }

    draw(ctx){
        ctx.fillStyle = '#444'
        this.clear(ctx)
        this.tick += 1
        let ps = this.points
        let tips = ps[0].split(2, Math.PI, Math.PI*.5)
        let tips1 = ps[1].split(2, Math.PI, Math.PI*.5)
        let tips2 = ps[2].split(2, Math.PI, Math.PI*.5)

        // ps[0].pen.line(ctx, tips[0])
        // tips[1].pen.line(ctx, ps[2])

        ;(new PointList(...tips, ...tips1, ...tips2)).pen.quadCurve(ctx, undefined,1)

        ctx.fill()
        tips.pen.indicator(ctx, 'green')
        tips1.pen.indicator(ctx, 'green')
        tips2.pen.indicator(ctx, 'green')
        ps.pen.indicator(ctx, 'green')
        // ps.pen.line(ctx, 'green')
        // ps.pen.quadCurve(ctx)
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: bridged-loop.js
================================================================================



================================================================================
FILE: brownian-point-blur.js
================================================================================

/*
title: Brownian Blur
categories: brownian
    random
    blur
files:
    head
    point
    stage
    mouse
    dragging
    stroke
    ../point_src/random.js
---

In this example we simply turn off the `clear` call to allow allow a persistent
canvas. For each step (`stage.count`) performs hundreds of randomly positioned points,
using the `random.within` function.

As this function uses `Math.random` roughly 36k times per second, we gain a good insight to
_how random_ the random function is.

If this function was **truly random** the image should resolve to a pure sphere.
However you may to see a persistent pattern with micro gaps (undrawn dark spots).

The gaps show the random function doesn't generate _some_ numbers.
Given the image stabilises over time (it essentially stops changing) shows the random
repeats the same numbers after a certain period.

```
xy = random.within(point, max=.5)
```
*/

class MainStage extends Stage {
    canvas = 'playspace'
    updateSpeed = 1
    mounted(){
        this.count = 1000
        this.pixelColor = '#fff'
        this.pin = this.center.copy().update({radius: 200})
        this.point = new Point({radius: .3})
        this.dragging.add(this.pin)

        addControl('updateSpeed', {
            field: 'range'
            , label: 'update speed'
            , step: 1
            , max: 200
            , stage: this
            , onchange(ev) {
                /*slider changed. */
                let sval = ev.currentTarget.value
                this.stage.updateSpeed = parseInt(Math.sqrt(this.max)*2 + 1) - parseInt(Math.sqrt(sval)*2)
            }
        })
    }

    firstDraw(ctx) {
        this.pin.pen.fill(ctx, '#222255')
        ctx.fillStyle = this.pixelColor
    }

    draw(ctx) {
        // this.clear(ctx)
        let count = this.count;
        let p = this.point
        for(var i = count - 1; i >= 0; i--) {
            this.updateWalker()
            ctx.beginPath()
            p.draw.arc(ctx, p.radius)
            ctx.fill()
        }

        // this.point.pen.fill(ctx, this.pixelColor)
    }

    updateWalker(max=.5) {
        this.point.xy = random.within(this.pin, max)
    }

}

stage = MainStage.go({ loop: true })


================================================================================
END: brownian-point-blur.js
================================================================================



================================================================================
FILE: brownian-point.js
================================================================================

/*
title: Brownian Within a Point
categories: brownian
    random
files:
    head
    point
    stage
    mouse
    dragging
    stroke
    ../point_src/random.js
---

Plot a random point within a location.

```
   xy = random.within(point, max=.5)
```
*/

class MainStage extends Stage {
    canvas = 'playspace'
    updateSpeed = 10
    mounted(){
        this.modu = 0
        this.pin = this.center.copy().update({radius: 200})
        this.point = new Point()
        this.dragging.add(this.pin)

        addControl('updateSpeed', {
            field: 'range'
            , label: 'update speed'
            , step: 1
            , max: 200
            , stage: this
            , onchange(ev) {
                /*slider changed. */
                let sval = ev.currentTarget.value
                this.stage.updateSpeed = parseInt(Math.sqrt(this.max)*2 + 1) - parseInt(Math.sqrt(sval)*2)
            }
        })
    }

    draw(ctx) {
        this.clear(ctx)
        this.modu += 1
        this.modu % this.updateSpeed == 0 && this.updateWalker()

        this.pin.pen.fill(ctx, '#222255')
        this.point.pen.fill(ctx, '#ddd')
    }

    updateWalker(max=.5) {
        this.point.xy = random.within(this.pin, max)
    }

}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: brownian-point.js
================================================================================



================================================================================
FILE: brownian-walker-raw.js
================================================================================

/*
title: Brownian Within a Point
categories: brownian
    random
files:
    head
    point
    stage
    mouse
    dragging
    stroke
    ../point_src/random.js
    ../point_src/relative.js

---

A tiny walker to move towards a browian point.
*/

class MainStage extends Stage {
    canvas = 'playspace'
    updateSpeed = 50
    lookSpeedUpdateSpeed = 10
    touchSpaceUpdateSpeed = 10
    forwardSpeed = 1
    turnSpeed = .1
    maxTouchDistance = 10
    viewSpaceOffset = -20
    viewSpaceMultiplerSize = 10

    mounted(){
        this.modu = 0
        let bodySize = 5

        this.point = this.center.copy().update({radius:bodySize, rotation: random.int(360)})
        this.updateLookSpace()
        this.viewPoint = this.center.copy()
        this.updateWalker()
        this.dragging.add(this.point)
    }


    draw(ctx) {
        this.clear(ctx)
        this.updateAll()

        this.viewSpace.pen.circle(ctx, '#222255')
        this.viewPoint.pen.fill(ctx, 'red', 1)
        this.point.pen.indicator(ctx, '#ddd')
    }

    updateAll(){
        this.modu += 1
        this.modu % this.updateSpeed == 0 && this.updateWalker()
        this.modu % this.lookSpeedUpdateSpeed == 0 && this.updateLookSpace()
        this.modu % this.touchSpaceUpdateSpeed == 0 && this.updateTouchSpace()

        this.point.turnTo(this.viewPoint, this.turnSpeed)
        this.point.relative.forward(this.forwardSpeed)

        let didChange = this.screenWrap(this.point)
        if(didChange) {
            this.updateWalker(.5)
        }
    }

    screenWrap(p, topLeft=[100, 100], bottomRight=[400, 400]) {
        /* wrap */
        let didChange = false;
        let px, opx = p.x
        let py, opy = p.y


        if(opx < topLeft[0]) {
            px = bottomRight[0]
        }

        if(opy < topLeft[1]) {
            py = bottomRight[1]
        }


        if(opx > bottomRight[0]) {
            px = topLeft[0]
        }

        if(opy > bottomRight[1]) {
            py = topLeft[1]
        }

        if(px != undefined) {
            p.x = px
            didChange = true
        }

        if(py != undefined) {
            p.y = py
            didChange = true
        }



================================================================================
END: brownian-walker-raw.js
================================================================================



================================================================================
FILE: brownian-walker.js
================================================================================

/*
title: Brownian Walker
categories: brownian
    random
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    stroke
    ../point_src/random.js
    ../point_src/functions/range.js
    ../point_src/relative.js
    ../point_src/constrain-distance.js
    ../point_src/screenwrap.js
---

A tiny walker to move towards a browian point.
*/


let fleeSettings = {
    tailLength: 3,
    turnSpeed: .18,
    maxTouchDistance: 6,
    viewSpaceOffset: 10,
    viewSpaceMultiplerSize: 3,
    forwardSpeed: 1.7,
    leashDistanceMultiplier: 2,
    radius: 1.2,
    color: 'green',
}


const sliderValue = function(value, min, max, step) {
    let d = {}
    if(step != undefined) { d.step = step }
    if(value != undefined) { d.value = value }
    if(min != undefined) { d.min = min }
    if(max != undefined) { d.max = max }
    return d;
}

const sliders = {
      tailLength:              sliderValue(   3,   2, 40)
    , turnSpeed:               sliderValue( .18,  .1,  1,  .05)
    , maxTouchDistance:        sliderValue(   6,   6, 20)
    , viewSpaceOffset:         sliderValue(  10,  10, 30)
    , viewSpaceMultiplerSize:  sliderValue(   3,   2, 20)
    , forwardSpeed:            sliderValue( 1.7,  .1,  3,  .10)
    , leashDistanceMultiplier: sliderValue(   2, 1.5, 20,   .2)
    , radius:                  { step: .10, value: 1.2, min: 1, max: 20 }
};

addSliderControlSet(sliders);

addButton('Generate', {
    onclick: ()=> {
        let d = {}
        for(let k in sliders) {
            d[k] = parseFloat(appShared.miniApp.controls[k].value)
        };

        stage.newWalker(Object.assign(d, { x: 300, y: 300}))
    }
})


class Walker extends Point {

    init(d) {
        this.updateSpeed = 20
        this.lookSpeedUpdateSpeed = 10
        this.touchSpaceUpdateSpeed = 10
        this.forwardSpeed = 1
        this.turnSpeed = .2
        this.maxTouchDistance = 10
        this.viewSpaceOffset = -20
        this.viewSpaceMultiplerSize = 10
        this.modu = d.modu ==undefined? 0: d.modu
        this.leashDistanceMultiplier = 1
        this.tailLength = 10

        this.viewPoint = new Point(this.copy())
        this.update(d)
        this.updateLookSpace()
    }

    step(delta=1){
        this.modu += 1
        if(this.modu % this.updateSpeed == 0) {
            this.updateWalker()
        }
        if(this.modu % this.lookSpeedUpdateSpeed == 0) {
            this.updateLookSpace()
        }
        if(this.modu % this.touchSpaceUpdateSpeed == 0) {
            this.updateTouchSpace()


================================================================================
END: brownian-walker.js
================================================================================



================================================================================
FILE: brownian.js
================================================================================

/*
title: Brownian Position (Raw)
categories: brownian
    raw
files:
    head
    point
    stage
---

This (raw) example shows a _random_ position but relative to a home location.
Allowing a randomisation without drifting from a preferred point.

*/

class MainStage extends Stage {
    canvas = 'playspace'
    updateSpeed = 10
    mounted(){
        this.point = new Point(this.center)
        this.modu = 0

        addControl('updateSpeed', {
            field: 'range'
            , label: 'update speed'
            , step: 1
            , max: 200
            , stage: this
            , onchange(ev) {
                /*slider changed. */
                // debugger;
                let sval = ev.currentTarget.value
                this.stage.updateSpeed = parseInt(Math.sqrt(sval)*2)
            }
        })

    }

    draw(ctx) {
        this.clear(ctx)
        this.modu += 1
        this.modu % this.updateSpeed == 0 && this.updateWalker(1, .5)
        this.point.pen.fill(ctx, '#ddd')
    }

    updateWalker(limit=1, max=1) {
        let width = 1024
        let height = 512
        let margin = 10
        let maxMove = width * 0.1 * max
        let x = width * .5
        let y = height * .5
        let precision = 0
        let halfPi = Math.PI / 180

        for (let i = 0; i < limit; i++) {
            let distance = Math.random() * maxMove
            let angle = Math.random() * 360
            let tx = x + distance * Math.sin(halfPi * angle);
            let ty = y + distance * Math.cos(halfPi * angle);
            if( tx > margin
                && tx < (width - margin)
                && ty > margin
                && ty < (height - margin) ) {
                x = +tx.toFixed(precision)
                y = +ty.toFixed(precision)
            }
        }
        this.point.xy = [x,y]
    }

}


stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: brownian.js
================================================================================



================================================================================
FILE: brush-alpha.js
================================================================================

/*
title: Raw Brush
categories: brush
    raw
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/split.js
    ../point_src/gradient.js
---

*/
;(()=>{

// brushSize simply is the thikness of the brush stroke
let mouseX, mouseY;
let brushSize = 10;
let f = 0.5;
let spring = 0.4;
let friction = 0.45;
let v = 0.5;
let r = 0;
let vx = 0;
let vy = 0;
let splitNum = 100;
let diff = 2;

function brushDraw(ctx, mouseIsPressed) {

    let strokeWeight = (v)=>ctx.lineWidth=v;

    let line = function(x1, y1, x2, y2){
        ctx.beginPath(); // Start a new path
        ctx.moveTo(x1, y1); // Move the pen to (30, 50)
        ctx.lineTo(x2, y2); // Draw a line to (150, 100)
        ctx.stroke(); // Render the path
    }

    if(mouseIsPressed) {
        if(!f) {
            f = true;
            x = mouseX;
            y = mouseY;
        }
        vx += ( mouseX - x ) * spring;
        vy += ( mouseY - y ) * spring;
        vx *= friction;
        vy *= friction;

        v += Math.sqrt( vx*vx + vy*vy ) - v;
        v *= 0.6;

        oldR = r;
        r = brushSize - v;

        for( let i = 0; i < splitNum; ++i ) {
            oldX = x;
            oldY = y;
            x += vx / splitNum;
            y += vy / splitNum;
            oldR += ( r - oldR ) / splitNum;
            if(oldR < 1) { oldR = 1; }

            strokeWeight( oldR+diff );  // AMEND: oldR -> oldR+diff
            line( x, y, oldX, oldY );
            strokeWeight( oldR );  // ADD
            line( x+diff*1.5, y+diff*2, oldX+diff*2, oldY+diff*2 );  // ADD
            line( x-diff, y-diff, oldX-diff, oldY-diff );  // ADD
        }

    } else if(f) {
        vx = vy = 0;
        f = false;
    }
}



class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        let c = this.center.copy().update({
                radius: this.center.radius + 40
                , color:"hsl(299deg 62% 44%)"
            })



================================================================================
END: brush-alpha.js
================================================================================



================================================================================
FILE: bubble-box-example.js
================================================================================

/*
title: Bubble Box Example
categories: minimal
    velocity
files:
    head
    point
    pointlist
    stroke
    stage
    mouse
    dragging
    ../point_src/random.js
    ../point_src/screenwrap.js
    ../point_src/velocity.js
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        let pin = this.center.copy().update({radius: .1})
        this.points = PointList.generate.random(1000, 400, pin)
        // this.points = PointList.generate.random(300, 400, pin)

        this.reactor = new VelocityReactor()
        this.reactor.points = this.points
        let direction = new Point(-1, 1)
        this.reactor.randomize()
        this.points.forEach(p=>{
            // speed relative to size.
            p.xy = random.within(pin, 600)
            // turn to direction of travel
            faceVelocity(p)
            let v = p.radius * 12
            let s = 100 - v//(p.velocity.length() * 100)
            p.color = `hsl(200, ${s}%, ${v}%)`
        })
        // this.screenWrap.setDimensions({
        //     top: 100
        //     , left: 100
        //     , bottom: 500
        //     , right: 500
        // })
        // this.dragging.add(this.points)
    }

    draw(ctx){
        this.clear(ctx)
        this.reactor.step()
        // this.points.forEach(p=>this.screenWrap.perform(p))
        this.screenWrap.performMany(this.points)
        // this.points.pen.indicator(ctx)
        this.points.pen.fill(ctx,)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: bubble-box-example.js
================================================================================



================================================================================
FILE: candle-flame-shape.js
================================================================================

/*
title: Flame
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/bisector.js
    ../point_src/functions/clamp.js
    dragging
    mouse
    ../point_src/random.js
    stage
    ../point_src/curve-extras.js
---

A simple _flame_ or teardrop shape, using two origin points for each example.

The shape of the flame is dependant upon the position, radius, and rotation of
the origin points. The result is four points producing two curves.
*/


class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        this.regen()
    }
    regen() {
        this._t = 0
        let ps = this.points = new PointList(
            new Point(120, 300, 50),
            new Point(120, 100, 50),

            new Point(250, 300, 80),
            new Point(250, 100, 70),

            new Point(400, 300, 40),
            new Point(400, 100, 50),
        )

        this.curvesA = this.generateFlame(
            ps[0],
            ps[1]
        )

        this.curvesB = this.generateFlame(
            ps[2],
            ps[3],
            1,
        )

        this.curvesC = this.generateFlame(
            ps[4],
            ps[5],
            60,
        )

        this.curves = [
            this.curvesA[1],
            this.curvesB[1],
            this.curvesC[1],
        ]

        this.plots = [
            this.curvesA[0],
            this.curvesB[0],
            this.curvesC[0],
        ]

    }

    generateFlame(a, b, tilt){
        let plots = this.plotFlame(a, b, tilt)
        let curves = this.createCurves(plots)
        return [plots, curves]
    }

    plotFlame(basePoint, tipPoint, tilt=30) {

        /* The base point is the _foot_ of the flame.*/
        let bRight = basePoint.copy()
        bRight.radians = 0
        let bLeft = bRight.copy()
        bLeft.rotation += 180

        /* the tip generates a sharp tip - to a more rounded tip. */
        let ta = tipPoint.copy()
        ta.rotation = this.compass.down + tilt + (random.int(-20, 20))
        let tb = ta.copy()
        tb.rotation -= tilt * 2

        return new PointList(ta, tb, bLeft, bRight)
    }

    createCurves(plots) {
        let curveA = new BezierCurve(plots[0], plots[2])
        let curveB = new BezierCurve(plots[1], plots[3])


================================================================================
END: candle-flame-shape.js
================================================================================



================================================================================
FILE: catenary-2.js
================================================================================

/*
title: Catenary Example By GPT
categories: raw
  broken
  gpt
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    mouse
    dragging
    stroke
    ../theatre/a.js
---

Spoiler. It's broke.
*/

/**
 * Simple Node/Weight definition
 */
class Node {
  constructor({ x, y, mass = 1, isWeight = false }) {
    this.x = x;
    this.y = y;
    this.mass = mass;
    this.isWeight = isWeight;
  }
}

/**
 * Solve for c so that the catenary y(x) = y0 + c cosh((x - x0)/c)
 * passes exactly through (xA,yA) and (xB,yB), assuming x0 = (xA + xB)/2.
 */
function solveCatenaryParams(xA, yA, xB, yB) {
  // 1) define midpoint x0
  const x0 = (xA + xB) / 2;

  // 2) define F(c) = 0
  function F(c) {
    // The cosh terms
    const coshA = Math.cosh((xA - x0) / c);
    const coshB = Math.cosh((xB - x0) / c);

    // We define y0 from the A condition:
    //    y0 = yA - c coshA
    // Then plug into the B condition => F(c) = [that expression] + c coshB - yB
    return (yA - c * coshA) + c * coshB - yB;
  }

  // 3) We need a numeric approach to solve F(c) = 0 for c.
  //    We'll do a simple bisection between cMin and cMax.
  //    We assume c > 0 always. Let's pick some range for c.
  //    We'll pick cMin = 1e-3, cMax = big. We'll refine until we find a sign change.

  let cMin = 1e-3;
  let cMax = 10000; // large upper guess
  // Check sign of F at min
  let fMin = F(cMin);
  let fMax = F(cMax);

  // If fMin and fMax have the same sign, we may widen cMax more or do other logic.
  // For simplicity, let's do a loop that expands cMax until sign changes or hits a limit:
  let attempts = 0;
  while (fMin * fMax > 0 && attempts < 50) {
    cMax *= 2;
    fMax = F(cMax);
    attempts++;
  }
  // Now do bisection
  for (let i = 0; i < 60; i++) {
    const cMid = (cMin + cMax) / 2;
    const fMid = F(cMid);
    if (Math.abs(fMid) < 1e-7) {
      // close enough
      cMin = cMid;
      cMax = cMid;
      break;
    }
    if (fMid * fMin > 0) {
      // same sign as fMin => move cMin to cMid
      cMin = cMid;
      fMin = fMid;
    } else {
      // move cMax to cMid
      cMax = cMid;
      fMax = fMid;
    }
  }
  const c = (cMin + cMax) / 2;

  // 4) Now compute y0 from the A condition
  const coshA = Math.cosh((xA - x0) / c);


================================================================================
END: catenary-2.js
================================================================================



================================================================================
FILE: catenary-example.js
================================================================================

/*
---
title: Catenary
categories:
    curve
    catenary
files:
    head
    stroke
    pointlist
    point
    mouse
    dragging
    ../point_src/functions/clamp.js
    ../point_src/catenary-curve.js
    ../point_src/curve-extras.js
    stage
 */

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.a = new Point({x:100, y:100, radius: 10, rotation: 0})
        this.b = new Point({x:290, y:200, radius: 10, rotation: 270})
        this.dragging.addPoints(this.a, this.b)
        this.tick = 0
        this.curve = new CatenaryCurve(this.a, this.b, 400)
        // this.curve.useCache = false;
    }

    onClick(ev) {
        console.log('set')
        this.curve.clear()
    }

    draw(ctx){
        this.clear(ctx)
        let a = this.a;
        let b = this.b;
        this.tick += 1
        // this.curve.update(ctx, this.tick)
        // this.curve.updateSwing(ctx, this.tick)
        // this.curve.render(ctx)

        this.curve.draw(ctx)

        a.pen.indicator(ctx)
        b.pen.indicator(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: catenary-example.js
================================================================================



================================================================================
FILE: chars-example.js
================================================================================

/*
title: Char Example
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/image.js

---

*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        // this.dragging.add()
    }

    draw(ctx){
        this.clear(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: chars-example.js
================================================================================



================================================================================
FILE: chord-example.js
================================================================================

/*
title: Circle Chords
category: chords
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    pointlist
    point
    stage
    mouse
    dragging
    stroke
    ../point_src/random.js
---


There are a range of elements to consider for a chord.

+ chord: A line drawn within a circle, edge to edge, equidistant from the center.
+ _segment_: A chord - but non-equidistant. where the points are _anywhere_ around the edge.
+ sagitta: The midpoint project to the edge of the (inside) circle.
+ secant: An extended (to infinite) chord, through two points
+ tangent: A line extended to infinite, touching the outside the circle
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 , radius: 100})
        this.iPoint = new Point({x: 250, y: 150 , radius: 10, rotation: 33})
        this.iPoint2 = new Point({x: 250, y: 250 , radius: 10, rotation: 3})
        this.dragging.add(this.point, this.iPoint, this.iPoint2)
    }

    onMousedown(ev) {
        this.iPoint.rotation = random.int(180)
    }
    draw(ctx){
        this.clear(ctx)

        let p = this.point;
        let chord = this.iPoint
        let chord2 = this.iPoint2
        // chord.xy = this.mouse.point.xy
        chord.pen.indicator(ctx)
        chord2.pen.indicator(ctx)
        let r = chordEndpoints2(p, chord)//, chord2)
        // let r =  chordEndpoints(p, chord)
        // let r =  chordEndpointsRaw(p.x, p.y, p.radius, chord.x, chord.y, chord.radians)
        if(r) {
            r.forEach(d=>{
                (new Point(d)).pen.indicator(ctx)
            });

            (new Point(r[0])).pen.line(ctx, r[1], 'red')
        }

        let spacing = chord.radius
        let count = 10

        gOffsetValue += .2;
        if(gOffsetValue >= spacing) {
            gOffsetValue = 0
        }

        let offset = {x: -(gOffsetValue % spacing), y: -(gOffsetValue % spacing)};

        let pls = generateParallelChordsAutoCountParallel(p, chord, chord2, spacing, offset, true)
        // let pls = generateParallelChordsAutoCountParallel(p, chord, undefined, spacing, offset, true)
        // let pls = generateParallelChordsAutoCountParallel(p, chord, chord2, spacing, offset, false)
        // let pls = generateParallelChordsAutoCountParallel(p, chord, undefined, spacing, offset, false)
        // let pls = generateParallelChordsAutoCountParallel(p, chord, chord2, 10, offset, true, false)
        // let pls = generateParallelChordsAutoCountParallel(p, chord, chord2, spacing, offset, true, false)

        /* _within_ the control point */
        // let pls = generateParallelChordsAutoCountOffset(p, chord, undefined, spacing * .3)
        // let pls = generateParallelChordsAutoCountOffset(p, chord, undefined, 10)
        // let pls = generateParallelChordsAutoCountOffset(p, chord, chord2, 10)
        // let pls = generateParallelChordsAutoCountOffset(p, chord, chord2, 10, false)

        /*  manual count*/
        // let pls = generateParallelChords(p, chord, undefined, spacing, count)
        // let pls = generateParallelChords(p, chord, chord2, spacing, count)

        pls.forEach(pair=>{
            (new Point(pair[0])).pen.line(ctx, pair[1], 'green')
            // pair.forEach(d=>{
            // })
        });

        this.point.pen.indicator(ctx)

    }
}

/**
 * Generates parallel chords automatically covering the circle.


================================================================================
END: chord-example.js
================================================================================



================================================================================
FILE: chord-rect.js
================================================================================

/*
title: Chord Rect
category: chords
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    mouse
    dragging
    stroke
    ../point_src/random.js
    ../point_src/chords.js
---

*/

class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 , radius: 20, rotation: 45})
        this.topLeft = new Point({x: 20, y: 40 , radius: 10})
        this.bottomRight = new Point({x: 500, y: 300 , radius: 10})

        this.dragging.add(this.point, this.topLeft, this.bottomRight)
    }

    onMousedown(ev) {
        this.point.rotation = random.int(180)
    }

    draw(ctx){
        this.clear(ctx)
        let p = this.point
        let tl = this.topLeft
        tl.pen.indicator(ctx)
        let br = this.bottomRight
        br.pen.indicator(ctx)

        let ps = rectChordEndpoints(this.topLeft, this.bottomRight, p)//, p.radians)

        ps = PointList.from(ps).cast()
        // let ps = rectChordEndpoints(20, 500, 40, 300, p[0], p[1], p.radians)
        ps.pen.fill(ctx, {color: 'purple'})
        // ps.forEach(p=> (new Point(p)).pen.fill(ctx, {color: 'purple'}))
        ps[0]?.pen.line(ctx, ps[1], 'purple')
        this.point.pen.indicator(ctx)

    }
}


console.log('chord');


stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: chord-rect.js
================================================================================



================================================================================
FILE: classy-flower.js
================================================================================

/*
title: Flower!
src_dir: ../point_src/
categories: curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/functions/range.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    ../point_src/split.js
    ../point_src/gradient.js
    ../point_src/jiggle.js

---

*/

addButton('Generate', {
    onclick(){
        stage.generate()
    }
});

// const TAU = Math.PI * 2;

class Flower extends Point {
    /*
    flower = new Flower({
        // The general radius of the flower.
        radius: random.int(5, 80)
        // A count of petals.
        , count: random.int(5, 20)
        // The size of petals (Their point radius)
        , size: radius * 3 // random.int(100, 200)
    });
    flower.generate()
    flower.render(ctx)

    */

    // constructor(conf={}) {
    //     this.config = conf;
    //     this.point = conf.point || (new Point)
    // }
    init() {

        let size = this.size // random.int(100, 200)
        this.grad = this.setupGradient(this, size)

        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this._count = 0
        // call once
        this._time = this._time ?? 0;
        this._last = this._last ?? performance.now();

    }

    generate() {
        /* The general radius of the flower. */
        let radius = this.radius //random.int(5, 80)
        /* A count of petals. */
        let count = this.count //random.int(5, 20)
        /* The size of petals (Their point radius) */
        let size = this.size // random.int(100, 200)
        /* We copy the center point to save keystrokes. */
        let p = this.update({radius})

        /* Split on a point, returns many points around the radius. */
        this.points = p.split(count)
        this.points.each.radius = size
        this.points.each.initRadians = (p)=> p.radians

        let lines = this.lines = []
        let length = this.points.length;

        /* Generate many curves. connecting pairs. */
        for (var i = 0; i < length; i++) {
            let nextValue = i + 1;


================================================================================
END: classy-flower.js
================================================================================



================================================================================
FILE: click-arc.js
================================================================================

/*
title: Click Arc
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/stage-clock.js
    ../point_src/text/alpha.js
    ../point_src/text/fps.js
    ../point_src/split.js
    stroke
    dragging

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.additionSpeed = .45

        this.events.wake()
        this.stroke = new Stroke({
            color: 'yellow'
            , width: 4
        })
    }

    onMousedown(ev, point) {
        // console.log('onMousedown', ev)
        let p = point || Point.from(ev)
        p.update({radius: 20})
        this.point = p

        this.stroke.update({color: 'yellow', width: 4})
        this.tickValue = 0
        this.mouseDown = +(new Date)
        this.downPoint = p.copy()
        this.complete = false
        this.unhandled = true
        this.upPoint = undefined
    }

    onMouseup(ev, point) {
        // console.log('onMouseup', ev)
        this.mouseDown = undefined
        let p = point || Point.from(ev)
        this.upPoint = p

        if(this.complete) {
            this.stroke.update({color: '#2299EE'})
            this.activate()
        }
    }

    draw(ctx){
        this.clear(ctx)

        this.spinCon(ctx)
        this.lineProject(ctx,)
        this.fps.drawFPS(ctx);
    }

    lineProject(ctx) {
        let mouse = Point.mouse.position
        let mousePoint = this.upPoint || mouse;
        mouse.pen.indicator(ctx, { color: 'green', width: 3})
        if(this.downPoint) {
            this.isDistant = mousePoint.distanceTo(this.downPoint) > this.point.radius
            if(this.isDistant) {
                this.point.pen.line(ctx, mousePoint)
            }
        }
    }

    spinCon(ctx){
        let p = this.point
        let direction = 0
        let fullCircle = Math.PI2;

        // (zero) points to the right,
        // rotate -1/4 pi
        let spin = -Math.PI * .5

        if(p) {
            this.stroke.set(ctx)
            ctx.beginPath()
            p.draw.arc(ctx,
                    p.radius,
                    this.tickValue,     // Arc amount


================================================================================
END: click-arc.js
================================================================================



================================================================================
FILE: click-create-2.js
================================================================================

/*
title: Example
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    stroke
    ../point_src/stage.js
    mouse
    dragging
---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
                new Point({x: 250, y: 150 , radius: 20, rotation: 45})
            )
        this.dragging.add(...this.points)
    }

    onEmptyDown(ev) {
        console.log('onEmptyDown')
        let p = Point.from(ev).update({radius: 10})
        this.points.push(p)
        this.dragging.add(p)
    }

    draw(ctx){
        this.clear(ctx)
        this.points.pen.indicator(ctx)

    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: click-create-2.js
================================================================================



================================================================================
FILE: click-create-example.js
================================================================================

/*
title: Click Create Example
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/functions/clamp.js
    // ../others/curve_src/curve.js
    ../point_src/extras.js
    ../point_src/text/alpha.js
    ../point_src/text/fps.js
    ../point_src/curve-extras.js
---

 */
var superV = 0

class RelativeNumber {
    constructor(parent, offset) {
        this.offset = offset
    }

    compute() {
        this.value = this.offset
    }
}


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = (new Point(100, this.center.y)).quantize(100)
        this.clickPoint = this.center.copy();
        this.points = new PointList(this.point, this.clickPoint)


        this.line = new Line(this.point, this.clickPoint, 'green', 2)

        let drag = this.drag = new Dragging
        drag.initDragging(this)
        drag.addPoints(this.point, this.clickPoint)
        drag.onClick = this.dragOnClick.bind(this)
        autoMouse.on(this.canvas, 'mouseup', this.mouseOnClick.bind(this))
    }

    draw(ctx) {
        this.clear(ctx)

        // this.point.pen.indicator(ctx, {color:'#333'})
        this.points.pen.indicators(ctx, {color: '#999'})
        /* Follow the mouse */
        this.drawMouse(ctx)

        this.line.render(ctx)

        /* The pinned point 100,100 */

        let p = this.drag.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }
    }

    drawMouse(ctx) {
        let mouse = Point.mouse
        let pos = mouse.position
        // let color = mouse.isDown(0) ? 'red': '#444'
        this.point.radius = pos.radius = mouse.wheelSize()//(v)=>v*v) + 10
        // pos.pen.indicator(ctx, { color })
        // this.line.b = pos
    }

    rel(percent) {
        return new RelativeNumber(this, percent)
    }

    mouseOnClick(canvas, event) {
        // console.log('Custom click event', event)
        if(!this.drag.isDragging) {
            // let np = new Point({x:event.x,y:event.y, radius: this.mouse.wheelSize(true)})
            // this.points.push(np)
            // this.drag.add(np)
        }
    }

    dragOnClick(event) {
        // console.log('Custom click event', event)


================================================================================
END: click-create-example.js
================================================================================



================================================================================
FILE: click-create-line-length-present-2.js
================================================================================

/*
---
title: Line Length
files:
    head
    point
    pointlist
    mouse
    stage
    stroke
    dragging
    ../point_src/random.js
    ../point_src/stage-clock.js
    ../point_src/easing.js
    ../point_src/functions/quantize.js
    ../point_src/iter/lerp.js
    ../point_src/text/beta.js
    ../point_src/arc.js


Click-hold to draw a line. Apply the length as a label orientated along the line.

---

*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    mounted(){
        this.drawing = false;
        this.startPoint = undefined
        this.line = []
    }


    onMousedown(e){
        /*
            Grab Point
            Animate To size.
            Then the new background color,
        */
        this.drawing = true
        this.startPoint = Point.from(e).quantize(20)
    }

    onMouseup(ev) {
        this.drawing = false
        this.upPoint = Point.from(ev).quantize(20)
        this.line = [this.startPoint, this.upPoint]

    }

    switchOut() {
        console.log('doneHandler')
        let p = this.p
        this.v = undefined;
    }

    firstDraw(ctx) {
        ctx.fillStyle = '#ccc'
        ctx.font = 'normal 1em arial'
    }

    step(ctx){
        if(!this.drawing) {
            return
        }

        let a = this.startPoint.quantize(20)
        let b = this.mouse.point.quantize(20)
        a.pen.line(ctx, b)

    }

    draw(ctx){
        this.clear(ctx)
        this.step(ctx)

        if(this.line.length==2) {
            this.stageB(ctx)
        }

        return this.stageA(ctx)
    }

    stageA(ctx) {

        let a = this.startPoint
        let b = this.mouse.point.quantize(20)

        if(this.line.length > 0 && !this.drawing){
            a = this.line[0]
            b = this.line[1]
        }

        if(a) {
            a.pen.line(ctx, b, 'red')
            a.pen.fill(ctx)
            b.pen.fill(ctx)
            let dis = a.distanceTo(b).toFixed(2)


================================================================================
END: click-create-line-length-present-2.js
================================================================================



================================================================================
FILE: click-create-line-length-present.js
================================================================================

/*
---
title: Line Length
files:
    head
    point
    pointlist
    mouse
    stage
    stroke
    dragging
    ../point_src/random.js
    ../point_src/stage-clock.js
    ../point_src/easing.js
    ../point_src/functions/quantize.js
    ../point_src/iter/lerp.js
    ../point_src/text/beta.js


Click-hold to draw a line. Apply the length as a label orientated along the line.

---

*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    mounted(){
        this.drawing = false;
        this.startPoint = undefined
        this.line = []
    }


    onMousedown(e){
        /*
            Grab Point
            Animate To size.
            Then the new background color,
        */
        this.drawing = true
        this.startPoint = Point.from(e).quantize(20)
    }

    onMouseup(ev) {
        this.drawing = false
        this.upPoint = Point.from(ev).quantize(20)
        this.line = [this.startPoint, this.upPoint]
    }

    switchOut() {
        console.log('doneHandler')
        let p = this.p
        this.v = undefined;
    }

    firstDraw(ctx) {
        ctx.fillStyle = '#ccc'
        ctx.font = 'normal 1em arial'
    }

    step(ctx){
        if(!this.drawing) {
            return
        }

        let a = this.startPoint.quantize(20)
        let b = this.mouse.point.quantize(20)
        a.pen.line(ctx, b)

    }

    draw(ctx){
        this.clear(ctx)
        this.step(ctx)
        this.startPoint && this.startPoint.pen.fill(ctx)

        let a = this.startPoint
        let b = this.mouse.point.quantize(20)


        if(this.line.length > 0 && !this.drawing){
            a = this.line[0]
            b = this.line[1]
        }

        if(a) {
            a.pen.line(ctx, b)
            let dis = a.distanceTo(b).toFixed(2)
            let tp = a.midpoint(b)
            tp.lookAt(b)
            tp.text.label(ctx, dis, {y:-10, x: 0})
        }

    }
}


;stage = MainStage.go();

================================================================================
END: click-create-line-length-present.js
================================================================================



================================================================================
FILE: click-draw-line-box.js
================================================================================

/*
title: Draw Box
files:
    head
    point
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    stage
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    ../point_src/curve-extras.js
    dragging
    stroke
    ../point_src/random.js
    ../point_src/functions/clamp.js
    ../point_src/functions/within.js
    ../point_src/automouse.js
    ../point_src/recttools.js
---

Create a bounding box by click-dragging a selection.
*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){

        /* The (soon to be) generated lines */
        this.lines = []

        /* A flag for later */
        this.drawing = false

        /* A bunch of random points.*/
        this.points = PointList.generate.random(100,
                [800, 600],  // size
                {x: 100, y: 100} // top left
            )

        /* Box stroke. */
        this.stroke = new Stroke({
            color: '#5555FF'
            , width: 1
            , dash: [1]
        })

        /* populated when drawing */
        this.selected = new Set
        this.mouse.point.radius = 20
    }

    onClick(ev) {}

    onDblclick(ev) {}

    onMousedown(ev) {
        /* On mouse down, we flag the drawing as active and store the down Point */
        if(this.dragging.getPoint()?.uuid == 'handle'){
            // Dragging box mode.
            return
        }

        this.drawing = true
        this.downPoint = Point.from(ev)
        // this.selectItems()
    }

    onMouseup(ev) {
        /* On mouse up, flag the drawing=false, and store the up point. */
        this.drawing = false
        this.upPoint = Point.from(ev)
        // this.lines = []
    }

    onMousemove(ev) {
        /* On every move, creata a draw box from the down point
        to the mouse point, then test for selected items.*/
        if(!this.drawing) {
            return
        }

        /* render the concurrent box from downPoint to mousePoint*/
        let dp = this.downPoint
        let mp = this.mouse.point
        this.lines = twoPointBox(dp, mp)
        this.selectItems(dp, mp)
    }

    selectItems(a,b){

        let rect = twoPointsAsRectOrdered(a,b)
        let keep = new Set;

        let handList = new PointList(...rect)

        /* For every _point_ in the list, test to see if
        it's within the rectable polygon shape.


================================================================================
END: click-draw-line-box.js
================================================================================



================================================================================
FILE: click-point-detect.js
================================================================================

/*
title: Chord Rect
category: chords
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    mouse
    dragging
    stroke
    ../point_src/random.js
    ../point_src/chords.js
---

*/

class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 , radius: 20, rotation: 45})

        this.dragging.add(this.point)
    }

    onMousedown(ev) {
        this.point.xy = Point.from(ev)
        this.point.rotation += random.int(180)
    }

    draw(ctx){
        this.clear(ctx)

        this.point.pen.indicator(ctx)

    }
}


stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: click-point-detect.js
================================================================================



================================================================================
FILE: click-pop.js
================================================================================

/*
title: Click Pop
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js
    ../point_src/text/alpha.js
    ../point_src/stage-clock.js
    ../point_src/text/fps.js
---

*/



class ClickPumpRandomPointEmitter extends PumpRandomPointEmitter {
    /* Only execute when _clicked_. This is acheived by turning
    off the modulo tick (tickModulo=0)
    and running _cycle_ when required.

        let e3 = new ClickPumpRandomPointEmitter(500,200, 60)
        e3.wake()

        draw(){
            e3.step()  // Always run
        }

        onclick(){
            e3.cycle()
        }

    One cycle will emit a count of _birthrate_ - to the age of `lifetime`
    */
    tickModulo = 0
    pointLimit = 200
    birthrate = 100
    // birthrate = 100
    lifetime = 100
}



class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        // this.point = new Point(100, 100, 20)
        /*this.point.onMousedown = (e)=>{
            console.log("onClick", e)
            this.blast()
        }*/

        // this.events.wake()

        // let e2 = new PumpRandomPointEmitter(400,400, 60)
        // // let e2 = new RandomPointEmitter(400,400, 60)
        // e2.direction = {x:-1, y:0} //inward.
        // e2.fromEdge = true
        // e2.tickModulo = 10
        // e2.speed = 1
        // e2.birthrate = 3
        // e2.lifetime = e2.radius * .5
        // e2.wake()
        // this.e2 = e2


        // let e3 = new Emitter(500,200, 60)
        // e3.fromEdge = true
        // e3.tickModulo = 100
        // e3.birthrate = 20
        // e3.lifetime = 200
        let e3 = new ClickPumpRandomPointEmitter(100,200, 30)
        e3.onMousedown = (e)=>{
            console.log("onClick", e)
            this.blast()
        }
        e3.wake()

        e3.lifetime = ()=>Math.random() *  e3.radius
        // e3.speed = 20
        e3.particleSpeed = ()=>1+(Math.random() * 3)


================================================================================
END: click-pop.js
================================================================================



================================================================================
FILE: clip-draw-star.js
================================================================================

/*
title: Clip Draw Star Example
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    ../point_src/curve-extras.js
    ../point_src/split.js
---

Collected from mozila as an example of a clipping path:

[Mozila:Compositing](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Compositing)


*/


function draw(ctx) {
  // const ctx = document.getElementById("canvas").getContext("2d");
  ctx.fillRect(0, 0, 150, 150);
  ctx.translate(75, 75);

  // Create a circular clipping path
  ctx.beginPath();
  ctx.arc(0, 0, 50, 0, Math.PI * 2, true);
  ctx.clip();

  // Draw background
  const linGrad = ctx.createLinearGradient(0, -75, 0, 75);
  linGrad.addColorStop(0, "#232256");
  linGrad.addColorStop(1, "#143778");

  ctx.fillStyle = linGrad;
  ctx.fillRect(-75, -75, 150, 150);

  generateStars(ctx);
}


function generateStars(ctx) {
  for (let j = 1; j < 50; j++) {
    ctx.save();
    ctx.fillStyle = "#fff";
    ctx.translate(
      75 - Math.floor(Math.random() * 150),
      75 - Math.floor(Math.random() * 150),
    );
    drawStar(ctx, Math.floor(Math.random() * 4) + 2);
    ctx.restore();
  }
}


function drawStar(ctx, r) {
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(r, 0);
    for (let i = 0; i < 9; i++) {
        ctx.rotate(Math.PI / 5);
        if (i % 2 === 0) {
          ctx.lineTo((r / 0.525731) * 0.200811, 0);
        } else {
          ctx.lineTo(r, 0);
        }
    }
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        // this.dragging.add(this.a, this.b)
    }

    draw(ctx){
        this.clear(ctx)
        draw(ctx)
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: clip-draw-star.js
================================================================================



================================================================================
FILE: clock-face-raw.js
================================================================================

/*
title: Clock Face Raw
categories: clock
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/text/beta.js
    ../point_src/curve-extras.js


 */
const oo6 = 1/60

class SimTime {
    /*
        Sim Time provides an interface for hour, minute, second
        clock additons.

            let st = new SimTime(16, 30, 0)
            st.add(1) // seconds
            st.addHour(-1)
            st.add(100) //seconds
            st.array()
            [15, 31, 41]

     */
    constructor(hour, minute, seconds=0) {
        this.innerOffset = 0
        this._hour = hour
        this._minute = minute
        this._seconds = seconds
        this._cache = this.split(this.innerOffset)
    }

    add(seconds) {
        this.innerOffset += seconds
        this._cache = this.split(this.innerOffset)
    }

    split(secs){
        var hour = Math.floor(secs / (60 * 60));

        var divisor_for_minutes = secs % (60 * 60);
        var minute = Math.floor(divisor_for_minutes / 60);

        var divisor_for_seconds = divisor_for_minutes % 60;
        var second = Math.ceil(divisor_for_seconds);

        var obj = {
             hour,
             minute,
             second,
             seconds:second
        };
        return obj;
    }

    get hour(){
        return this._hour + this._cache.hour
    }

    get minute(){
        return this._minute + this._cache.minute
    }

    get seconds(){
        return this._seconds + this._cache.seconds
    }

    set hour(v){
        return this._hour = v
    }

    set seconds(v){
        return this._seconds = v
    }

    set minute(v){
        return this._minute = v
    }

}



================================================================================
END: clock-face-raw.js
================================================================================



================================================================================
FILE: clock-face-sweep.js
================================================================================

/*
title: Clock Face Sweep
categories: clock
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
    ../point_src/text/beta.js
    ../point_src/clock.js
    ../point_src/curve-extras.js
*/

class MainStage extends Stage {
    // canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.gWidth = 50
        this.count = 20

        let d = new Date;
        this.simTime = new SimTime(d.getHours(), d.getMinutes(), d.getSeconds())

        let p = this.point = this.center.copy().update({ radius: 100 })
        this.hourPoint = this.point.copy()
        this.minutePoint = this.point.copy()
        this.secondPoint = this.point.copy()

        this.dragging.add(this.point)

        this.microValue = 1 / (60 * 1) //1 second
        this.microStep = 0
        this.animatingSeconds = false;
        this.secondsDest = 0
        this.hands = new Hands
    }

    setHourHand(parent, point, hour, minute, modulo=12) {
        // assign the time hour to the point hand in the form of rotation
        point.rotation = this.hands.getHourHand(parent.rotation, hour, minute, modulo)

    }

    setMinuteHand(parent, point, minute=0) {
        point.rotation = this.hands.getMinuteHand(parent.rotation, minute)
    }

    setSecondHand(parent, point, seconds=0) {

        /* Working - no animation*/
        // point.rotation = this.hands.getSecondHand(parent.rotation, seconds)


        const ts = 1
        const tsos = (360/60) * ts

        if(this.animatingSeconds == true) {
            // already doing some animations.
            //  perform an update and continue...
            // let newVal = this.hands.getSecondHand(this.secondsDest || point.rotation , seconds)
            let v = this._secondHandLerp.get(this.microStep)
            const nv = this.secondsDest - tsos
            // console.log(nv.toFixed(3), v.toFixed(3), (nv + v).toFixed(), this.microStep)
            point.rotation = (parent.rotation - ( -v + nv)) % 360
            return
        } else {
            this.secondsDest = this.hands.getSecondHand(
                    (parent.rotation - point.rotation) % 360,
                ts)
        }

        // point.rotation = newVal
        let lerper = this._secondHandLerp

        if(lerper == undefined){
            // create / start
            this._secondHandLerp = new Value(
                            0, //point.rotation,
                            tsos, // newVal,
                            // elasticEaseOut
                            // quinticEaseIn
                            // quadEaseInOut


================================================================================
END: clock-face-sweep.js
================================================================================



================================================================================
FILE: clock-face.js
================================================================================

/*
title: Clock Face
categories: clock
files:
    head
    pointlist
    point
    mouse
    stage
    ../point_src/random.js
    ../point_src/functions/clamp.js
    dragging
    stroke
    ../point_src/split.js
    ../point_src/clock.js
    ../point_src/easing.js
 */

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.modulo = 12
        this.clockSpeed = 1
        let d = new Date;
        this.simTime = new SimTime(d.getHours(), d.getMinutes(), d.getSeconds())

        this.clockHands = PointList.generate.countOf(4)
        this.clockHands[0].copy(this.center).update({ radius: 200, rotation: -90 })

        this.hands = new Hands;

        this.dragging.add(this.clockHands[0])
    }

    draw(ctx){
        this.clear(ctx)

        this.simTime.add(oo6 * this.clockSpeed)

        let  ch = this.clockHands
            , p = ch[0]
            , hp = ch[1] // hour
            , mp = ch[2] // minute
            , sp = ch[3] // second
            , st = this.simTime
            , modulo = this.modulo
            ;

        // hp.xy = mp.xy = sp.xy = p.xy
        ch.each.xy = ch[0].xy

        const out = p.copy()
        out.radius += 25

        hp.radius = out.radius * .45
        mp.radius = out.radius *  .7
        sp.radius = out.radius *  .83

        let pr = p.rotation

        out.pen.circle(ctx, { width: 2, color: 'purple'})

        this.drawText(ctx,out,p, modulo)

        // mp.rotation = this.hands.getMinuteHand(pr, st.minute)
        mp.rotation = this.hands.getMinuteHand(pr, st.sweepMinute)
        mp.pen.line(ctx, null,  'green', 3)

        hp.rotation = this.hands.getHourHand(pr, st.hour, st.minute, modulo)
        hp.pen.line(ctx, null, '#880000', 4)

        sp.rotation = this.hands.getSecondHand(pr, st.sweepSeconds)
        sp.pen.line(ctx, null,  '#999', 1)

        this.drawCenter(ctx, out, p)

        let easingFunction = (v) => easingFunctions.quartic.out(easingFunctions.sine.inOut(v))
        sp.rotation = this.hands.getSecondHand(pr, st.seconds, st.milliseconds, easingFunction)
        sp.pen.line(ctx, null,  'orange', 2)
    }

    drawCenter(ctx, out, p){
        const c = out.copy().update({radius: p.radius * .05})
        c.pen.circle(ctx, {color: 'orange', width: 4})
        c.pen.fill(ctx, '#111')
    }

    drawText(ctx,out, p, modulo=12){
        let r = p.radius * .16
        let ps = out.update({radius: out.radius - (r * 1)}).split(modulo)
        ps.each.radius = r
        // ps.pen.indicators(ctx, { color: 'white'})
        ctx.fillStyle = 'pink'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        let px = Math.max(r*1, 8)
        ctx.font = `400 ${px}px arial`

        const psl = ps.length


================================================================================
END: clock-face.js
================================================================================



================================================================================
FILE: clock-stopwatch.js
================================================================================

/*
title: Clock Stopwatch
categories: clock
files:
    head
    pointlist
    point
    mouse
    stage
    ../point_src/random.js
    ../point_src/functions/clamp.js
    dragging
    stroke
    ../point_src/split.js
    ../point_src/clock.js
    ../point_src/easing.js
 */

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.modulo = 60
        this.clockSpeed = -1
        let d = new Date;
        this.simTime = new SimTime(1, 5, 20)
        // this.simTime = new SimTime(d.getHours(), d.getMinutes(), d.getSeconds())

        this.clockHands = PointList.generate.countOf(4)
        this.clockHands[0].copy(this.center).update({ radius: 200, rotation: -90 })

        this.hands = new Hands;

        this.dragging.add(this.clockHands[0])
    }

    draw(ctx){
        this.clear(ctx)

        this.simTime.add(oo6 * this.clockSpeed)

        let  ch = this.clockHands
            , p = ch[0]
            , hp = ch[1] // hour
            , mp = ch[2] // minute
            , sp = ch[3] // second
            , st = this.simTime
            , modulo = this.modulo
            ;

        // hp.xy = mp.xy = sp.xy = p.xy
        ch.each.xy = ch[0].xy

        const out = p.copy()
        out.radius += 25

        hp.radius = out.radius * .45
        mp.radius = out.radius *  .7
        sp.radius = out.radius *  .83

        let pr = p.rotation

        out.pen.circle(ctx, { width: 2, color: 'purple'})

        // this.drawText(ctx,out,p, modulo)
        out.split(60, -Math.PI).forEach((p)=>{
            p.radius = out.radius * .05
            p.pen.line(ctx, null,  'purple', 2)
        })


        // mp.rotation = this.hands.getMinuteHand(pr, st.minute)
        mp.rotation = this.hands.getMinuteHand(pr, st.sweepMinute)
        mp.pen.line(ctx, null,  'green', 3)

        hp.rotation = this.hands.getHourHand(pr, st.hour, st.minute, modulo)
        hp.pen.line(ctx, null, '#880000', 4)

        sp.rotation = this.hands.getSecondHand(pr, st.sweepSeconds)
        sp.pen.line(ctx, null,  '#999', 1)

        this.drawCenter(ctx, out, p)

        let easingFunction = (v) => easingFunctions.quartic.out(easingFunctions.sine.inOut(v))
        sp.rotation = this.hands.getSecondHand(pr, st.seconds, 1000 - st.milliseconds, easingFunction)
        sp.pen.line(ctx, null,  'orange', 2)
    }

    drawCenter(ctx, out, p){
        const c = out.copy().update({radius: p.radius * .05})
        c.pen.circle(ctx, {color: 'orange', width: 4})
        c.pen.fill(ctx, '#111')
    }

    drawText(ctx,out, p, modulo=12){
        let r = p.radius * .06
        let ps = out.update({radius: out.radius - (r * 1)}).split(modulo)
        ps.each.radius = r
        // ps.pen.indicators(ctx, { color: 'white'})
        ctx.fillStyle = 'pink'


================================================================================
END: clock-stopwatch.js
================================================================================



================================================================================
FILE: cluster-2.js
================================================================================

/*
title: Cluster 2
categories: clusters
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    dragging
    ../point_src/table.js
    ../point_src/cluster.js
    ../point_src/velocity.js
    stroke
    mouse
 */


var points = PointList.generate.random(100, 500);
points.forEach(p => {
    p.vx = 0
    p.vy = 0
    p.radius = 5
})


class MainStage extends Stage {

    mounted() {
        this.target = this.center.copy()
        this.dragging.add(this.target)
    }

    draw(ctx) {
        this.clear(ctx)
        let target = this.target
        simpleCluster(points, target, {
                func: gravitateSquareDistance // clusterStyleB // clusterStable
                // func: clusterStable
            })

        points.forEach(faceVelocity)
        target.pen.indicator(ctx, {color:'red'})
        // points.pen.lines(ctx, 'red', {color:'#33aa99'})
        points.pen.indicators(ctx, {color:'#33aa99'})
        points.centerOfMass().pen.indicator(ctx, {color: 'pink'})
    }
}

const stage = new MainStage('playspace')
stage.loopDraw()
// stage.go()


================================================================================
END: cluster-2.js
================================================================================



================================================================================
FILE: cluster.js
================================================================================

/*
title: Cluster
categories: clusters
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    dragging
    ../point_src/table.js
    ../point_src/cluster.js
    stroke
    mouse
 */


let keys = [
    "minDistance"
    , "attractionStrength"
    , "repulsionStrength"
    , "damping"
    , "minVelocity"
    , "maxVelocity"
    , "itercount"
    , "method"
]

const confTable = new Table(keys, {
      'default': [30,  0.004, 200, 0.60,  0.1,  5]
    , 'alt':     [90,  0.002, 100, 0.66,  0.08, 5]
    , 'gas':     [100, 0.001, 800, 0.974, 0.1,  9,  1]
    , 'stable':  [100, 0.001, 80,  0.974, 0.01, 9,  1]
    , 'blob':    [90,  0.002, 100, 0.95,  0.1,  20, 1, 'springy']
    , 'orbitals':[400, 0.01, 90, 0.99,  0.08, 5,  1]
    , 'orbitab': [200, 0.01, 300, 0.98,  0.08, 5,  1]
})

const selectedConfigName =  'stable' // 'default' // "orbitab" // "blob" // "gas" // 'alt'
var settings = confTable.get(selectedConfigName)

var points = PointList.generate.random(50, 500);
points.forEach(p => {
    p.vx = 0
    p.vy = 0
    p.radius = 5
})


// var pointsB = PointList.generate.random(50, 500);
// pointsB.forEach(p => {
//     p.vx = 0
//     p.vy = 0
//     p.radius = 5
// })



addControl('type', {
    field: 'select'
    , onchange(ev) {
        let v = ev.currentTarget.value
        console.log('set settings to', v)
        settings =  confTable.get(v)
    }

    , options: confTable.getKeys()
})

class MainStage extends Stage {

    mounted() {
        console.log('mounted')
        // this.settings = settings
        this.pointA = this.center.copy()
        this.pointB = this.center.copy()
        this.dragging.add(this.pointA, this.pointB)
    }

    draw(ctx) {
        // let settings = this.settings
        let pointA = this.pointA
        let pointB = this.pointB
        let targetPosition = pointB

        let c = settings.itercount
        if(c == undefined) { c = 10 }
        simpleCluster(points, pointA, settings, {
            func: clusterStyleB
            , itercount: c
            // , repulsionStrength: pointA.radius  *2 //+ settings.minDistance
            // , minDistance: pointA.radius * 2 //+ settings.minDistance
        });


================================================================================
END: cluster.js
================================================================================



================================================================================
FILE: collision-box-2.js
================================================================================

/*
title: CollisionBox Class
categories: collisions
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/automouse.js
    ../point_src/collisionbox.js

*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted() {
        this.mouse.point.radius = 20
        this.points1 = PointList.generate.grid(100, 10, 40, {x: 100, y:100});
        this.points1.each.radius = 20;

        this.points2 = PointList.generate.grid(100, 10, 40, {x:620, y: 240});
        this.points2.each.radius = (p)=>p.radius=5+random.int(20)

        this.points = this.points1.concat(this.points2)
        this.dragging.add(...this.points);

        this.collisionbox = new CollisionBox(this.points)
    }

    draw(ctx) {
        this.clear(ctx);
        this.collisionbox.step(this.mouse.point)

        this.mouse.point.pen.indicator(ctx);
        this.points.pen.indicators(ctx);
    }

}

stage = MainStage.go()


================================================================================
END: collision-box-2.js
================================================================================



================================================================================
FILE: collision-box-3.js
================================================================================

/*
title: Collision with Locks.
categories: collisions
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/automouse.js
    ../point_src/collisionbox.js

*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted() {
        this.mouse.point.radius = 20

        this.points = PointList.generate.grid(50, 10, 40, {x: 200, y:200});
        this.points.each.radius = (p)=>p.radius=10+random.int(20)

        this.lockedPoints = new PointList(
            this.points[9],
            this.points[33]
        )

        this.lockedPoints.each.locked = true

        this.dragging.add(...this.points);

        this.collisionbox = new CollisionBox(this.points)
    }

    draw(ctx) {
        this.clear(ctx);
        this.collisionbox.step(this.mouse.point)

        this.mouse.point.pen.indicator(ctx);
        this.points.pen.indicators(ctx);
        this.lockedPoints.pen.fill(ctx, '#880000');

    }

}

stage = MainStage.go()


================================================================================
END: collision-box-3.js
================================================================================



================================================================================
FILE: collision-box.js
================================================================================

/*
title: Collision Box
categories: collisions
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/automouse.js

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted() {
        this.points1 = PointList.generate.grid(100, 10, 40);
        this.points1.each.radius = 20;

        this.points2 = PointList.generate.grid(100, 10, 40, {x:620, y: 240});
        // this.points2.each.radius = (p)=> 5+random.int(20)
        this.points2.forEach((p)=>p.radius=5+random.int(20))

        this.points = this.points1.concat(this.points2)
        this.dragging.add(...this.points);
    }

    draw(ctx) {
        this.clear(ctx);

        let mouse = this.mouse.point;
        let radius = 20
        mouse.radius = radius
        mouse.pen.indicator(ctx);

        // this.shuffle(radius, this.points);
        this.shuffle(radius, this.points);

        this.points.pen.indicators(ctx);
        // this.points2.pen.indicators(ctx);
    }


    shuffle(radius, points=this.points) {
        const iterations = 5;
        let mouse = this.mouse.point;

        for (let k = 0; k < iterations; k++) {
            points.forEach((p) => {
                resolveCollision(mouse, p, true, false);
            });

            for (let i = 0; i < points.length; i++) {
                let p1 = points[i];
                for (let j = i + 1; j < points.length; j++) {
                    let p2 = points[j];
                    resolveCollision(p1, p2);
                }
            }
        }
    }

}

// Collision resolution function
function resolveCollision(p1, p2, p1Static = false, p2Static = false) {
      let dx = p2.x - p1.x;
      let dy = p2.y - p1.y;
      let dist = Math.hypot(dx, dy);
      let overlap = p1.radius + p2.radius - dist;

    if (overlap > 0) {
        let nx = dx / dist;
        let ny = dy / dist;

        let totalMass = (p1Static ? 0 : 1) + (p2Static ? 0 : 1);
        let p1Move = p1Static ? 0 : overlap / totalMass;
        let p2Move = p2Static ? 0 : overlap / totalMass;

        p1.x -= nx * p1Move;
        p1.y -= ny * p1Move;
        p2.x += nx * p2Move;
        p2.y += ny * p2Move;
    }
}


================================================================================
END: collision-box.js
================================================================================



================================================================================
FILE: color-bits-example.js
================================================================================

/*
title: Color Bits Library Example
categories: minimal, color, third-party
files:
    head
    point
    pointlist
    stroke
    stage
    ../point_src/third_party/color-bits.js
---

Minimal example using the color-bits library for high-performance color manipulation.

The color-bits library is included in the head comment and provides a global `colorBits` object
with functions for parsing, formatting, and manipulating colors.

Example usage:
- colorBits.parse('#ff0000') - Parse color strings
- colorBits.rgb(255, 0, 0) - Create RGB colors
- colorBits.format(color) - Format colors as hex strings
- colorBits.toRGBA(color) - Convert to RGBA object

For more information, see: https://github.com/romgrk/color-bits
*/

// Color scheme based on palette
// https://paletton.com/#uid=70q0u0kw0sSkR-+qtw8zVncG5hZ
colorScheme = {
    primary: [
        colorBits.parse('#FF9E59'),  // Light orange
        colorBits.parse('#FF842C'),  // Medium-light orange
        colorBits.parse('#E55F00'),  // Medium orange
        colorBits.parse('#B94D00'),  // Medium-dark orange
        colorBits.parse('#8F3B00'),  // Dark orange
    ],
    secondary1: [
        colorBits.parse('#FFC459'),  // Light gold
        colorBits.parse('#FFB42C'),  // Medium-light gold
        colorBits.parse('#E09400'),  // Medium gold
        colorBits.parse('#B97700'),  // Medium-dark gold
        colorBits.parse('#8F5C00'),  // Dark gold
    ],
    secondary2: [
        colorBits.parse('#4B7386'),  // Light blue
        colorBits.parse('#2B5AA9'),  // Medium-light blue
        colorBits.parse('#0E4299'),  // Medium blue
        colorBits.parse('#0A347B'),  // Medium-dark blue
        colorBits.parse('#06275F'),  // Dark blue
    ],
    complement: [
        colorBits.parse('#3DAF9F'),  // Light teal
        colorBits.parse('#1CA08E'),  // Medium-light teal
        colorBits.parse('#00907C'),  // Medium teal
        colorBits.parse('#007464'),  // Medium-dark teal
        colorBits.parse('#005A4E'),  // Dark teal
    ]
}

class ColorBase {

    constructor() {
        this.palette = new Map
        this.set(this.base())
    }

    base() {
        return {
            primary: '#E55F00'   // Medium orange
            , secondary1: '#E09400' // Medium gold
            , secondary2: '#0E4299' // Medium blue
            , complement: '#00907C' // Medium teal
        }
    }

    set(data) {
        for(let k in data) {
            this.add(k, data[k])
        }
    }

    add(name, color) {
        this.palette.set(name, this.cast(color))
    }

    get(name, parse=true) {
        if(this.palette.has(name) == false) return null
        let v = this.palette.get(name)
        return parse==true? this.format(v): v
    }

    blend(background, overlay, opacity, gamma=1) {
        let _b = this.get(background, 0)
        if(_b == null) _b = background;
        let _o = this.get(overlay, 0)
        if(_o == null) _o = overlay;

        return this.format(colorBits.blend(_b, _o, opacity, gamma))
    }



================================================================================
END: color-bits-example.js
================================================================================



================================================================================
FILE: com-example-2.js
================================================================================

/*
title: Center of Mass.
category: center
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/compass.js
    ../point_src/center.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/events.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/extras.js
    ../point_src/setunset.js
    ../point_src/stroke.js
---

*/


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.rawPointConf = { circle: { color: 'orange', width: 1}}
        this.generate()

        // update center indicator every 5 frames
        this.onTick(5, this.createMassPoints.bind(this))
    }

    generate(pointCount=4){
        /* Generate a list. In this random... */
        this.randomPoints = PointList.generate.radius(pointCount, 100, point(200,200))
        /* Customise the points, randomising the mass and rotation. */
        this.randomPoints.forEach(p => {
                let mass = Math.random() * 10
                // p.mass = mass
                p.rotation = Math.random() * 360
                p.radius = Math.max(5, mass)
            })
        // this.dragging.add(...this.randomPoints)
        this.dragging.addPoints(...this.randomPoints)

        this.createMassPoints()
    }


    createMassPoints(){
        /* Call upon the list "center of mass" function */
        this.comPoint = this.randomPoints.centerOfMass()
        /* In this case we cater for mass and rotation additions */
        this.weightedComPoint = this.randomPoints.centerOfMass('deep')
    }

    draw(ctx){
        this.clear(ctx)
        /* Use the pen to draw a simple circle at the Center of Mass.*/
        this.comPoint.pen.circle(ctx, undefined, 'teal', 3)
        /* Draw an indicator at the _weighted_ Center of Mass. */
        this.weightedComPoint.pen.indicator(ctx)
        /* Draw a circle at the origin points */
        this.randomPoints.pen.indicators(ctx, this.rawPointConf)
    }
}

stage = MainStage.go()


================================================================================
END: com-example-2.js
================================================================================



================================================================================
FILE: com-example-no-stage.js
================================================================================

/*
category: center
    raw
title: COM Example No Stage
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/extras.js
    ../point_src/setunset.js
    ../point_src/stroke.js

 */
const canvas = document.getElementById('playspace');
const ctx = canvas.getContext('2d');
Point.mouse.listen(canvas)

var randomPoints;
var comPoint;
var weightedComPoint;
/* A basic setup for the small points. */
const rawPointConf = { circle: { color: 'orange', width: 1}}

const generate = function(pointCount=4){

    /* Generate a list. In this random... */
    randomPoints = PointList.generate.radius(pointCount, 100, point(200,200))

    /* Alter the positions of all the points,
    around a radius of 100, at a position. */
    // randomPoints = PointList.generate.random(pointCount)
    // randomPoints.shape.radius(100, point(200,200))

    /* Customise the points, randomising the mass and rotation. */
    randomPoints.forEach(p => {
            let mass = Math.random() * 10
            p.mass = mass
            p.rotation = Math.random() * 360
            p.radius = Math.max(5, mass)
        })

    /* Call upon the list "center of mass" function */
    comPoint = randomPoints.centerOfMass()
    /* In this case we cater for mass and rotation additions */
    weightedComPoint = randomPoints.centerOfMass('deep')
}


const update = function() {
    ctx.beginPath()
    drawView()
}


generate();


const drawView = function(){
    /* Use the pen to draw a simple circle at the Center of Mass.*/
    comPoint.pen.circle(ctx, undefined, 'teal', 3)

    // quickStroke('white', 1, ()=>comPoint.draw.circle(ctx)

    /* Draw an indicator at the _weighted_ Center of Mass. */
    weightedComPoint.pen.indicator(ctx)

    /* Draw a circle at the origin points */
    randomPoints.pen.indicators(ctx, rawPointConf)

    /* Render a line through all the points. When we "draw" (not pen), the
    next action should be a fill or stroke. */
    // randomPoints.draw.pointLine(ctx)
    // quickStroke('yellow', 1)

    // May bleed if not applied.
    ctx.closePath();
}


function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    update()
    requestAnimationFrame(draw);
}


let rect = canvas.getBoundingClientRect()
ctx.canvas.width  = rect.width;
ctx.canvas.height = rect.height;
draw()



================================================================================
END: com-example-no-stage.js
================================================================================



================================================================================
FILE: com-example-ship.js
================================================================================

/*
title: Center of Mass.
category: center
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/compass.js
    ../point_src/center.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/events.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/extras.js
    ../point_src/setunset.js
    ../point_src/stroke.js
---

*/


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.rawPointConf = { circle: { color: 'orange', width: 1}}
        this.generate()

        // update center indicator every 5 frames
        this.onTick(5, this.createMassPoints.bind(this))
    }

    generate(pointCount=4){
        /* Generate a list. In this random... */
        this.randomPoints = PointList.generate.radius(pointCount, 100, point(200,200))
        /* Customise the points, randomising the mass and rotation. */
        this.randomPoints.forEach(p => {
                let mass = Math.random() * 10
                // p.mass = mass
                p.rotation = Math.random() * 360
                p.radius = Math.max(5, mass)
            })
        // this.dragging.add(...this.randomPoints)
        this.dragging.addPoints(...this.randomPoints)

        this.velocity = point(0, 0);        // Linear velocity (x, y)
        this.angularVelocity = 0;           // Angular velocity (radians/sec)
        this.position = point(0, 0);        // Center of mass position
        this.rotation = 0;                  // Orientation in radians

        this.createMassPoints()

    }


    createMassPoints(){
        /* Call upon the list "center of mass" function */
        this.comPoint = this.randomPoints.centerOfMass()
        /* In this case we cater for mass and rotation additions */
        this.weightedComPoint = this.randomPoints.centerOfMass('deep')
    }

    draw(ctx){
        this.clear(ctx)
        let dt = 1 / 60; // Or whatever your timestep is

        // Update center of mass position by velocity
        this.position.x += this.velocity.x * dt;
        this.position.y += this.velocity.y * dt;

        // Update rotation by angular velocity
        this.rotation += this.angularVelocity * dt;

        // For each engine:
        for (let p of this.randomPoints) {
            // Find engine's offset from center
            let dx = p.x - this.comPoint.x;
            let dy = p.y - this.comPoint.y;

            // Rotate offset by current orientation
            let cosA = Math.cos(this.rotation);
            let sinA = Math.sin(this.rotation);

            let px = this.position.x + dx * cosA - dy * sinA;
            let py = this.position.y + dx * sinA + dy * cosA;

            // Draw at (px, py)
            // e.g., ctx.circle(px, py, p.radius)
        }

        let totalMass = 0;
        let center = this.weightedComPoint

        // Moment of inertia (about center), for point masses:


================================================================================
END: com-example-ship.js
================================================================================



================================================================================
FILE: com-main-raw.js
================================================================================

/*
category: center
    raw
title: COM Main Raw
files:
    head
    point
    pointlist
    stroke
    stage
    mouse
    dragging

 */
const canvas = document.getElementById('playspace');
const ctx = canvas.getContext('2d');
Point.mouse.listen(canvas)

var randomPoints;
var comPoint;
var weightedComPoint;
/* A basic setup for the small points. */
const rawPointConf = { circle: { color: 'orange', width: 1}}


const runExample = function(){
    generate();

    let rect = canvas.getBoundingClientRect()
    ctx.canvas.width  = rect.width;
    ctx.canvas.height = rect.height;

    draw()
}


function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.beginPath()
    drawView()
    // May bleed if not applied.
    ctx.closePath();

    requestAnimationFrame(draw);
}


const generate = function(pointCount=4){
    /* Generate a list. In this random... */
    randomPoints = PointList.generate.radius(pointCount, 100, point(200,200))
    /* Customise the points, randomising the mass and rotation. */
    randomPoints.forEach(p => {
            let mass = Math.random() * 10
            p.mass = mass
            p.rotation = Math.random() * 360
            p.radius = Math.max(5, mass)
        })
    /* Call upon the list "center of mass" function */
    comPoint = randomPoints.centerOfMass()
    /* In this case we cater for mass and rotation additions */
    weightedComPoint = randomPoints.centerOfMass('deep')
}


const drawView = function(){
    /* Use the pen to draw a simple circle at the Center of Mass.*/
    comPoint.pen.circle(ctx, undefined, 'teal', 3)
    /* Draw an indicator at the _weighted_ Center of Mass. */
    weightedComPoint.pen.indicator(ctx)
    /* Draw a circle at the origin points */
    randomPoints.pen.indicators(ctx, rawPointConf)

}


;runExample();

================================================================================
END: com-main-raw.js
================================================================================



================================================================================
FILE: com-stage-example.js
================================================================================

/*
title: Center of Mass.
category: center
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/compass.js
    ../point_src/center.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/events.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/extras.js
    ../point_src/setunset.js
    ../point_src/stroke.js
---

*/


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.rawPointConf = { circle: { color: 'orange', width: 1}}
        this.generate()
    }

    generate(pointCount=4){
        /* Generate a list. In this random... */
        this.randomPoints = PointList.generate.radius(pointCount, 100, point(200,200))
        /* Customise the points, randomising the mass and rotation. */
        this.randomPoints.forEach(p => {
                let mass = Math.random() * 10
                // p.mass = mass
                p.rotation = Math.random() * 360
                p.radius = Math.max(5, mass)
            })
        // this.dragging.add(...this.randomPoints)
        this.dragging.addPoints(...this.randomPoints)
        // this.dragging.onDragEnd = this.onDragEnd.bind(this)
        this.dragging.onDragMove = this.onDragMove.bind(this)
        this.dragging.onWheel = this.onWheel.bind(this)

        this.createMassPoints()
    }

    // onDragEnd(){
    //     this.createMassPoints()
    // }

    onDragMove(){
        this.createMassPoints()
    }

    onWheel(ev, p) {
        this.createMassPoints()
    }

    createMassPoints(){
        /* Call upon the list "center of mass" function */
        this.comPoint = this.randomPoints.centerOfMass()
        /* In this case we cater for mass and rotation additions */
        this.weightedComPoint = this.randomPoints.centerOfMass('deep')
    }

    draw(ctx){
        this.clear(ctx)
        this.drawView(ctx)
        let p = this.dragging.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }
    }

    drawView(ctx){
        /* Use the pen to draw a simple circle at the Center of Mass.*/
        this.comPoint.pen.circle(ctx, undefined, 'teal', 3)
        /* Draw an indicator at the _weighted_ Center of Mass. */
        this.weightedComPoint.pen.indicator(ctx)
        /* Draw a circle at the origin points */
        this.randomPoints.pen.indicators(ctx, this.rawPointConf)
    }
}

stage = MainStage.go()


================================================================================
END: com-stage-example.js
================================================================================



================================================================================
FILE: connect-lights.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    pointlist
    ../point_src/events.js
    mouse
    stage
    dragging
    stroke
    ../point_src/random.js
    ../point_src/rectangle.js
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/
class MainStage extends Stage {
    canvas = 'playspace'

    constantClick = true
    mounted() {

        this.points = PointList.generate.random(8, new Point(500, 500, 30), new Point(100, 100))
        this.points = PointList.generate.grid(40, 7, 110)
        this.points.each.radius = ()=> random.int(5,15)
        // this.point = this.points[2].copy()
        // this.point.radius = 30
        random.shuffle(this.points, 2)
        this.dragging.add(...this.points)
        this.action = 'connectStart'
        this.connections = {}
    }

    onclick(ev) {
        console.log('click', this.dragging._near)
        this[this.action](ev, this.dragging._near)
    }

    connectStart(ev, p) {
        if(p == undefined) { return }
        this.start = p
        this.action = 'connectEnd'
        console.log('started')
    }

    connectEnd(ev, p) {
        if(p == undefined) { return }

        if(p == this.start) {
            // turn off
            this.start = undefined
            this.action = 'connectStart'
            return
        }

        let uuid1 = this.start.uuid
        let uuid2 = p.uuid
        console.log('stopped')
        let name = `${uuid1}-${uuid2}`
        if(this.connections[name] == undefined){
            // create
            this.connections[name] = []
            console.log('Creating')
        }

        this.connections[name].push([this.start, p])
        this.start = undefined
        this.action = 'connectStart'

        if(this.constantClick) {
            this.start = p
            this.action = 'connectEnd'
        }
    }

    draw(ctx){
        this.clear(ctx)
        // this.points.pen.rect(ctx,{width: 4, color: '#444'})
        for(let k in this.connections) {
            this.connections[k].forEach(v=>{
                v[0].pen.line(ctx, v[1], '#888', 3)
            })
        }

        this.points.pen.fill(ctx, {color:'purple'})

        if(this.action == 'connectEnd') {
            this.start.pen.line(ctx, this.mouse.point, '#888', 3)
        }
        if(this.start) {
            this.start.pen.fill(ctx, {color:'green'})
        }
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: connect-lights.js
================================================================================



================================================================================
FILE: constrain-leash-points.js
================================================================================

/*
category: constraints
title: Constrain Leash Points
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/constrain-distance.js
 */

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                 x: 250, y: 150
                , radius: 10
                , vx: 1, vy: 0
                , mass: 2
            })
            , new Point({
                 x: 400, y: 320
                , vx: -1, vy: 0
                , radius: 10
                , mass: 10
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
        )
    }

    draw(ctx){
        this.clear(ctx)

        let mouse = Point.mouse.position
        // constrainDistance(mouse, this.points[0], 50)
        // constrainDistance(this.points[0], this.points[1], 50)
        // constrainDistance(this.points[1], this.points[2], 50)
        // constrainDistance(this.points[2], this.points[3], 50)
        // constrainDistance(this.points[3], this.points[4], 50)
        // constrainDistance(this.points[4], this.points[5], 50)

        this.points[0].leash(mouse, 50)
        this.points[1].leash(this.points[0], 50)
        this.points[2].leash(this.points[1], 50)
        this.points[3].leash(this.points[2], 50)
        this.points[4].leash(this.points[3], 50)
        this.points[5].leash(this.points[4], 50)

        // this.points.last().rotation += 2
        this.points.pen.indicators(ctx)

    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: constrain-leash-points.js
================================================================================



================================================================================
FILE: control-points-2.js
================================================================================

/*
title: Egg 2
src_dir: ../point_src/
categories: binding
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
---

 */
class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        let size = 200
        let spin = .44
        // let pj = this.projectionLength = size * ((Math.sin(spin) + Math.cos(spin) ) * .5)
        this.createPoints(size)

        this.dragging.add(...this.points, ...this.controlPoints)

        // this.lineStroke = new Stroke({
        //     color: '#fff'
        //     , width: 2
        //     , dash: [7, 4]
        // })

        // this.lineStroke2 = new Stroke({
        //     color: '#CCC'
        //     , width: 2
        //     , dash: [7, 4]
        // })

        // this.events.wake()
    }

    createPoints(width=200) {
        let x = 400
            , x2 = width + x
            , y = 300

        this.points = new PointList(
            new Point(x, y, 100)
            , new Point(x2, y, 100)
        )

        // this.eggPoints = new PointList(
        //     new Point(x, y, pj)
        //     , new Point(x2, y, pj)

        //     , new Point(x, y, pj, 90)
        //     , new Point(x2, y, pj, 90)
        // )


        this.controlPoints = new PointList(
            this.points[0].project()
            , this.points[1].project()
            // , this.eggPoints[2].project()
            // , this.eggPoints[3].project()
        )

        let stage = this;
        this.controlPoints.forEach((p,i)=>{

            p.onDragStart = function() {
                // console.log('Drag start')
                this._release = true;
            }

            p.onDragMove = function() {
                // console.log('Drag move')
                stage.controlPointsDistances[i] = stage.controlPoints[i].distance2D(
                        stage.points[i])

            }

            p.onDragEnd = function() {
                // console.log('Drag end')
                stage.controlPointsDistances[i] = stage.controlPoints[i].distance2D(


================================================================================
END: control-points-2.js
================================================================================



================================================================================
FILE: controller-point.js
================================================================================

/*
---
title: Controller
categories: binding
    relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
 */


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.point = new Point({x:200,y:200, radius: 100})
        this.point.controlPoint = this.point.copy().update({radius: 10})
        this.point.controlPoint.parent = this.point;
        this.point.controlPoint.onDragMove = function(ev){
            let d = this.distance2D(this.parent)
            console.log(d)
            this.set(
                d.x,
                d.y,
                )
        }
        this.point.controlPoint.x = 20
        this.point.controlPoint.y = 20
        this.dragging.addPoints(this.point, this.point.controlPoint)
    }

    draw(ctx){
        this.clear(ctx)
        // this.point.controlPoint.xy = this.point.xy
        this.point.controlPoint.rel.x = this.point.x
        this.point.controlPoint.rel.y = this.point.y
        let a = this.point;
        a.pen.indicator(ctx)
        a.controlPoint.pen.indicator(ctx)
        // this.targetPoint.pen.fill(ctx, '#33dd33')
    }
}


;stage = MainStage.go();

================================================================================
END: controller-point.js
================================================================================



================================================================================
FILE: coupled-direction-points.js
================================================================================

/*
title: Coupled Direction
category: binding
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
---

The second point will always mirror the first point

*/

class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true

    mounted(){
        this.point = new Point(300, 400, 100)
        this.point2 = new Point(600, 400, 100)

        this.projection = this.point.project()
        this.projection2 = this.point2.project()

        this.dragging.add(this.point, this.point2, this.projection, this.projection2)
    }

    coupling() {
        this.point.lookAt(this.projection)
        this.point.radius = this.point.distanceTo(this.projection)

        this.point2.rotation = this.point.rotation + 180
        this.point2.radius = this.point.radius
    }

    draw(ctx){
        this.clear(ctx)
        this.coupling()
        let pos = this.mouse.position
        pos.pen.circle(ctx)

        this.point.pen.indicator(ctx)
        this.point2.pen.indicator(ctx)

        this.projection.pen.fill(ctx, '#33DDAA')
        // this.projection2.pen.fill(ctx, '#33DDAA')

    }
}

;stage = MainStage.go();

================================================================================
END: coupled-direction-points.js
================================================================================



================================================================================
FILE: coupled-lines.js
================================================================================

/*
title: Coupled Lines
category: binding
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
---

*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true

    mounted(){
        this.pa = new Point(150, 150, 100, 90)

        this.ma = new Point(300, 400, 100)
        this.mb = new Point(300, 400, 100)

        this.pb = new Point(500, 600, 100, 270)

        let lpoints = [this.pa, this.ma]
        let lpoints2 = [this.mb, this.pb]
        this.line = new BezierCurve(...lpoints)
        this.line2 = new BezierCurve(...lpoints2)

        this.projection = this.ma.project()
        this.projection2 = this.mb.project()

        this.lineStroke = new Stroke({
            color: 'green'
            , width: 5
            , dash: [7, 4]
        })

        this.dragging.add(this.ma, this.mb,
                          this.pa, this.pb,
                          this.projection, this.projection2)
    }

    coupling() {
        this.ma.lookAt(this.projection)
        this.mb.rotation = this.ma.rotation + 180
    }

    draw(ctx){
        this.clear(ctx)
        this.coupling()
        let pos = this.mouse.position
        pos.pen.circle(ctx)

        this.ma.pen.indicator(ctx)
        this.mb.pen.indicator(ctx)

        this.pa.pen.indicator(ctx)
        this.pb.pen.indicator(ctx)

        this.projection.pen.fill(ctx, '#33DDAA')

        let lineStroke = this.lineStroke
        lineStroke.set(ctx)

        this.line.render(ctx)
        this.line2.render(ctx)
        lineStroke.unset(ctx)

    }
}

;stage = MainStage.go();

================================================================================
END: coupled-lines.js
================================================================================



================================================================================
FILE: coupled-vectors-d.js
================================================================================

/*
title: Coupled Vectors D
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    point
    dragging
    stroke
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/constrain-distance.js
    ../point_src/screenwrap.js
    ../theatre/objects/vectors/physics.js
    ../theatre/objects/vectors/controller.js
    ../theatre/objects/vectors/ship.js
---

Coupled Vector Engines - Rigid Body Physics Simulation
*/

class MainStage extends Stage {
    canvas = 'playspace'

    mounted() {
        console.log('mounted')
        // this.screenwrap = new ScreenWrap
        this.mouse.position.vy = this.mouse.position.vx = 0

        // Create the ship as a Ship instance
        this.ship = new Ship({
            x: 200,
            y: 225,  // midpoint between a and b
            vx: 0,
            vy: 0,
            radians: -Math.PI/2,  // -90 degrees (pointing up)
            rotationSpeed: 0,
            mass: 10,
            radius: 5
        })

        // Create engine points with RELATIVE positions (local space)
        // These will be transformed to world space by Ship.addEngine()
        this.a = new Point({ x: 50, y: 0, vx: 0, vy: 0, rotation: 0, radius: 10 })     // Top engine (25 units above ship center)
        this.b = new Point({ x: 0, y: -20, vx: 0, vy: 0, rotation: 0, radius: 10 })     // Left engine (25 units left of ship center)
        this.c = new Point({ x: 0, y: 20, vx: 0, vy: 0, rotation: 0, radius: 10 })     // Right engine (25 units right of ship center)

        // Add engines to ship - addEngine transforms from relative to world space
        this.ship
            .addEngine(this.a, 1)   // Top engine
            .addEngine(this.b, 1)   // Left engine
            .addEngine(this.c, 1)   // Right engine
            ;

        // Convenience references (for backward compatibility with existing code)
        this.engines = this.ship.engines
        this.engineOffsets = this.ship.engineOffsets

        // Add additional mass points to shift center of mass
        // These are "virtual" mass points that don't render but affect physics
        // For a top-heavy VTOL: put heavy mass at the top
        this.massPoints = [
            { x: 60, y: 0, mass: 20 },  // Heavy payload at the top (15 mass units)
            { x: 30, y: 0, mass: 8 },   // Additional mass slightly lower
            // , { x: 0, y: 40, mass: 20 }   // Light fuel tank at bottom (uncomment to test)
        ]

        this.asteroids = new PointList(
                [250, 200]
                , [200, 250]
                , [200, 350]
            ).cast()
        this.asteroids.update({vx: 0, vy: 0, mass: 1})

        this.power = 0
        this.powerDown = false
        this.triggerForce = 0.26
        this.powerSensitivity = 0.1  // Rotation sensitivity (0.0 to 1.0, lower = slower rotation)
        this.axisDeadzone = 0.01  // Controller axis deadzone (0.0 to 1.0, lower = more sensitive)
        this.engineRotationMode = 'spring-back'  // 'accumulate' or 'spring-back' - engine rotation behavior
        this.invertRotation = true  // Invert rightStickX rotation direction

        this.setupKeyboard()
        this.dragging.add(...this.asteroids)

        // Initialize gamepad controller
        // Change profile here: 'XBOX' or 'RADIOMASTER_TS16S'
        this.gamepad = new GamepadController('RADIOMASTER_TS16S')
        this.gamepad.deadzone = this.axisDeadzone  // Apply custom deadzone

    }


================================================================================
END: coupled-vectors-d.js
================================================================================



================================================================================
FILE: coupling-function.js
================================================================================

/*
---
title: Coupling Function
categories: binding
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/coupling.js
---

In this example. The node A and B locked _rotation_ to the location of C.

    a.rotation -> [coupled to] -> b.location
    a.rotation <- [coupled to] <- b.location

*/
class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        let a = this.a = new Point({x:200,y:200, radius: 50})
        let looky = this.c = new Point({x:400,y:200, radius: 10})

        this.dragging.add(a, looky)

        // The looky point should _loosely_ follow A.
        // looky should follow A,
        // and looky should release when manipulated
        // e.g. A drag control point
    }

    draw(ctx){
        this.clear(ctx)

        this.a.pen.indicator(ctx, { color:'#ddd'})
        this.c.pen.indicator(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: coupling-function.js
================================================================================



================================================================================
FILE: coupling-old.js
================================================================================

/*
---
title: Coupling Points
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/protractor.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/mirror.js
    ../point_src/stage.js
    ../point_src/text/label.js
    ../point_src/text/alpha.js
---

# Version 1 (Deprecated)

Bind many points through a single key of updated, allowing _double binding_,
or changes in both directions.

This is deprecated in favour of the newer `coupling.Coupling` unit.
 */


// examples
// b.x = a.x
// double binding required a more complex proxy watch.

// altered bound.
// b.x = a.x + 10

class Coupling {

    constructor() {
        this.pairs = new Set
    }

    couple(a, b, relativeOffset, keys=['x', 'y','radius', 'rotation']) {
        /*
        Couple two points, binding the x,y,radius,rotation
        Apply a relative offset to update the values between binding changes

        when a side is manipulated, the _other_ side is updated.
        If B is the altered value, the relativeOffset is applied inversly.

        Apply a function to the relative offset key to capture live change.s
        */

        // if relativeOffset is array, assume norm
        // if dict, use keys.
        let offset = relativeOffset
        if(Array.isArray(relativeOffset)) {
            offset = {}
            relativeOffset.forEach((v,i,a)=>{
                if(v === undefined || v === null) {
                    return
                };
                offset[keys[i]] = v
            })
        }


        let perform = undefined;

        let aName = a.asArray().join('')
        let bName = b.asArray().join('')

        // store a and b as testable values
        this.pairs.add({a, b, offset, keys, aName, bName})
    }

    step(){
        // when any side is a mismatch, recalc the offset and ripple to others
        // if both sides are edited, force a to b.
        const FORWARD_SET = true
        const REVERSE_SET = false

        this.pairs.forEach(item=>{
            let a = item.a
            let b = item.b

            let an = a.asArray().join('')
            let bn = b.asArray().join('')

            let perform = undefined;

            if(an != a.aName) {
                perform = FORWARD_SET
            }

            if(bn != b.bName) {


================================================================================
END: coupling-old.js
================================================================================



================================================================================
FILE: coupling-points.js
================================================================================

/*
---
title: Coupling Points
categories: binding
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/coupling.js
---

# Coupling Three Points

assign multiple _coupled_ keys across three points. Dragging a point adapts its
sibling.

*/
class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        let a = this.a = new Point({x:200,y:200, radius: 50})
        let b = this.b = new Point({x:300,y:300, radius: 50})
        let c = this.c = new Point({x:200,y:200, radius: 50})

        this.dragging.add(a, b, c)

        let d = this.coupling = new Coupling()

        d.couple(a, b, {
            x: 100
            // , y: 100
        })

        d.couple(a, b, {
            // x: 100
            rotation: 10
            , radius: 0
             // y: 100
        })

        d.couple(a, c, {
            y: 100
            , rotation: -180
             // y: 100
        });

        d.step()
    }

    draw(ctx){
        this.clear(ctx)

        this.a.rotation += 1
        this.coupling.step()

        this.a.pen.indicator(ctx, { color:'#ddd'})
        this.b.pen.indicator(ctx, {color:'green'})
        this.c.pen.indicator(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: coupling-points.js
================================================================================



================================================================================
FILE: cullbox.js
================================================================================

/*
title: Culling screen edge points
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/text/beta.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/text/styler.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/screenwrap.js

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        this.textPos = new Point(100, 100, 20)

        let e1 = this.e1 = new RandomPointEmitter()
        e1.update({
            x: 400
            , y: 400
            , radius: 60
            // , radiusVariant: .1
            , directionVariant: 100
            , particleSpeed: .6
            , lifetime: 600
            , fromEdge: true
            , tickModulo: 1
            // , speed: 100
            , birthrate: 90
            , pointLimit: 1000
        })

        // e1.direction = {x:-1, y:0} //inward.
        this.e1 = e1
        e1.wake()
        this.screenWrap.edgeMethod = 'performCull'
        this.dragging.add(this.point, this.e1)
    }

    draw(ctx){
        this.clear(ctx)
        this.e1.step()

        this.point.pen.indicator(ctx, '#880000')
        /* the primary emitter point */
        this.e1.pen.fill(ctx, '#aaa')
        /* The spawned points.*/
        this.e1.points.pen.circle(ctx, undefined, '#aaa')
        // this.e1.points.pen.lines(ctx,'#aaa')

        let v = this.point.speed2D.absFloat()
        let vh = (v * .5)
        this.e1.birthrate = 2 + v
        this.e1.particleSpeed = 1 + (vh * .2)
        this.e1.lifetime = this.e1.distanceTo(this.point) - vh

        ctx.fillStyle = 'white';
        ctx.font = `500 16px arial`;

        this.screenWrap.cullBox(this.e1.points, (p)=>{
            /* Because this is an emitter, we can cheat
            and simply _over-age_ the point, The emitter will handle
            the rest. */
            p.age = p.lifetime + 10

        })

        this.textPos.text.fill(ctx, this.e1.points.length,)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: cullbox.js
================================================================================



================================================================================
FILE: curve-angles.js
================================================================================

/*
---
title: Split
categories: curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
    ../point_src/iter/alpha.js
    ../point_src/iter/beta.js

*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.point = new Point(300, 400, 100)
        this.count = 20
        this.offset = undefined
        let lpoints3 = [new Point(100, 300, 400, 50), new Point(500, 300, 200, 250)]
        this.curve = new BezierCurve(...lpoints3)
        this.dragging.add(this.point, ...lpoints3)

        // this.lerper = new Iterator(0, .1, 1)
        this.tick = 0

        addControl('tangent', {
            type: 'range'
            , field:  'input'
            , stage: this
            , onchange(ev) {
                /*slider changed. */
                // debugger;
                let sval = ev.currentTarget.value
                this.stage.offset = parseFloat(sval) * .01
            }
        })
    }

    draw(ctx){
        this.clear(ctx)

        let pos = this.mouse.position
        pos.pen.circle(ctx)

        // let v = this.lerper.step(1)
        let offset = this.offset

        if(offset == undefined) {
            offset = Math.sin((this.tick++ * .005) % Math.PI)
        }

        let l = this.curve
        let ps = l.points
        ps.pen.indicators(ctx, {color:'#333'})
        l.render(ctx, {color: 'green'})
        l.getControlPoints().forEach(p=>p.pen.fill(ctx, 'darkred'))

        let bp = get_bezier_point(l.a, ...l.getControlPoints(), l.b, offset)

        let spot = Point.from(bp)
        spot.pen.fill(ctx, 'purple')

        let { dx, dy } = get_bezier_derivative(l.a, ...l.getControlPoints(), l.b, offset)
        let p = new Point(200, 300, 40)
        p.xy = spot.project(30).xy

        let theta = Math.atan2(dy, dx)
        p.radians = theta

        p.pen.indicator(ctx)

        // this.curve.splitInner(this.count, degToRad(0)).pen.indicators(ctx)
        // this.curve.splitHinted(this.count).pen.indicators(ctx, {color:'red'})

    }
}


;stage = MainStage.go();

================================================================================
END: curve-angles.js
================================================================================



================================================================================
FILE: curve-circle.js
================================================================================

/*
title: Curve Circle (Egg bezierFactor)
categories: curve
src_dir: ../point_src/
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    ../point_src/split.js
    ../point_src/angle.js

---

 */

function bezierFactor(count) {
    // Formula: factor = (4/3) * tan( ( / 2) / count )
    return (4 / 3) * Math.tan(Math.PI / (2 * count));
}


class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        this.generate()
        this.dragging.add(...this.points)
        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this.events.wake()
    }

    generate(count=random.int(3,6), radius=100) {
        let factor = bezierFactor(count)
        let size = radius * factor
        let p = this.center.copy().update({radius})
        this.point = this.center.copy().update({radius: radius - 5})
        let rot = Angle.from(1/4).turns

        /* Split on a point, returns many points around the radius. */
        const _splits = p.split(count, rot.rad)
        _splits.each.radius = size

        let lines = this.lines = []
        let length = _splits.length;

        /* Generate a new list of points, 2 points per line*/
        let res = new PointList;

        /* Generate many curves. connecting pairs. */
        for (var i = 0; i < length; i++) {
            let nextValue = i + 1;
            if(nextValue == length) {
                nextValue = 0 // wrap around.
            }
            let o = _splits[nextValue].copy()
            let a = _splits[i].copy()
            o.rotation += 180
            let line = new BezierCurve(a, o)
            res.push(a, o)
            lines.push(line)
        }

        this.points = res;
        return res
    }

    draw(ctx){
        this.clear(ctx)
        let col = {color: '#336600'}
        this.points.pen.indicator(ctx, {color: '#336600'})

        let lineStroke = this.lineStroke
        lineStroke.set(ctx)

        this.lines.forEach((l)=>{
            l.render(ctx, {color: '#44CC55'});
        });


================================================================================
END: curve-circle.js
================================================================================



================================================================================
FILE: curve-con.js
================================================================================

/*
title: Graph Chain Follow Points 2
categories: graph
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    stroke

---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point(250, 150, 10)
            , new Point(400, 320, 10)
            , new Point(300, 520, 8)

            , new Point(340, 580, 8)
            , new Point(380, 520, 8)

            , new Point(410, 520, 8)
            , new Point(450, 520, 8)

            , new Point(430, 520, 8)
            , new Point(400, 520, 8)
        )

        this.collisionBox = new CollisionBox(this.points)
        this.g = new G;

        this.head = 0

        this.g.connect(0, 1, 2, 3, 4)
        this.g.connect(2, 5)
        this.g.connect(5, 6, 7, 8)

        this.dragging.add(...this.points)
    }

    onMousedown(ev, p) {
        // console.log(this.dragging._near)
        this.head = this.points.indexOf(this.dragging._near)
    }

    draw(ctx){
        this.clear(ctx)
        this.collisionBox.shuffle()

        // let mouse = Point.mouse.position
        // followPoint(mouse, this.points[0], 50)

        this.graphChain2()
        this.points.pen.indicators(ctx)

        // head
        this.points[0].pen.fill(ctx, '#992211')
        // tri joint
        this.points[2].pen.fill(ctx, '#00cc33')
    }

    graphChain2() {
        let head = this.head
        let ps = this.points
        let visits = {}

        let pairCallback = (key, fromKey, allTargets)=>{
            // console.log('from=', fromKey, 'key=', key, )
            // constraints.within(ps[fromKey], ps[key], 50)


            constraints.distance(ps[fromKey], ps[key], 50)

            if(visits[fromKey] == undefined) { visits[fromKey] = 0 }
            if(visits[key] == undefined) { visits[key] = 0 }

            visits[fromKey] += 1
            visits[key] += 1
        }

        this.g.walkForward(head, pairCallback)
    }

}


================================================================================
END: curve-con.js
================================================================================



================================================================================
FILE: curve-knife-2.js
================================================================================

/*
title: Curve Knife 2
categories: curve
    split
files:
    ../point_src/math.js
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/point.js
    ../point_src/pointlist.js
    mouse
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    dragging
    stroke
    ../point_src/curve-extras.js
    ../point_src/curve-knife.js
---

*/


class MainStage extends Stage {
    canvas = 'playspace'
    live = true
    mounted(){
        /* Our start and end points */
        this.pointA = new Point(150, 150, 100, 120)
        this.pointB = new Point(300, 400, 100) // default rotation == 0 (looking right)

        /* The primary line */
        this.line = new BezierCurve(this.pointA, this.pointB)

        this.dragging.add(this.pointB, this.pointA)

        /* Some styles for our lines. */
        this.lineStroke = new Stroke({
            color: 'green'
            , width: 2
            , dash: [7, 4]
        })

        this.lineStroke2 = new Stroke({
            color: 'red'
            , width: 2
            // , dash: [7, 4]
        })

        /* The small point along the line, denoting the knife point.*/
        this.indicator = new Point(344,344)
    }

    onMousemove(ev) {
        /* Action the mouse move, discovering the nearest point
        to the mouse along the line. */
        const closestPoint = this.line.nearestPoint(this.mouse.position)
        this.indicator.set(closestPoint);
    }

    onLongClick(stage, canvas, ev, delta) {
        this.dragging.callPointHandler('onLongClick', ev, this._near, delta)
        let cutPointT = this.indicator.t
        // console.log('Long Click', cutPointT)
        this._splitLines = this.line.splitAt(cutPointT)
    }

    draw(ctx){
        this.clear(ctx)

        this.indicator?.pen.fill(ctx, '#ddd')

        // show the spare points
        this.pointA.pen.indicator(ctx, {color:'#333'})
        this.pointB.pen.indicator(ctx, {color:'#333'})

        let lineStroke = this.lineStroke
        lineStroke.set(ctx)
        this.line.render(ctx)
        lineStroke.unset(ctx)
        this.drawKnifeLines(ctx)
    }

    drawKnifeLines(ctx){
        if(!this._splitLines) { return }
        let [lineA, lineB] = this._splitLines

        this.lineStroke2.set(ctx)

        this.drawSubLine(ctx, lineA)
        this.drawSubLine(ctx, lineB, 'red')

        this.lineStroke2.unset(ctx)

    }

    drawSubLine(ctx, stack, fillColor='orange') {
        stack.controls.forEach((p, i)=>{


================================================================================
END: curve-knife-2.js
================================================================================



================================================================================
FILE: curve-knife.js
================================================================================

/*
title: Curve Knife
categories: curve
    split
    raw
files:
    ../point_src/math.js
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/point.js
    ../point_src/pointlist.js
    mouse
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    dragging
    stroke
    ../point_src/curve-extras.js
---

*/

/**
 * Linearly interpolate between two points a and b at parameter t
 * Returns a new point { x, y }
 */
function lerp(a, b, t) {
  return {
    x: a.x + (b.x - a.x) * t,
    y: a.y + (b.y - a.y) * t
  };
}

/**
 * Subdivide a cubic Bzier at parameter t using De Casteljaus algorithm.
 * @param {Object} P0 - Starting control point {x, y}
 * @param {Object} P1 - 1st control point {x, y}
 * @param {Object} P2 - 2nd control point {x, y}
 * @param {Object} P3 - Ending control point {x, y}
 * @param {number} t - Split parameter, 0 < t < 1
 * @returns {Object} An object with two arrays:
 *                    left:  [P0, A, D, F]
 *                    right: [F, E, C, P3]
 */
function subdivideCubicBezier(P0, cP1, cP2, P3, t) {
  // Step 1: interpolate P0->P1, P1->P2, P2->P3
  const A = lerp(P0, cP1, t);
  const B = lerp(cP1, cP2, t);
  const C = lerp(cP2, P3, t);

  // Step 2: interpolate A->B, B->C
  const D = lerp(A, B, t);
  const E = lerp(B, C, t);

  // Step 3: final interpolation between D->E
  const F = lerp(D, E, t);

  // Return two new sets of control points
  return {
    left:  [P0, A, D, F]
    , right: [F, E, C, P3]
    , t
  };
}

// Example usage:
// const t = 0.5; // subdivide at halfway
// const { left, right } = subdivideCubicBezier(P0, P1, P2, P3, t);

// console.log("Left subdivided curve:", left);
// console.log("Right subdivided curve:", right);



const findNearestPoint = function(bezierStack, p, divisor=100) {

    let minDist = Infinity;
    let closestPoint = null;

    let pointA = bezierStack.line.a
    let pointB = bezierStack.line.b
    let controlPointA = bezierStack.controlPoints.a
    let controlPointB = bezierStack.controlPoints.b

    // Sample points along the Bezier curve
    for (let i = 0; i <= divisor; i++) {
        let t = i / divisor;
        let oneMt = 1 - t;
        let omtp3 = Math.pow(oneMt, 3)
        let tpow3 = Math.pow(t, 3)
        let tpow2 = Math.pow(t, 2)
        let omtp2 = Math.pow(oneMt, 2)

        // Calculate the point on the cubic Bezier curve at parameter t
        let x = omtp3 * pointA.x + 3
                * omtp2 * t * controlPointA.x + 3
                * (oneMt) * tpow2 * controlPointB.x
                + tpow3 * pointB.x


================================================================================
END: curve-knife.js
================================================================================



================================================================================
FILE: curvy-mouse-motion-line.js
================================================================================

/*
category: curve
title: Curvy Mouse Motion Line
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../others/curve_src/curve.js
    ../point_src/extras.js
    ../point_src/curve-extras.js
    ../point_src/iter/alpha.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js

*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'
    tick = 0
    mounted(){
        let c = this.curvyLineA  = new BezierCurve(...this.pointPair())
        c.useCache = false;
    }

    pointPair() {
        let cumX = 0
            , cumOffset = 200
            , globalY = this.center.y
            , offset = ()=> cumX+=cumOffset
            , c = this.compass
            ;

        let ps = new PointList(
            new Point({
                name: "a"
                // , rotation: c.right + 45
                , modulusRotate: false
                , x: offset()
                , y: globalY
                , radius: 50
                , rotation: 10
            })
            , new Point({
                name: "b"
                , modulusRotate: false
                // , modulusRotate: true
                , rotation: 10
                , x: offset()
                , y: globalY + 50
                , radius: 50
            })
        )

        return ps;
    }

    draw(ctx){

        this.clear(ctx)

        let p = Point.mouse.position
        let l = this.curvyLineA
        let ps = l.points
        ps.rotate(.4)
        ps.lookAt(p)


        let currentDistance = l.a.distanceTo(l.b) * .5
        let distanceClamp = (q)=> clamp(q.distanceTo(p), 20, currentDistance)
        ps.keyMany('radius', distanceClamp)

        // ps.keyMany('radius', 10)
        // l.a.radius = l.a.distanceTo(p)
        // l.b.radius = l.b.distanceTo(p)

        ps.pen.indicators(ctx)
        l.width= 5
        l.color= '#00AA00'
        l.render(ctx)
        this.tick += 1

    }

}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: curvy-mouse-motion-line.js
================================================================================



================================================================================
FILE: device-orientation.js
================================================================================

/*
title: Device Orientation
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/pointlist.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/text/beta.js

 */
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(200, 100, 20)
        this.orientation = {spin: 0, pitch: 0, roll: 0}
    }

    draw(ctx){
        this.clear(ctx)

        ctx.fillStyle = '#DDD'
        ctx.font = '400 22px sans-serif'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        this.point.text.fill(ctx, JSON.stringify(this.orientation))
        // this.point.pen.fill(ctx, '#880000')
    }
}


const sensor = new AbsoluteOrientationSensor();
Promise.all([navigator.permissions.query({ name: "accelerometer" }),
             navigator.permissions.query({ name: "magnetometer" }),
             navigator.permissions.query({ name: "gyroscope" })])
       .then(results => {
         if (results.every(result => result.state === "granted")) {
           sensor.start();

         } else {
           console.log("No permissions to use AbsoluteOrientationSensor.");
         }
   });

window.addEventListener('deviceorientation', handleOrientation);

let ticks = 0;


function handleOrientation(event) {
    const spin = alpha = event.alpha; // flat on its back
    const pitch = beta = event.beta; // pitch forward
    const roll = gamma = event.gamma; // roll
    // Do stuff...
    ticks++
    // console.log(spin, pitch, roll, )
    stage.orientation = {ticks, spin, pitch}
}


stage = MainStage.go(/*{ loop: true }*/);

================================================================================
END: device-orientation.js
================================================================================



================================================================================
FILE: direction-tethered-point.js
================================================================================

/*
title: Tethered Controller Point
categories: binding
files:
    head
    point
    pointlist
    mouse
    stage
    dragging
    ../point_src/distances.js
    ../point_src/stage-clock.js
    ../theatre/objects/vectorpoint.js
---

*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let p = this.point = new VectorPoint(200, 200, 100)
        this.dragging.add(p)

        let cp = p.addNewPoint()
        this.dragging.add(cp)
    }

    draw(ctx){
        this.clear(ctx)
        this.point.render(ctx)
    }
}



;stage = MainStage.go();

================================================================================
END: direction-tethered-point.js
================================================================================



================================================================================
FILE: directional-tangent-2.js
================================================================================

/*
---
title: Directional Tangent 2
categories: tangents
    bisector
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/tangents.js
    ../point_src/bisector.js
    ../point_src/math.js
    ../point_src/split.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/tangents.js
    ../point_src/text/beta.js
---

Acute kite form, where a single item always points towards its acute angle.
*/

function triples(arr) {
    const triples = [];
    const len = arr.length;
    for (let i = 0; i < len; i++) {
        triples.push([
            arr[i % len],
            arr[(i + 1) % len],
            arr[(i + 2) % len]
        ]);
    }
    return triples;
}

const isOuterPoint = function(a,b,c) {
    return calculateAngleWithRef(a,b,c) > 180
    // return obtuseBisect(previousPoint, p, nextPoint) > -1
}

class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        this.points = new PointList(
                {x:130, y:230, radius: 30}
                ,{x:300, y:240, radius: 30}
                // ,{x:230, y:340, radius: 30}
                ,{x:540, y:140, radius: 30}
                ,{x:440, y:440, radius: 30}
                ,{x:400, y:40, radius: 30}
            ).cast();
        this.regen();
        // stage.points.siblings(1).forEach(pair=>{})
        this.dragging.addPoints(...this.points)
    }

    regen() {
        this.twistAll(this.points)
        this.biPoints = this.generate(this.points)
        this.tangentPoints = this.generateTangents(this.biPoints)
    }

    generateTangents(biPoints) {
        /* Built tangent lines to later plot*/
        let res = []
        biPoints.siblings(1).forEach((pairs, i, items)=>{
            if(!this.points[i].isOuter) {
                if(i == 0) {
                    let io = this.points[i+1]?.isOuter
                    let fname = io? 'ba': 'aa'
                    res.push(pairs[0].tangent[fname](pairs[1]))
                    /*if(io) {
                        res.push(pairs[0].tangent[fname](pairs[1]))
                    }else{
                        // res.push(pairs[0].tangent.ab(pairs[1]))
                        res.push(pairs[0].tangent[fname](pairs[1]))
                    }
                    */
                } else if(i == items.length-1) {

                    if(this.points[i+1]?.isOuter) {
                        res.push(pairs[0].tangent.aa(pairs[1]))
                    }else{

                        /* Race condition*/
                        let next = this.points[i+1]
                        if(next == undefined) {
                            next = this.points[0] //wrap
                        }

                        let io = next?.isOuter
                        let fname = io? 'ba': 'aa'
                        res.push(pairs[0].tangent[fname](pairs[1]))



================================================================================
END: directional-tangent-2.js
================================================================================



================================================================================
FILE: directional-tangent-3.js
================================================================================

/*
---
title: Directional Tangent 3
categories: tangents
    bisector
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/tangents.js
    ../point_src/bisector.js
    ../point_src/math.js
    ../point_src/split.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/tangents.js
    ../point_src/text/beta.js
---

Acute kite form, where a single item always points towards its acute angle.
*/

// function triples(arr) {
//     const triples = [];
//     const len = arr.length;
//     for (let i = 0; i < len; i++) {
//         triples.push([
//             arr[i % len],
//             arr[(i + 1) % len],
//             arr[(i + 2) % len]
//         ]);
//     }
//     return triples;
// }

const isOuterPoint = function(a,b,c) {
    return calculateAngleWithRef(a,b,c) > 180
    // return obtuseBisect(previousPoint, p, nextPoint) > -1
}

class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        this.points = new PointList(
                {x:130, y:230, radius: 30}
                ,{x:300, y:240, radius: 30}
                ,{x:230, y:340, radius: 30}
                ,{x:540, y:140, radius: 30}
                // ,{x:440, y:440, radius: 30}
                // ,{x:400, y:40, radius: 30}
                // ,{x:420, y:140, radius: 30}
            ).cast();
        this.dragging.addPoints(...this.points)
    }

    regen() {
        this.twistAll(this.points)
        this.biPoints = this.generateBiPoints(this.points)
        this.tangentPoints = this.generateTangents(this.biPoints)
    }

    generateTangents(biPoints) {
        /* Built tangent lines to later plot*/
        let res = [];
        let getNextWrapped = function(points, i) {
            let next = points[i+1]
            if(!next) { next = points[0] /*wrap*/ }
            return next;
        }

        biPoints.siblings(1).forEach((pairs, i, items)=>{
            let next = getNextWrapped(this.points, i)
            let [da,db] = this.points[i].isOuter? ['bb', 'ab']: ['ba', 'aa']
            let fname = (next?.isOuter)? da: db
            res.push(pairs[0].tangent[fname](pairs[1]))
        })

        return res;
    }

    generateBiPoints(points) {
        // this.biPoints = this.generate(this.points)
        let res = new PointList;

        points.forEach(p=>{
            /* To only project the _inside_ pin for the loop.*/
            let pin = p.project()
            pin.radius = p.radius
            pin.color = p.isOuter? 'red': 'yellow'
            res.push(pin)
        })

        return res
    }


================================================================================
END: directional-tangent-3.js
================================================================================



================================================================================
FILE: directional-tangent-4.js
================================================================================

/*
---
title: Directional Tangent 4
categories: tangents
    bisector
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/tangents.js
    ../point_src/bisector.js
    ../point_src/math.js
    ../point_src/split.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/tangents.js
    ../point_src/text/beta.js
---

Acute kite form, where a single item always points towards its acute angle.
*/

// function triples(arr) {
//     const triples = [];
//     const len = arr.length;
//     for (let i = 0; i < len; i++) {
//         triples.push([
//             arr[i % len],
//             arr[(i + 1) % len],
//             arr[(i + 2) % len]
//         ]);
//     }
//     return triples;
// }

const isOuterPoint = function(a,b,c) {
    return calculateAngleWithRef(a,b,c) > 180
    // return obtuseBisect(previousPoint, p, nextPoint) > -1
}

class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        this.points = new PointList(
                {x:130, y:230, radius: 30}
                ,{x:300, y:240, radius: 30}
                ,{x:230, y:340, radius: 30}
                ,{x:540, y:140, radius: 30}
                // ,{x:440, y:440, radius: 30}
                // ,{x:400, y:40, radius: 30}
                // ,{x:420, y:140, radius: 30}
            ).cast();
        this.dragging.addPoints(...this.points)
    }

    regen() {
        this.twistAll(this.points)
        this.biPoints = this.generateBiPoints(this.points)
        this.tangentPoints = this.generateTangents(this.biPoints)
    }

    generateTangents(biPoints) {
        /* Built tangent lines to later plot*/
        let res = [];
        let getNextWrapped = function(points, i) {
            let next = points[i+1]
            if(!next) { next = points[0] /*wrap*/ }
            return next;
        }

        biPoints.siblings(1).forEach((pairs, i, items)=>{
            let next = getNextWrapped(this.points, i)
            let [da,db] = this.points[i].isOuter? ['bb', 'ab']: ['ba', 'aa']
            let fname = (next?.isOuter)? da: db
            res.push(pairs[0].tangent[fname](pairs[1]))
        })

        return res;
    }

    generateBiPoints(points) {
        // this.biPoints = this.generate(this.points)
        let res = new PointList;

        points.forEach(p=>{
            /* To only project the _inside_ pin for the loop.*/
            let pin = p.project()
            pin.radius = p.radius
            pin.color = p.isOuter? 'red': 'yellow'
            res.push(pin)
        })

        return res
    }


================================================================================
END: directional-tangent-4.js
================================================================================



================================================================================
FILE: directional-tangent-5.js
================================================================================

/*
---
title: Directional Tangent 5
categories: tangents
    bisector
    raw
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/tangents.js
    ../point_src/bisector.js
    ../point_src/math.js
    ../point_src/split.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/tangents.js
    ../point_src/text/beta.js
---

This version presents a more complete version of tangent lines.

It builds a line by plotting the tangent points to the siblings through
a psuedo center. This ensures the arc is drawn _through_ the center rather
than arcing around the outside.

It works very well at small scales, but at larger scales the tangent lines to points
tends to overshoot the center, causing the two lines to cross before reaching the center point.

This should be fixed by limiting the length of the tangent lines to a reasonable distance, given the radius of the arc (the target point).

For example, if four points are connected, with A and C being very large radius points, when moving B, the tangent lines from A and C 
will intersect before reaching B, causing the arc to loop back on itself.

*/

const isOuterPoint = function(a,b,c) {
    return calculateAngleWithRef(a,b,c) > 180
    // return obtuseBisect(previousPoint, p, nextPoint) > -1
}

class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        this.points = new PointList(
                {x:130, y:230, radius: 30}
                ,{x:300, y:240, radius: 20, isFlipped: true}
                ,{x:230, y:340, radius: 30}
                ,{x:540, y:140, radius: 30}
                // ,{x:440, y:440, radius: 30}
                // ,{x:400, y:40, radius: 30}
                // ,{x:420, y:140, radius: 30}
            ).cast();
        this.dragging.addPoints(...this.points)
    }

    regen() {
        this.twistAll(this.points)
        this.biPoints = this.generateBiPoints(this.points)
        this.tangentPoints = this.generateTangents(this.biPoints)
        this.arcPointPairs = this.orderArcPoints(this.tangentPoints)
    }

    orderArcPoints(tangentPoints) {
        let orders = tangentPoints

        const rearranged = orders.map((_, i) => {
            const current = orders[i];
            const next = orders[(i + 1) % orders.length];
            return [current ? current[1]: next[0], next ? next[0]: current[0]];
        });

        return rearranged
    }

    generateTangents(biPoints) {
        /* Built tangent lines to later plot*/
        let res = [];
        let getNextWrapped = function(points, i) {
            let next = points[i+1]
            if(!next) { next = points[0] /*wrap*/ }
            return next;
        }

        biPoints.siblings(1).forEach((pairs, i, items)=>{
            let next = getNextWrapped(this.points, i)
            let p = this.points[i]
            let typ = (p.isOuter || p.isFlipped)
            let [da,db] = typ? ['bb', 'ab']: ['ba', 'aa']
            let fname = (next?.isOuter || next?.isFlipped)? da: db
            res.push(pairs[0].tangent[fname](pairs[1]))
        })

        return res;


================================================================================
END: directional-tangent-5.js
================================================================================



================================================================================
FILE: directional-tangent.js
================================================================================

/*
---
title: Directional Tangent
categories: tangents
    bisector
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/tangents.js
    ../point_src/bisector.js
    ../point_src/math.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
---

Acute kite form, where a single item always points towards its acute angle.
*/

function triples(arr) {
    const triples = [];
    const len = arr.length;
    for (let i = 0; i < len; i++) {
        triples.push([
            arr[i % len],
            arr[(i + 1) % len],
            arr[(i + 2) % len]
        ]);
    }
    return triples;
}

const isOuterPoint = function(a,b,c) {
    return calculateAngleWithRef(a,b,c) > 180
    // return obtuseBisect(previousPoint, p, nextPoint) > -1
}

class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        this.points = new PointList(
                {x:130, y:230, radius: 30}
                ,{x:300, y:240, radius: 30}
                ,{x:540, y:140, radius: 30}
                ,{x:440, y:440, radius: 30}
                ,{x:400, y:40, radius: 30}
            ).cast()
        // stage.points.siblings(1).forEach(pair=>{})
        this.dragging.addPoints(...this.points)

    }

    draw(ctx){
        this.clear(ctx)
        triples(this.points).forEach((t)=>{
            let outer = acuteBisect(t[0], t[1], t[2])
            t[1].radians = outer
            t[1].color = isOuterPoint(t[0], t[1], t[2])? 'red': 'yellow'
        });

        this.points.pen.indicator(ctx)
        this.points.pen.line(ctx, {color:'green'})
        this.points[0].pen.line(ctx, this.points.last())
    }
}


;stage = MainStage.go();

================================================================================
END: directional-tangent.js
================================================================================



================================================================================
FILE: disc-elipse-2.js
================================================================================

/*
title: Egg 2
categories: curve
src_dir: ../point_src/
files:
    head
    pointlist
    point
    ../point_src/math.js
    ../point_src/point-content.js
    mouse
    stage
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
---

*/
class MainStage extends Stage {
    canvas = 'playspace'
    live = true

    mounted() {
        this.angleX = 0
        this.angleY = 0
        this.angleZ = 0
        this.radius = 100
        this.point = this.center.copy().update({radius: this.radius})
        this.dragging.add(this.point)
    }

    draw(ctx) {
        this.draw2(ctx)
    }

    draw1(ctx) {
        this.clear(ctx)
        // this.angleX += 0.1
        // this.angleY -= 0.1
        // this.angleZ = 0
        // this.angleZ += 0.01
        this.drawDisc(ctx)
        this.point.pen.indicator(ctx, {color: '#AA6666'})
    }

    drawDisc(ctx) {

        const center = this.point
        const baseRadius = this.point.radius

        // Simulate 3D disc squash using sin of rotation
        const rx = baseRadius
        const ry = baseRadius * Math.cos(this.angleX) * Math.cos(this.angleY)

        // Draw the ellipse as a disc projection
        ctx.beginPath()
        ctx.ellipse(center.x, center.y, rx, Math.abs(ry), this.angleZ, 0, 2 * Math.PI)
        ctx.strokeStyle = '#AA6666'
        ctx.lineWidth = 2
        ctx.stroke()
        ctx.fillStyle = 'rgba(200, 100, 100, 0.3)'
        ctx.fill()
    }

    draw2(ctx) {
        this.clear(ctx)

        this.angleX += 0.1
        // this.angleY += 0.1
        // this.angleZ += 0.01

        const r = this.radius || 100
        const center = this.center

        // // Define local axes of a unit circle (X and Y axes in 3D)
        // let xAxis = rotate3D({x: r, y: 0, z: 0}, this.angleX, this.angleY, this.angleZ)
        // let yAxis = rotate3D({x: 0, y: r, z: 0}, this.angleX, this.angleY, this.angleZ)

        // // Radii are lengths of the projected axes
        // const rx = Math.sqrt(xAxis.x**2 + xAxis.y**2)
        // const ry = Math.sqrt(yAxis.x**2 + yAxis.y**2)

        // // Rotation angle of the x-axis (for canvas ellipse rotation)
        // const rotation = Math.atan2(xAxis.y, xAxis.x)


        let xDir = rotate3D({x: 1, y: 0, z: 0}, this.angleX, this.angleY, this.angleZ)
        let yDir = rotate3D({x: 0, y: 1, z: 0}, this.angleX, this.angleY, this.angleZ)

        const rx = r * Math.sqrt(xDir.x**2 + xDir.y**2)
        const ry = r * Math.sqrt(yDir.x**2 + yDir.y**2)
        const rotation = Math.atan2(xDir.y, xDir.x)

        ctx.beginPath()
        ctx.ellipse(center.x, center.y, rx, ry, rotation, 0, 2 * Math.PI)


================================================================================
END: disc-elipse-2.js
================================================================================



================================================================================
FILE: disc-elipse.js
================================================================================

/*
title: Egg 2
categories: curve
src_dir: ../point_src/
files:
    head
    pointlist
    point
    ../point_src/math.js
    ../point_src/point-content.js
    mouse
    stage
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
---

*/
class MainStage extends Stage {
    canvas = 'playspace'
    live = true

    mounted() {
        this.angleX = 0
        this.angleY = 0
        this.angleZ = 0
        this.radius = 100
        this.point = this.center.copy().update({radius: this.radius})
        this.dragging.add(this.point)
    }

    draw(ctx) {
        this.clear(ctx)
        this.angleX = Math.PI * 2
        // this.angleX += 0.01
        // this.angleY += 0.01
        // this.angleZ += 0.1
        this.drawDisc(ctx)
        this.point.pen.indicator(ctx, {color: '#AA6666'})
    }

    drawDisc(ctx) {

        const center = this.point
        const baseRadius = this.point.radius

        // Simulate 3D disc squash using sin of rotation
        const rx = baseRadius
        const ry = baseRadius * Math.cos(this.angleX) * Math.cos(this.angleY)

        // Draw the ellipse as a disc projection
        ctx.beginPath()
        ctx.ellipse(center.x, center.y, rx, Math.abs(ry), this.angleZ, 0, 2 * Math.PI)
        ctx.strokeStyle = '#AA6666'
        ctx.lineWidth = 2
        ctx.stroke()
        ctx.fillStyle = 'rgba(200, 100, 100, 0.3)'
        ctx.fill()
    }

}


function rotate3D(point, angleX, angleY, angleZ) {
    let {x, y, z} = point

    // X Rotation
    let cosX = Math.cos(angleX), sinX = Math.sin(angleX)
    let y1 = y * cosX - z * sinX
    let z1 = y * sinX + z * cosX

    // Y Rotation
    let cosY = Math.cos(angleY), sinY = Math.sin(angleY)
    let x2 = x * cosY + z1 * sinY
    let z2 = -x * sinY + z1 * cosY

    // Z Rotation
    let cosZ = Math.cos(angleZ), sinZ = Math.sin(angleZ)
    let x3 = x2 * cosZ - y1 * sinZ
    let y3 = x2 * sinZ + y1 * cosZ

    return {x: x3, y: y3, z: z2}
}


;stage = MainStage.go();

================================================================================
END: disc-elipse.js
================================================================================



================================================================================
FILE: disc-ellipse.js
================================================================================

/*
title: Egg 2
categories: curve
src_dir: ../point_src/
files:
    head
    pointlist
    point
    ../point_src/math.js
    ../point_src/point-content.js
    mouse
    stage
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
---

*/
class MainStage extends Stage {
    canvas = 'playspace'
    live = true

    mounted() {
        this.angleX = 0
        this.angleY = 0
        this.angleZ = 0
        this.radius = 100
        this.point = this.center.copy().update({radius: this.radius})
        this.dragging.add(this.point)
    }

    draw(ctx) {
        this.clear(ctx)
        this.angleX = Math.PI * 2
        // this.angleX += 0.01
        // this.angleY += 0.01
        // this.angleZ += 0.1
        this.drawDisc(ctx)
        this.point.pen.indicator(ctx, {color: '#AA6666'})
    }

    drawDisc(ctx) {

        const center = this.point
        const baseRadius = this.point.radius

        // Simulate 3D disc squash using sin of rotation
        const rx = baseRadius
        const ry = baseRadius * Math.cos(this.angleX) * Math.cos(this.angleY)

        // Draw the ellipse as a disc projection
        ctx.beginPath()
        ctx.ellipse(center.x, center.y, rx, Math.abs(ry), this.angleZ, 0, 2 * Math.PI)
        ctx.strokeStyle = '#AA6666'
        ctx.lineWidth = 2
        ctx.stroke()
        ctx.fillStyle = 'rgba(200, 100, 100, 0.3)'
        ctx.fill()
    }

}


function rotate3D(point, angleX, angleY, angleZ) {
    let {x, y, z} = point

    // X Rotation
    let cosX = Math.cos(angleX), sinX = Math.sin(angleX)
    let y1 = y * cosX - z * sinX
    let z1 = y * sinX + z * cosX

    // Y Rotation
    let cosY = Math.cos(angleY), sinY = Math.sin(angleY)
    let x2 = x * cosY + z1 * sinY
    let z2 = -x * sinY + z1 * cosY

    // Z Rotation
    let cosZ = Math.cos(angleZ), sinZ = Math.sin(angleZ)
    let x3 = x2 * cosZ - y1 * sinZ
    let y3 = x2 * sinZ + y1 * cosZ

    return {x: x3, y: y3, z: z2}
}


;stage = MainStage.go();

================================================================================
END: disc-ellipse.js
================================================================================



================================================================================
FILE: disc-points.js
================================================================================

/*
title: Egg 2
categories: curve
src_dir: ../point_src/
files:
    head
    pointlist
    point
    ../point_src/math.js
    ../point_src/point-content.js
    mouse
    stage
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
---

*/
class MainStage extends Stage {
    canvas = 'playspace'
    live = true

    mounted() {
        this.angleX = 0
        this.angleY = 0
        this.angleZ = 0

        this.radius = 100
        // this.center = this.center || new Point(400, 300) // fallback if not set
        this.point = this.center.copy().update({radius: this.radius})
        this.dragging.add(this.point)

        // Create static circle points in local XY plane
        this.circlePoints3D = []
        const steps = 40
        for (let i = 0; i < steps; i++) {
            const theta = (Math.PI * 2 * i) / steps
            const x = Math.cos(theta) * this.radius
            const y = Math.sin(theta) * this.radius
            this.circlePoints3D.push({ x, y, z: 0 })
        }
    }

    draw(ctx) {
        this.clear(ctx)

        this.angleX += -Math.cos(this.angleY) * .01
        this.angleY += Math.sin(this.angleX) * .04
        // this.angleZ += 0.01

        const center = this.center
        const rotatedProjected = this.circlePoints3D.map(p => {
            let r = rotate3D(p, this.angleX, this.angleY, this.angleZ)
            let scale = 1 // (r.z * 0.003 + 1)
            return {
                x: r.x * scale + this.point.x,
                y: r.y * scale + this.point.y
            }
        })

        // Draw the disc outline
        ctx.beginPath()
        for (let i = 0; i < rotatedProjected.length; i++) {
            const p = rotatedProjected[i]
            if (i === 0) ctx.moveTo(p.x, p.y)
            else ctx.lineTo(p.x, p.y)
        }
        ctx.closePath()

        ctx.strokeStyle = '#AA6666'
        ctx.lineWidth = 2
        ctx.stroke()

        // Optionally, fill the disc
        ctx.fillStyle = 'rgba(200, 100, 100, 0.3)'
        ctx.fill()
        this.point.pen.indicator(ctx, {color: '#AA6666'})

    }

    // draw(ctx) {
    //     this.clear(ctx)

    //     // this.angleX += 0.01
    //     this.angleY += 0.1
    //     this.angleZ += 0.01
    //     this.drawDisc(ctx)
    //     this.point.pen.indicator(ctx, {color: '#AA6666'})
    // }

    drawDisc(ctx) {

        const center = this.point
        const baseRadius = this.point.radius



================================================================================
END: disc-points.js
================================================================================



================================================================================
FILE: double-bind-xy.js
================================================================================

/*
title: Double Bind XY
category: binding
src_dir: ../point_src/
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
    stroke
    xybind
---

Bind the XY of two points, ensuring movement (such as _dragging_) of one entity,
affects the other.
*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.bindMap = new XYBindMap()

        let r = this.generate()
        this.points = r
        this.dragging.add(...r)
        // this.dragging.onEmptyDown = this.onEmptyDown.bind(this)
    }

    generate(pointCount=2){

        let ps = new PointList(
            new Point({x:100, y:200, radius: 60}),
            new Point({radius: 10}),

            new Point({x:100, y:400, radius: 60}),
            new Point({radius: 10}),

            new Point({x:300, y:200, radius: 60}),
            new Point({radius: 10}),

            new Point({x:300, y:400, radius: 60}),
            new Point({radius: 10}),

            new Point({x:500, y:200, radius: 60}),
            new Point({radius: 10}),

            new Point({x:500, y:400, radius: 60}),
            new Point({radius: 10})
        )

        // this.bindMap.connect(ps[0], ps[1], { speed: .1 })
        // this.bindMap.connect(ps[2], ps[3] /*, { speed: 1 }*/)
        // this.bindMap.connect(ps[4], ps[5], { distance: 100, angle: 0})
        // this.bindMap.connect(ps[6], ps[7], { distance: 100, angle: 0, relative: false})
        // this.bindMap.connect(ps[8], ps[9], { distance: 100, angle: 2, movable: true})
        // this.bindMap.connect(ps[10], ps[11], { distance: 100, angle: 2, relative: false, movable: true})
        ps[0].xyBindChild(ps[1], { speed: .1 })
        ps[2].xyBindChild(ps[3] /*, { speed: 1 }*/)

        ps[4].xyBind.settings = { distance: 100, angle: 0}
        ps[4].xyBindChild(ps[5])

        // ps[4].xyBindChild(ps[5], { distance: 100, angle: 0})
        ps[6].xyBindChild(ps[7], { distance: 100, angle: 0, relative: false})
        ps[8].xyBindChild(ps[9], { distance: 100, angle: 2, movable: true})
        ps[10].xyBindChild(ps[11], { distance: 100, angle: 2, relative: false, movable: true})

        return ps
    }

    onEmptyDown(ev) {
        // console.log('onEmptyDown')
        const p = Point
                    .from(ev)
                    .update({
                        radius: 60
                        , angularVelocity: 1
                    })
                    ;
        this.points.push(p)
        this.dragging.add(p)
    }

    simpleRotate(){

        this.points[4].rotation += 1;
        this.points[6].rotation += 1;

        this.points[8].rotation += 1;
        this.points[10].rotation += 1;

        this.points[5]._updateRequired = true;
        this.points[7]._updateRequired = true;

        this.points[9]._updateRequired = true;
        this.points[11]._updateRequired = true;


================================================================================
END: double-bind-xy.js
================================================================================



================================================================================
FILE: drag-point.js
================================================================================

/*
title: Drag Point
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/screenshot.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/bisector.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/l.js
    ../point_src/protractor.js
    # ../point_src/text/alpha.js
    # ../point_src/text/label.js
    ../point_src/text/beta.js
    ../point_src/stage.js
 */
class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        console.log('drag-point')
        this.spot = this.center.copy()
        this.spot.radius = 300
        this.spot.rotation = random.int(360)
        this.dragging.addPoints(this.spot)
    }

    firstDraw(ctx) {
        ctx.strokeStyle = 'yellow'
        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px inter`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
    }

    draw(ctx){
        this.clear(ctx)
        // this.fps.drawFPS(ctx)
        this.drawCircles(ctx)
        ctx.fillStyle = '#EEE'
        this.drawIris(ctx)
    }

    drawCircles(ctx) {
        this.spot.pen.fill(ctx, '#333')
        this.spot.pen.indicator(ctx, { color: '#111'})
    }

    drawIris(ctx) {
        /* The dynamic highlighter. */
        this.dragging.drawAll(ctx)

    }

}


;stage = MainStage.go();

================================================================================
END: drag-point.js
================================================================================



================================================================================
FILE: draggable-bounding-box.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    stage
    mouse
    dragging
---

The minimal requirements include the _head_, _stage_, and the _point_
And it's draggable.

*/
class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.point = this.center.copy().update({radius: 100})
        this.dragging.add(this.point)
    }

    draw(ctx){
        this.clear(ctx)
        let p = this.point

        p.pen.indicator(ctx, {color: '#444'})

        let r = p.radians + (Math.PI/4)
        p.pen.ngon(ctx, 3, p.radius, 1, '#880000', 2, p.radians)
        p.pen.box(ctx, p.radius, 'red', 2, r)
        // this.point.pen.box(ctx, this.point.radius, 'red', 2, r)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: draggable-bounding-box.js
================================================================================



================================================================================
FILE: draggable-ngon-example.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    stage
    mouse
    dragging
---

The minimal requirements include the _head_, _stage_, and the _point_
And it's draggable.

*/
class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.point = this.center.copy().update({radius: 100})
        this.dragging.add(this.point)
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.indicator(ctx, {color: '#444'})
        this.point.pen.ngon(ctx, 3, this.point.radius, 1, '#880000', 2, Math.PI + this.point.radians)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: draggable-ngon-example.js
================================================================================



================================================================================
FILE: draw-line.js
================================================================================

/*
title: Draw Line
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/curve-extras.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/automouse.js

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        // this.dragging.add(...this.points)
        this.events.wake()

        this.stroke = new Stroke({
            color: '#eee'
            , width: 1
            , dash: [7, 4]
        })

    }

    maxDistance = 20
    projectionSpread = .3

    onMousedown(ev) {
        let delta = Infinity
        if(this.mouseUpTime) {
            delta = +(new Date) - this.mouseUpTime
        }

        if(delta < 100) {
            /* mouse click buffer */
            console.warn('fast click')
        }

        // console.log('start draw', delta)
        clearInterval(this.walkTicker)

        this.walkTicker = undefined

        this.drawingLine = true
        this.startLine(Point.from(ev))
    }

    onMouseup(ev) {
        // console.log('stop draw')
        this.drawingLine = false
        this.stopLine(Point.from(ev))
        this.mouseUpTime = +(new Date)
    }

    onMousemove(ev) {
        let mp = this.mouse.point

        let lastPosition = mp._previousPosition
        mp._previousPosition = mp.copy()
        if(lastPosition == undefined) {
            return
        }
        //speedVector
        mp.speed = mp.distanceTo(lastPosition) * .5
        let dist = mp.speed
        if(this.drawingLine && dist > this.maxDistance) {
            this.line && this.tickFunc()
        }
    }

    startLine(point) {
        /* Start a line at a position*/
        this.line = new PointList(point)
        this.walkTicker = setInterval(this.tickFunc.bind(this), 50)
    }

    stopLine(point) {
        this.line.push(point)
        clearInterval(this.walkTicker)
        this.walkTicker = undefined
        // if(this.walkTicker) {
        // }
    }



================================================================================
END: draw-line.js
================================================================================



================================================================================
FILE: earth-sun.js
================================================================================

/*
title: Earth and Sun
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/bisector.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
*/
const arcLine = function(ctx, points) {
    ctx.beginPath();
    // midPoint.pen.indicator(ctx)

    let startPoint = points[0]

    ctx.moveTo(startPoint.x, startPoint.y);

    let previousPoint = startPoint;
    let pl = points.length;

    // debugger;
    for (var i = 0; i < pl; i++) {
        let p = points[i]
        // if(previousPoint) {
            // if(i == pl-1) {
                // end point
                // ctx.lineTo(p.x, p.y);
            // } else {
                let toPoint = p;
                let r = previousPoint.radius
                ctx.arcTo(previousPoint.x, previousPoint.y, toPoint.x, toPoint.y, r);
            // }
        // }
        previousPoint = p
        // this.drawArc(ctx, midPoint, pointC, pointD)
    }
    let last = points[pl-1]
    ctx.lineTo(last.x, last.y);

    // ctx.stroke();
}





/*

Mercury #1a1a1a Yes it is really that dark

Venus #e6e6e6 or perhaps a bit darker

Earth tricky as it is a mix of colors, and changes over the yea
r seems to average out as about #2f6a69

Mars #993d00

Jupiter #b07f35

Saturn #b08f36

Uranus #5580aa

Neptune #366896
const planetColors = [
    { planet: "Mercury", color: "#918E85" },
    { planet: "Venus", color: "#EEDDAA" },
    { planet: "Earth", color: "#7EC8E3" },
    { planet: "Mars", color: "#D14A28" },
    { planet: "Jupiter", color: "#C6906E" },
    { planet: "Saturn", color: "#D9C48B" },
    { planet: "Uranus", color: "#7FD1B9" },
    { planet: "Neptune", color: "#2C4D97" },
    { planet: "Pluto", color: "#B2A393" }
];



 */
const planets = [
    {
        color: "#d64b02"
        , diameter: 1_391_400 // km
        , name: 'Sun'
        , au: 0
        , radius: 500
    },
    {
        color: "#4DA6FF",


================================================================================
END: earth-sun.js
================================================================================



================================================================================
FILE: easing-example.js
================================================================================

/*
title: Easing Example
categories: easing
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/stage-clock.js
    ../point_src/easing.js
    ../point_src/timeit.js
    ../point_src/iter/lerp.js
    ../point_src/random.js
*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        this.events.wake()
        this.microValue = this.clock.frameStepValue(2) // seconds
        /*  quad, cubic, quartic, quintic, sine, circular,
            exponential, elastic, back, bounce

            in, out, inOut */
        this.easeNameX = 'sine'
        this.easyDirX = 'inOut'
        this.easeNameY = 'cubic'
        this.easyDirY = 'inOut'

        this.easingFunctionX = easingFunctions.get(this.easeNameX, this.easyDirX)
        this.easingFunctionY = easingFunctions.get(this.easeNameY, this.easyDirY)

        addButton('move', {
            // label: 'move'
             onclick: ()=> console.log('move')
        })

        let _this = this;

        addControl('easing', {
            field: 'select'
            , onchange(ev) {
                let v = ev.currentTarget.value
                console.log('set easeNameY to', v)
                _this.easeNameY = v
                _this.easeNameX = v

                _this.easingFunctionX = easingFunctions.get(_this.easeNameX, _this.easyDirX)
                _this.easingFunctionY = easingFunctions.get(_this.easeNameY, _this.easyDirY)
            }

            , options: [
                "linear"
                , "quad"
                , "cubic"
                , "quartic"
                , "sine"
                , "circular"
                , "exponential"
                , "elastic"
                , "back"
                , "bounce"
            ]
        })
    }

    onClick(ev) {
        this.dest = Point.from(ev)

        this.vx = new Value(this.point.x, this.dest.x, this.easingFunctionX)
        this.vy = new Value(this.point.y, this.dest.y, this.easingFunctionY)
        const timerX = new TimeIt('x', true)
        const timerY = new TimeIt('y', true)

        this.vx.doneHandler = function(value, preValue, mutator, step) {
            console.log(timerX.stop().toString());
        }

        this.vy.doneHandler = function(value, preValue, mutator, step) {
            console.log(timerY.stop().toString());
        }

        this.microStep = 0
        this.timeIn = +(new Date)
    }

    draw(ctx){
        if(this.vy) {
            this.point.x = this.vx.get(this.microStep)
            this.point.y = this.vy.get(this.microStep)
        }



================================================================================
END: easing-example.js
================================================================================



================================================================================
FILE: easing-merge.js
================================================================================

/*
title: Easing Merge
categories: easing
files:
    head
    point
    pointlist
    ../point_src/math.js
    ../point_src/point-content.js
    stage
    mouse
    ../point_src/stage-clock.js
    ../point_src/easing.js
    ../point_src/timeit.js
    ../point_src/iter/lerp.js
    ../point_src/random.js
*/
addButton('move', {
    // label: 'move'
     onclick: ()=> console.log('move')
})


addControl('easing', {
    field: 'select'
    , onchange(ev) {
        let v = ev.currentTarget.value
        console.log('set easeNameY to', v)
        stage.easeNameY = v
        stage.easeNameX = v

        stage.easingFunctionX = easingFunctions.get(stage.easeNameX, stage.easyDirX)
        stage.easingFunctionY = easingFunctions.get(stage.easeNameY, stage.easyDirY)
    }

    , options: [
        "linear"
        , "quad"
        , "cubic"
        , "quartic"
        , "sine"
        , "circular"
        , "exponential"
        , "elastic"
        , "back"
        , "bounce"
    ]
})

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        this.microValue = this.clock.frameStepValue(2) // seconds
        /*  quad, cubic, quartic, quintic, sine, circular,
            exponential, elastic, back, bounce

            in, out, inOut */

        this.easingFunctionX = multiEase(
                                // easingFunctions.sine.inOut,
                                easingFunctions.back.in,
                                easingFunctions.sine.in,
                                // easingFunctions.elastic.in
                                // easingFunctions.bounce.out
                            )
        this.easingFunctionY = multiEase(
                                // easingFunctions.back.in,
                                // easingFunctions.sine.out,
                                // easingFunctions.sine.in,
                                // easingFunctions.back.inOut,
                                easingFunctions.bounce.out
                            )

        let _this = this;
    }

    onClick(ev) {
        this.dest = Point.from(ev)
        this.vx = new Value(this.point.x, this.dest.x, this.easingFunctionX)
        this.vy = new Value(this.point.y, this.dest.y, this.easingFunctionY)
        this.microStep = 0
    }

    draw(ctx){
        if(this.vy) {
            this.point.x = this.vx.get(this.microStep)
            this.point.y = this.vy.get(this.microStep)
        }

        this.microStep += this.microValue
        if(this.microStep > 1) {
            this.microStep = 1
        }

        this.clear(ctx)
        this.point.pen.fill(ctx, '#880000')
    }


================================================================================
END: easing-merge.js
================================================================================



================================================================================
FILE: egg-2.js
================================================================================

/*
title: Egg 2
categories: curve
src_dir: ../point_src/
files:
    head
    pointlist
    point
    ../point_src/math.js
    ../point_src/point-content.js
    mouse
    stage
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
---

 */
class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        let size = 200
        let spin = .44
        let pj = this.projectionLength = size * ((Math.sin(spin) + Math.cos(spin) ) * .5)
        this.createPoints(size, pj)

        this.dragging.add(...this.points)

        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this.lineStroke2 = new Stroke({
            color: '#CCC'
            , width: 2
            , dash: [7, 4]
        })

        this.events.wake()
    }

    createPoints(width=200,  pj=this.projectionLength) {
        let x = 400
            , x2 = width + x
            , y = 300

        this.points = new PointList(
            new Point(x, y, pj, 90)
            , new Point(x2, y, pj, 90)
        )

        this.eggPoints = new PointList(
            new Point(x, y, pj)
            , new Point(x2, y, pj)

            , new Point(x, y, pj, 90)
            , new Point(x2, y, pj, 90)
        )

        this.lineA = new BezierCurve(this.eggPoints[0], this.eggPoints[1])
        this.lineB = new BezierCurve(this.eggPoints[2], this.eggPoints[3])
        this.lineA.doTips = false
        this.lineB.doTips = false
    }

    updatePointsToControl(){

        const cloneData = (index, pointIndex, extra=0) => {
            /* Copy data from the `point` units into the
            target eggPoint */
            if(pointIndex==undefined) {
                pointIndex=index;
            }
            this.eggPoints[index].xy = this.points[pointIndex].xy
            this.eggPoints[index].radius = this.points[pointIndex].radius
            this.eggPoints[index].rotation = this.points[pointIndex].rotation + extra
        }

        /* The egg points should copy the primary point positions */
        cloneData(0)
        cloneData(1)
        cloneData(2,0, 180)
        cloneData(3,1, 180)
    }

    draw(ctx){
        this.clear(ctx)
        if(this.clock.tick % 5) {
            this.updatePointsToControl()
        }



================================================================================
END: egg-2.js
================================================================================



================================================================================
FILE: egg-4-5.js
================================================================================

/*
title: Egg 2
categories: curve
src_dir: ../point_src/
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
    ../point_src/functions/springs.js
---

 */
class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        let size = 200
        let spin = .44
        let pj = this.projectionLength = size * ((Math.sin(spin) + Math.cos(spin) ) * .5)
        this.createPoints(size, pj)
        this.dragging.add(...this.points)
        // this.dragging.add(...this.points, ...this.controlPoints)

        this.lineStroke = new Stroke({
            color: '#ccc'
            , width: 2
            , dash: [10,2]
        })

        this.lineStroke2 = new Stroke({
            color: '#CCC'
            , width: 2
            , dash: [8, 2]
        })

        // this.events.wake()
    }

    createPoints(width=200,  pj=this.projectionLength) {
        let x = 400
            , x2 = width + x
            , y = 300

        this.points = new PointList(
            new Point({x, y
                , radius: pj
                , rotation: 90
                , vx: 0, vy: 1
                , mass: 1
            })
            , new Point({x:x2, y
                , radius: pj
                , rotation: -90
                , vx: 0, vy: 1
                , mass: 1
            })
        )

        this.eggPoints = new PointList(
            new Point(x, y, pj - 30)
            , new Point(x2, y, pj - 30)

            , new Point(x, y, pj)
            , new Point(x2, y, pj)
        )

        this.lineA = new BezierCurve(this.eggPoints[0], this.eggPoints[1])
        this.lineB = new BezierCurve(this.eggPoints[2], this.eggPoints[3])
        this.lineA.doTips = false
        this.lineB.doTips = false
    }

    updatePointsToControl() {
        this.eggPoints[0].radians = this.points[0].radians
        this.eggPoints[2].radians = this.points[0].radians + Math.PI
        this.eggPoints[0].xy = this.eggPoints[2].xy = this.points[0].xy
        this.eggPoints[1].radians = this.points[1].radians
        this.eggPoints[3].radians = this.points[1].radians + Math.PI
        this.eggPoints[1].xy = this.eggPoints[3].xy = this.points[1].xy

        this.points[0].lookAt(this.points[1], Math.PI * .58)


================================================================================
END: egg-4-5.js
================================================================================



================================================================================
FILE: egg-4-6.js
================================================================================

/*
title: Egg 2
categories: curve
src_dir: ../point_src/
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
    ../point_src/functions/springs.js
---

 */
class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        let size = 200
        let spin = .44
        let pj = this.projectionLength = size * .3// * ((Math.sin(spin) + Math.cos(spin) ) * .5)
        this.createPoints(size, size * .3)
        this.dragging.add(...this.points)
        // this.dragging.add(...this.points, ...this.controlPoints)

        this.lineStroke = new Stroke({
            color: '#ccc'
            , width: 2
            , dash: [5,2]
        })

        // this.events.wake()
    }

    createPoints(height=300,  pj=this.projectionLength) {
        let x = 400
            , y = 300
            , y2 = height + y
            , footSize = 1.6

        this.points = new PointList(
            new Point({x, y
                , radius: pj * footSize
                , rotation: 0
                , vx: 0, vy: 1
                , mass: 1
            })
            , new Point({x, y2
                , radius: pj
                , rotation:  0
                , vx: 0, vy: 1
                , mass: 1
            })
        )

        this.eggPoints = new PointList(
            new Point(x, y, pj * footSize)
            , new Point(x, y2, pj)

            , new Point(x, y, pj * footSize)
            , new Point(x, y2, pj)
        )

        this.lineA = new BezierCurve(this.eggPoints[0], this.eggPoints[1])
        this.lineB = new BezierCurve(this.eggPoints[2], this.eggPoints[3])
        this.lineA.doTips = false
        this.lineB.doTips = false
    }

    updatePointsToControl() {
        this.eggPoints[0].radians = this.points[0].radians
        this.eggPoints[2].radians = this.points[0].radians + Math.PI
        this.eggPoints[0].xy = this.eggPoints[2].xy = this.points[0].xy
        this.eggPoints[1].radians = this.points[1].radians
        this.eggPoints[3].radians = this.points[1].radians + Math.PI
        this.eggPoints[1].xy = this.eggPoints[3].xy = this.points[1].xy

        this.points[0].lookAt(this.points[1], Math.PI * .5)
        this.points[1].lookAt(this.points[0], Math.PI * -.5)
    }

    draw(ctx){
        this.clear(ctx)


================================================================================
END: egg-4-6.js
================================================================================



================================================================================
FILE: egg-4.js
================================================================================

/*
title: Egg 2
categories: curve
src_dir: ../point_src/
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
---

 */
class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        let size = 200
        let spin = .44
        let pj = this.projectionLength = size * ((Math.sin(spin) + Math.cos(spin) ) * .5)
        this.createPoints(size, pj)

        this.dragging.add(...this.points, ...this.controlPoints)

        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this.lineStroke2 = new Stroke({
            color: '#CCC'
            , width: 2
            , dash: [7, 4]
        })

        this.events.wake()
    }

    createPoints(width=200,  pj=this.projectionLength) {
        let x = 400
            , x2 = width + x
            , y = 300

        this.points = new PointList(
            new Point(x, y, pj)
            , new Point(x2, y, pj)
        )

        this.eggPoints = new PointList(
            new Point(x, y, pj)
            , new Point(x2, y, pj)

            , new Point(x, y, pj, 90)
            , new Point(x2, y, pj, 90)
        )


        this.controlPoints = new PointList(
            this.eggPoints[0].project()
            , this.eggPoints[1].project()
            // , this.eggPoints[2].project()
            // , this.eggPoints[3].project()
        )

        let stage = this;
        this.controlPoints.forEach((p,i)=>{

            p.onDragStart = function() {
                // console.log('Drag start')
                this._release = true;
            }

            p.onDragMove = function() {
                // console.log('Drag move')
                stage.controlPointsDistances[i] = stage.controlPoints[i].distance2D(stage.eggPoints[i])

            }
            p.onDragEnd = function() {
                // console.log('Drag end')
                stage.controlPointsDistances[i] = stage.controlPoints[i].distance2D(stage.eggPoints[i])
                this._release = false;
            }


================================================================================
END: egg-4.js
================================================================================



================================================================================
FILE: egg-5.js
================================================================================

/*
title: Circle Curve (Egg bezierFactor)
categories: curve
src_dir: ../point_src/
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    ../point_src/split.js
    ../point_src/angle.js

---

 */

function bezierFactor(count) {
    // Formula: factor = (4/3) * tan( ( / 2) / count )
    return (4 / 3) * Math.tan(Math.PI / (2 * count));
}


class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        this.generate()
        this.dragging.add(...this.points)
        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this.events.wake()
    }

    generate(count=random.int(3,6), radius=100) {
        let factor = bezierFactor(count)
        let size = radius * factor
        let p = this.center.copy().update({radius})
        this.point = this.center.copy().update({radius: radius - 5})
        let rot = Angle.from(1/4).turns

        /* Split on a point, returns many points around the radius. */
        const _splits = p.split(count, rot.rad)
        _splits.each.radius = size

        let lines = this.lines = []
        let length = _splits.length;

        /* Generate a new list of points, 2 points per line*/
        let res = new PointList;

        /* Generate many curves. connecting pairs. */
        for (var i = 0; i < length; i++) {
            let nextValue = i + 1;
            if(nextValue == length) {
                nextValue = 0 // wrap around.
            }
            let o = _splits[nextValue].copy()
            let a = _splits[i].copy()
            o.rotation += 180
            let line = new BezierCurve(a, o)
            res.push(a, o)
            lines.push(line)
        }

        this.points = res;
        return res
    }

    draw(ctx){
        this.clear(ctx)
        let col = {color: '#336600'}
        this.points.pen.indicator(ctx, {color: '#336600'})

        let lineStroke = this.lineStroke
        lineStroke.set(ctx)

        this.lines.forEach((l)=>{
            l.render(ctx, {color: '#44CC55'});
        });


================================================================================
END: egg-5.js
================================================================================



================================================================================
FILE: egg-6.js
================================================================================

/*
title: Egg 2
categories: curve
src_dir: ../point_src/
files:
    head
    pointlist
    point
    ../point_src/math.js
    ../point_src/point-content.js
    mouse
    stage
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    xybind
---

*/
class MainStage extends Stage {
    canvas = 'playspace'
    live = true

    mounted() {
        this.angleX = 0
        this.angleY = 0
        this.angleZ = 0

        this.radius = 100
        // this.center = this.center || new Point(400, 300) // fallback if not set
        this.point = this.center.copy().update({radius: this.radius})
        this.dragging.add(this.point)

        // Create static circle points in local XY plane
        this.circlePoints3D = []
        const steps = 40
        for (let i = 0; i < steps; i++) {
            const theta = (Math.PI * 2 * i) / steps
            const x = Math.cos(theta) * this.radius
            const y = Math.sin(theta) * this.radius
            this.circlePoints3D.push({ x, y, z: 0 })
        }
    }

    draw(ctx) {
        this.clear(ctx)

        this.angleX += -Math.cos(this.angleY) * .01
        this.angleY += Math.sin(this.angleX) * .04
        // this.angleZ += 0.01

        const center = this.center
        const rotatedProjected = this.circlePoints3D.map(p => {
            let r = rotate3D(p, this.angleX, this.angleY, this.angleZ)
            let scale = 1 // (r.z * 0.003 + 1)
            return {
                x: r.x * scale + this.point.x,
                y: r.y * scale + this.point.y
            }
        })

        // Draw the disc outline
        ctx.beginPath()
        for (let i = 0; i < rotatedProjected.length; i++) {
            const p = rotatedProjected[i]
            if (i === 0) ctx.moveTo(p.x, p.y)
            else ctx.lineTo(p.x, p.y)
        }
        ctx.closePath()

        ctx.strokeStyle = '#AA6666'
        ctx.lineWidth = 2
        ctx.stroke()

        // Optionally, fill the disc
        ctx.fillStyle = 'rgba(200, 100, 100, 0.3)'
        ctx.fill()
        this.point.pen.indicator(ctx, {color: '#AA6666'})

    }

    draw(ctx) {
        this.clear(ctx)

        // this.angleX += 0.01
        this.angleY += 0.1
        this.angleZ += 0.01
        this.drawDisc(ctx)
        this.point.pen.indicator(ctx, {color: '#AA6666'})
    }

    drawDisc(ctx) {

        const center = this.point
        const baseRadius = this.point.radius



================================================================================
END: egg-6.js
================================================================================



================================================================================
FILE: egg.js
================================================================================

/*
title: Egg
categories: curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js

 */
class MainStage extends Stage {
    canvas='playspace'
    live = true
    mounted(){

        let size = 200
        let spin = .44
        let pj = this.projectionLength = size * ((Math.sin(spin) + Math.cos(spin) ) * .5)
        this.createPoints(size, pj)
        this.controlPointA = this.pointA.project()
        this.controlPointB = this.pointB.project()

        this.dragging.add(this.pointB, this.pointA,)
                        // this.controlPointA, this.controlPointB)

        // this.controlPointA.onDragMove = this.updatePointsToControl.bind(this)
        // this.controlPointB.onDragMove = this.updatePointsToControl.bind(this)

        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this.events.wake()

    }

    createPoints(width=200,  pj=this.projectionLength) {

        let x = 400
            , x2 = width + x
            , y = 300
                        // x, y, width, rotation
        this.pointA = new Point(x, y, pj, 90)
        this.pointB = new Point(x2, y, pj, 90) // default rotation == 0 (looking right)

        this.point0 = new Point(500, y, 100)

        this.pointC = new Point(x, y, pj, 90)
        this.pointD = new Point(x2, y, pj, 90) // default rotation == 0 (looking right)

        this.lineA = new BezierCurve(this.pointA, this.pointB)
        this.lineB = new BezierCurve(this.pointC, this.pointD)

        this.lineA.doTips = false;
        this.lineB.doTips = false;

    }

    updatePointsToControl(){
        // this.pointA.lookAt(this.controlPointA)
        // this.pointB.lookAt(this.controlPointB)
        this.pointC.radius = this.pointA.radius // = this.pointA.distanceTo(this.controlPointA)
        this.pointD.radius = this.pointB.radius // = this.pointB.distanceTo(this.controlPointB)

        this.pointC.rotation = this.pointA.rotation + 180
        this.pointD.rotation = this.pointB.rotation + 180

    }

    draw(ctx){
        this.clear(ctx)

        if(this.clock.tick % 5) {
            this.updatePointsToControl()
        }

        // show the spare points
        this.pointA.pen.indicator(ctx, {color: '#444'})
        this.pointB.pen.indicator(ctx, {color: '#444'})
        this.pointC.pen.indicator(ctx, {color: '#444'})
        this.pointD.pen.indicator(ctx, {color: '#444'})
        // this.point0.pen.indicator(ctx, {color: '#ccc'})



================================================================================
END: egg.js
================================================================================



================================================================================
FILE: elbow-2.js
================================================================================

/*
title: Elbow Constraints
category: constraints
files:
    head
    point
    stroke
    ../point_src/point-content.js
    pointlist
    mouse
    distances
    dragging
    ../point_src/functions/clamp.js
    ../point_src/mirror.js
    ../point_src/stage.js
    ../point_src/text/label.js
    ../point_src/intersections.js
    ../point_src/constrain-distance.js
---

An elbow contraint ensures a target point is _connected_ to another point, at
a distance of the two radii.

        point.constraint.elbow(other)

It's called an elbow, as there will always be an intersection at the max distance.
Similar to rings bound at the edge.

Synonymous to:

    let pA = this.endPoint
    let pB = this.primaryPoint

    pA.leash(pointB,
        (pB.radius + pA.radius) - .01)
    pA.avoid(pointB,
        Math.abs(pB.radius - pA.radius) + .01)

*/


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.endPoint = new Point({x:200,y:200, radius:90})
        this.primaryPoint = new Point({x:390,y:240, radius:130})
        this.dragging.addPoints(this.endPoint, this.primaryPoint)
        this.events.wake()

    }

    draw(ctx){
        this.clear(ctx)
        this.endPoint.constraint.elbow(this.primaryPoint)

        let i2 = this.endPoint.intersections.of(this.primaryPoint)
        // let i2 = getCircleCircleIntersections(this.endPoint, this.primaryPoint)

        if(i2.length > 0) {
            /* draw (quietly) the ignored point. */
            Point.from(i2[1]).pen.fill(ctx, '#332233')
        }

        this.endPoint.pen.indicator(ctx, {color: '#222'})
        this.primaryPoint.pen.indicator(ctx)

        if(i2.length > 0) {
            this.endPoint.pen.line(ctx, i2[0], 'red')
            this.primaryPoint.pen.line(ctx, i2[0], 'red')
            Point.from(i2[0]).pen.fill(ctx, '#CC00BB')
        }
    }
}


;stage = MainStage.go();

================================================================================
END: elbow-2.js
================================================================================



================================================================================
FILE: ellipse-example-2.js
================================================================================

/*
title: Ellipse Example 2
categories: simple
    ellipse
files:
    head
    stroke
    pointlist
    point
    mouse
    dragging
    stage
---

*/


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = new Point(200,200, 100, 0)
        this.start = new Point(200,200, 50, 20)
        this.end = new Point(200,200, 50, -20)
        this.dragging.addPoints(this.pointA, this.start, this.end)
    }

    draw(ctx){
        this.clear(ctx)

        let p = this.pointA;
        p.pen.indicator(ctx)
        let width = p.radius * .5
            , height = p.radius
        let start = this.start
        let end = this.end
        start.pen.indicator(ctx)
        end.pen.indicator(ctx)

        p.pen.ellipse(ctx, {width, height, start: start.radians, end: end.radians}, 'red')
    }
}


;stage = MainStage.go();

================================================================================
END: ellipse-example-2.js
================================================================================



================================================================================
FILE: ellipse-example-3.js
================================================================================

/*
title: Ellipse Example 3
categories: simple
    ellipse
files:
    head
    stroke
    pointlist
    point
    mouse
    dragging
    stage
    ../point_src/line.js
    ../point_src/recttools.js
---

*/


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = this.center.copy().update({radius: 80, radians:0})
        this.start = new Point(100, 300, 50, 20)
        this.end = new Point(100, 460, 50, -20)
        this.squishA = new Point(100,100, 10, 0)
        this.squishB = this.squishA.add(100, 50)
        this.rel = true
        this.dragging.addPoints(
                this.pointA,
                this.start,
                this.end,
                this.squishA,
                this.squishB,
                )
    }

    draw(ctx){
        this.clear(ctx)

        let p = this.pointA;
        p.pen.indicator(ctx)
        let size = this.squishA.distance2D(this.squishB)
        let width = Math.abs(size.x)
            , height = Math.abs(size.y)
        let start = this.start
        let end = this.end

        start.pen.indicator(ctx)
        end.pen.indicator(ctx)

        this.squishA.pen.fill(ctx, '#990000')
        this.squishB.pen.fill(ctx, '#990000')

        let lines = twoPointBox(this.squishA, this.squishB)
        lines.forEach(l=>l.render(ctx))

        p.pen.ellipse(ctx, {
                    width, height
                    , start: start.radians
                    , end: end.radians
                    , relative: this.rel
                },
                'red')
    }
}


;stage = MainStage.go();

================================================================================
END: ellipse-example-3.js
================================================================================



================================================================================
FILE: ellipse-example-4.js
================================================================================

/*
title: Ellipse Example 4
categories: simple
    ellipse
files:
    head
    stroke
    pointlist
    point
    mouse
    dragging
    stage
    ../point_src/line.js
    ../point_src/recttools.js
---

*/


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = this.center.copy().update({radius: 80, radians:0})
        this.pointB = this.center.copy().update({radius: 80, radians:0})
        this.start = new Point(100, 300, 50, 20)
        this.end = new Point(100, 460, 50, -20)
        this.squishA = new Point(100,100, 10, 0)
        this.squishB = this.squishA.add(100, 50)
        this.rel = true
        this.dragging.addPoints(
                this.pointA,
                this.pointB,
                this.start,
                this.end,
                this.squishA,
                this.squishB,
                )
    }

    draw(ctx){
        this.clear(ctx)

        let p = this.pointA;
        p.pen.indicator(ctx)
        this.pointB.pen.indicator(ctx)
        let size = this.squishA.distance2D(this.squishB)
        let width = Math.abs(size.x)
            , height = Math.abs(size.y)
        let start = this.start
        let end = this.end

        start.pen.indicator(ctx)
        end.pen.indicator(ctx)

        this.squishA.pen.fill(ctx, '#990000')
        this.squishB.pen.fill(ctx, '#990000')


        let lines = twoPointBox(this.squishA, this.squishB)
        lines.forEach(l=>l.render(ctx))

        p.pen.ellipse(ctx, {
                    width, height
                    , start: this.pointB.radians + start.radians
                    , end: this.pointB.radians + end.radians
                    , relative: this.rel
                },
                'red')
    }
}


;stage = MainStage.go();

================================================================================
END: ellipse-example-4.js
================================================================================



================================================================================
FILE: ellipse-example.js
================================================================================

/*
title: Ellipse Example
categories: simple
    ellipse
files:
    head
    stroke
    pointlist
    point
    mouse
    dragging
    stage
---

*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = new Point(200,200, 100, 0)
        this.dragging.addPoints(this.pointA)
    }

    draw(ctx){
        this.clear(ctx)

        let p = this.pointA;
        p.pen.indicator(ctx)
        let width = p.radius * .5
            , height = p.radius
        p.pen.ellipse(ctx, {width, height, end: Math.PI}, 'red')
    }
}


;stage = MainStage.go();

================================================================================
END: ellipse-example.js
================================================================================



================================================================================
FILE: emit-curve-second.js
================================================================================

/*
title: Emitter Curve
category: emitter
files:
    head
    ../point_src/math.js
    point
    ../point_src/point-content.js
    pointlist
    mouse
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    stage
    stroke
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js
    ../point_src/split.js
    ../point_src/curve-extras.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)

        let lpoints = [new Point(200, 600, 400, 0)
                      , new Point(800, 200, 400, 180)
                      ]
        this.line = new BezierCurve(...lpoints)
        this.line.doTips = false;

        let le = new LineEmitter()
        this.lineEmitter = le

        let conf = {
            tickModulo: 1
            , baseRadius: 1
            , minSize: 1
            , maxSize: 4
            , radius: 1
            , lifetime: 180
            , birthrate: 4
            , baseSpeed: .1
            , radiusVariant: 3
            , lifetimeVariant: 1
            , direction: ()=> [random.float(-1, 1),0]
            // , direction: ()=> [random.choice([-1, 1]),0]
            // , direction: {x:1, y:0}
        }


        le.update(conf)

        le.cachePoints(this.line, .5)
        le.wake()

        this.dragging.add(...this.line.points)
        this.dragging.onDragEnd = this.onDragEnd.bind(this)
        this.dragging.onDragMove = this.onDragMove.bind(this)
    }

    onDragEnd() {}
    onDragMove() {
        this.lineEmitter.cachePoints(this.line, .5)
    }

    draw(ctx){
        this.clear(ctx)

        ctx.strokStyle = '#EEE'
        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px sans-serif`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        this.lineEmitter.step()
        let pointColor = 'hsl(254deg 81% 36%)'
        let lineColor = 'hsl(269deg 82% 44%)'
        // pointColor = lineColor
        // let lineColor = 'hsl(299deg 62% 44%)' // light
        this.lineEmitter.points.pen.fill(ctx, pointColor)
        this.line.render(ctx, {color: lineColor, width: 3})

        ctx.fillStyle = '#EEE'

        this.line.points[0].text.fill(ctx
            , this.lineEmitter.points.length
            , {x:30, y:0}
        )
    }
}




================================================================================
END: emit-curve-second.js
================================================================================



================================================================================
FILE: emit-curve.js
================================================================================

/*
title: Emitter Curve
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/math.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js
    ../point_src/split.js
    ../point_src/curve-extras.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()

        let e2 = new RandomPointEmitter(400,400, 60)
        // e2.direction = {x:-1, y:0} //inward.
        e2.fromEdge = true
        e2.tickModulo = 12
        e2.speed = 1
        e2.birthrate = 10
        e2.wake()
        this.e2 = e2


        // let e3 = new Emitter(500,200, 60)
        // e3.fromEdge = true
        // e3.tickModulo = 100
        // e3.birthrate = 20
        // e3.lifetime = 200
        let e3 = new PumpRandomPointEmitter(500,200, 60)
        e3.wake()
        this.e3 = e3

        // this.dragging.add(this.e1, e2, e3)


        let lpoints = [new Point(200, 600, 400, -90), new Point(600, 600, 400, -90)]
        this.line = new BezierCurve(...lpoints)

        let le = new LineEmitter()
        this.lineEmitter = le
        le.tickModulo = 1
        le.birthrate = 1
        le.radiusVariant = 1
        // le.lifetime = 200
        le.cachePoints(this.line, .5)
        le.wake()

        this.dragging.add(e2, e3, ...this.line.points)
        this.dragging.onDragEnd = this.onDragEnd.bind(this)
        this.dragging.onDragMove = this.onDragMove.bind(this)
    }

    onDragEnd() {}
    onDragMove() {
        this.lineEmitter.cachePoints(this.line, .5)
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e2, this.e3]
        // let es = [this.e1, this.e2, this.e3]

        ctx.strokStyle = '#EEE'
        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px sans-serif`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        /*
        this.e2.step()
        this.e2.pen.indicator(ctx)

        es.forEach(e=>{
            e.step()
            e.rotation += (e.speed || 0)


================================================================================
END: emit-curve.js
================================================================================



================================================================================
FILE: emit-line-drawing-2.js
================================================================================

/*
title: Emitter Line
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js
    ../point_src/split.js
    ../point_src/curve-extras.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)

        let lpoints = [new Point(400, 400), new Point(100, 400)]
        this.line = new Line(...lpoints)

        let le = new LineEmitter()
        this.lineEmitter = le
        le.tickModulo = 1
        le.birthrate = 2
        le.lifetime = 400
        le.direction = {x: 0, y:1} // this.point.direction
        le.cachePoints(this.line, .5)
        le.wake()

        this.dragging.add(...this.line.points, this.point)
        // this.dragging.onDragEnd = this.onDragEnd.bind(this)
        this.dragging.onDragMove = this.onDragMove.bind(this)
    }

    // onDragEnd() {}
    onDragMove() {
        this.lineEmitter.cachePoints(this.line, .5)
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e2, this.e3]
        // let es = [this.e1, this.e2, this.e3]

        ctx.strokStyle = '#EEE'
        ctx.fillStyle = 'purple'
        ctx.font = `400 16px sans-serif`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        this.lineEmitter.step()

        this.lineEmitter.points.forEach((p)=> {
            ctx.moveTo(p.x + p.radius, p.y)
            // ctx.beginPath()
            ctx.closePath()
            p.draw.circle(ctx)
        })

        ctx.fill()
        // ctx.stroke()
        this.line.points[0].text.fill(ctx, this.lineEmitter.points.length, {x:30, y:0})
        this.point.pen.indicator(ctx, '#880000')

        this.line.render(ctx)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: emit-line-drawing-2.js
================================================================================



================================================================================
FILE: emit-line-drawing.js
================================================================================

/*
title: Emitter Line
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js
    ../point_src/split.js
    ../point_src/curve-extras.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()

        let e2 = new RandomPointEmitter(400,400, 60)
        // e2.direction = {x:-1, y:0} //inward.
        e2.fromEdge = true
        e2.tickModulo = 12
        e2.speed = 1
        e2.birthrate = 10

        // let e2 = new RandomPointEmitter({
        //     x: 400
        //     , y: 400
        //     , radius: 60
        //     // e2.direction = {x:-1, y:0} //inward.
        //     , fromEdge: true
        //     , tickModulo: 12
        //     , speed: 1
        //     , birthrate: 10
        // })


        e2.wake()
        this.e2 = e2


        // let e3 = new Emitter(500,200, 60)
        // e3.fromEdge = true
        // e3.tickModulo = 100
        // e3.birthrate = 20
        // e3.lifetime = 200
        let e3 = new PumpRandomPointEmitter(500,200, 60)
        e3.wake()
        this.e3 = e3

        // this.dragging.add(this.e1, e2, e3)


        let lpoints = [new Point(100, 100), new Point(100, 500)]
        this.line = new Line(...lpoints)
        // this.line = new BezierCurve(...lpoints)

        let le = new LineEmitter()
        this.lineEmitter = le
        le.tickModulo = 1
        le.birthrate = 2
        le.lifetime = 400
        le.cachePoints(this.line, .5)
        le.wake()

        this.dragging.add(e2, e3, ...this.line.points)
        this.dragging.onDragEnd = this.onDragEnd.bind(this)
        this.dragging.onDragMove = this.onDragMove.bind(this)
    }

    onDragEnd() {}
    onDragMove() {
        this.lineEmitter.cachePoints(this.line, .5)
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e2, this.e3]
        // let es = [this.e1, this.e2, this.e3]



================================================================================
END: emit-line-drawing.js
================================================================================



================================================================================
FILE: emit-line.js
================================================================================

/*
title: Emitter Line
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js
    ../point_src/split.js
    ../point_src/curve-extras.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()

        let e2 = new RandomPointEmitter(400,400, 60)
        // e2.direction = {x:-1, y:0} //inward.
        e2.fromEdge = true
        e2.tickModulo = 12
        e2.speed = 1
        e2.birthrate = 10

        // let e2 = new RandomPointEmitter({
        //     x: 400
        //     , y: 400
        //     , radius: 60
        //     // e2.direction = {x:-1, y:0} //inward.
        //     , fromEdge: true
        //     , tickModulo: 12
        //     , speed: 1
        //     , birthrate: 10
        // })


        e2.wake()
        this.e2 = e2


        // let e3 = new Emitter(500,200, 60)
        // e3.fromEdge = true
        // e3.tickModulo = 100
        // e3.birthrate = 20
        // e3.lifetime = 200
        let e3 = new PumpRandomPointEmitter(500,200, 60)
        e3.wake()
        this.e3 = e3

        // this.dragging.add(this.e1, e2, e3)


        let lpoints = [new Point(100, 100), new Point(100, 500)]
        this.line = new Line(...lpoints)
        // this.line = new BezierCurve(...lpoints)

        let le = new LineEmitter()
        this.lineEmitter = le
        le.tickModulo = 1
        le.birthrate = 1
        // le.lifetime = 200
        le.cachePoints(this.line, .5)
        le.wake()

        this.dragging.add(e2, e3, ...this.line.points)
        this.dragging.onDragEnd = this.onDragEnd.bind(this)
        this.dragging.onDragMove = this.onDragMove.bind(this)
    }

    onDragEnd() {}
    onDragMove() {
        this.lineEmitter.cachePoints(this.line, .5)
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e2, this.e3]
        // let es = [this.e1, this.e2, this.e3]



================================================================================
END: emit-line.js
================================================================================



================================================================================
FILE: emitter-2.js
================================================================================

/*
title: Emitter
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js
---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()

        let e2 = new RandomPointEmitter(400,400, 60)
        // e2.direction = {x:-1, y:0} //inward.
        e2.fromEdge = true
        e2.tickModulo = 10
        e2.speed = 2
        e2.birthrate = 1
        e2.wake()
        this.e2 = e2


        // let e3 = new Emitter(500,200, 60)
        // e3.fromEdge = true
        // e3.tickModulo = 100
        // e3.birthrate = 20
        // e3.lifetime = 200
        let e3 = new PumpRandomPointEmitter(500,200, 60)
        e3.wake()
        this.e3 = e3

        this.dragging.add(e2, e3)
        // this.dragging.add(this.e1, e2, e3)
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e2, this.e3]
        // let es = [this.e1, this.e2, this.e3]

        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px sans-serif`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        es.forEach(e=>{
            e.step()
            e.rotation += (e.speed || 0)
            // e.lookAt(this.mouse.point)
            e.pen.circle(ctx)
            e.text.fill(ctx, e.length)
            e.points.pen.indicators(ctx)
        })

        this.point.pen.fill(ctx, '#880000')
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: emitter-2.js
================================================================================



================================================================================
FILE: emitter-3.js
================================================================================

/*
title: Emitter 3
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()

        let e2 = new RandomPointEmitter(400,400, 60)
        // e2.direction = {x:-1, y:0} //inward.
        e2.fromEdge = true
        e2.tickModulo = 12
        e2.speed = 1
        e2.birthrate = 10
        e2.wake()
        this.e2 = e2


        // let e3 = new Emitter(500,200, 60)
        // e3.fromEdge = true
        // e3.tickModulo = 100
        // e3.birthrate = 20
        // e3.lifetime = 200
        let e3 = new PumpRandomPointEmitter(500,200, 60)
        e3.wake()
        this.e3 = e3

        this.dragging.add(e2, e3)
        // this.dragging.add(this.e1, e2, e3)

        this.stamp = new Stamp()
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e2, this.e3]
        // let es = [this.e1, this.e2, this.e3]

        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px sans-serif`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        this.e2.step()
        this.e2.pen.indicator(ctx)
        es.forEach(e=>{
            e.step()
            e.rotation += (e.speed || 0)
            // e.lookAt(this.mouse.point)
            e.pen.circle(ctx)
            e.text.fill(ctx, e.length)
            e.points.pen.indicators(ctx)
            // e.points.pen.indicators(ctx)
        })


        // this.point.pen.fill(ctx, '#880000')
    }
}

class Stamp {

    render(ctx, points, func) {
        ctx.save();
        let prev = points[0]
        points.forEach((p)=>{
            // ctx.translate(p.x, p.y)
            let np = p.subtract(prev)
            ctx.translate(np.x, np.y)
            // ctx.rotate(p.radians)
            func(np)
            prev = p
        });


================================================================================
END: emitter-3.js
================================================================================



================================================================================
FILE: emitter-4.js
================================================================================

/*
title: Emitter 4
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()

        let e2 = new PumpRandomPointEmitter(400,400, 60)
        // let e2 = new RandomPointEmitter(400,400, 60)
        e2.direction = {x:-1, y:0} //inward.
        e2.fromEdge = true
        e2.tickModulo = 10
        e2.speed = 1
        e2.birthrate = 3
        e2.lifetime = e2.radius * .5
        e2.wake()
        this.e2 = e2


        // let e3 = new Emitter(500,200, 60)
        // e3.fromEdge = true
        // e3.tickModulo = 100
        // e3.birthrate = 20
        // e3.lifetime = 200
        let e3 = new PumpRandomPointEmitter(500,200, 60)
        e3.wake()
        this.e3 = e3

        this.dragging.add(e2, e3)
        // this.dragging.add(this.e1, e2, e3)
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e2, this.e3]
        // let es = [this.e1, this.e2, this.e3]

        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px sans-serif`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        es.forEach(e=>{
            e.step()
            e.rotation += (e.speed || 0)
            // e.lookAt(this.mouse.point)
            e.pen.circle(ctx)
            e.text.fill(ctx, e.length)
            e.points.pen.indicators(ctx)
        })

        this.point.pen.fill(ctx, '#880000')
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: emitter-4.js
================================================================================



================================================================================
FILE: emitter-5.js
================================================================================

/*
title: Emitter 4
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()

        let e2 = new RandomPointEmitter(400,400, 60)
        // let e2 = new PumpRandomPointEmitter(400,400, 60)
        // let e2 = new RandomPointEmitter(400,400, 60)
        e2.direction = {x:1, y:0} //inward.
        e2.fromEdge = true
        e2.directionVariant = 200
        e2.tickModulo = 3
        e2.speed = .2
        e2.birthrate = 3
        e2.minSize = 1
        e2.particleSpeed = 1
        e2.lifetime = e2.radius * 3
        e2.wake()
        this.e2 = e2


        // let e3 = new Emitter(500,200, 60)
        // e3.fromEdge = true
        // e3.tickModulo = 100
        // e3.birthrate = 20
        // e3.lifetime = 200
        let e3 = new PumpRandomPointEmitter(500,200, 60)
        e3.wake()
        this.e3 = e3

        this.dragging.add(e2, e3)
        // this.dragging.add(this.e1, e2, e3)
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e2]
        // let es = [this.e1, this.e2, this.e3]

        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px sans-serif`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        es.forEach((e,i)=>{

            e.step()
            e.rotation += (e.speed || 0)
            // e.lookAt(this.mouse.point)
            e.pen.circle(ctx, {color: 'purple', width: 2})
            e.text.fill(ctx, e.length)
            // e.points.pen.indicators(ctx)
            // e.points.forEach(p=>{
            //     p.radius = clamp( (p.lifetime * 3 / p.age * 4) - 2, 0, 30)
            //     // p.radius = clamp( (p.age * 3 / p.lifetime * 4) - 2, 0, 30)
            // })
            // e.points.pen.lines(ctx, 'pink', 2)

            e.points.forEach(p=>{
                // p.radius = clamp( (p.lifetime * 3 / p.age * 4) - 2, 0, 30)
                p.radius = clamp( (p.age * 3 / p.lifetime * 4) - 2, 0, 30)
            })
            e.points.pen.lines(ctx, 'purple', 2)

        })

        // this.point.pen.fill(ctx, '#880000')
    }
}


================================================================================
END: emitter-5.js
================================================================================



================================================================================
FILE: emitter-6.js
================================================================================

/*
title: Emitter 4
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()

        let e2 = new RandomPointEmitter(400,400, 60)
        // let e2 = new PumpRandomPointEmitter(400,400, 60)
        // let e2 = new RandomPointEmitter(400,400, 60)
        e2.direction = {x:1, y:0} //inward.
        e2.fromEdge = true
        e2.directionVariant = 260
        e2.tickModulo = 7
        e2.speed = .2
        e2.birthrate = 2
        e2.minSize = 1
        e2.particleSpeed = .9
        e2.lifetime = e2.radius * 2
        e2.wake()
        this.e2 = e2

        this.dragging.add(e2)
        // this.dragging.add(this.e1, e2, e3)
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e2]
        // let es = [this.e1, this.e2, this.e3]

        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px sans-serif`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        es.forEach((e,i)=>{

            e.step()
            e.rotation += (e.speed || 0)
            // e.lookAt(this.mouse.point)
            e.pen.circle(ctx, {color: 'purple', width: 2})
            e.text.fill(ctx, e.length)
            e.points.forEach(p=>{
                p.radius = clamp( (p.lifetime * 3 / p.age * 4) - 2, 0, 30)
                // p.radius = clamp( (p.age * 3 / p.lifetime * 4) - 2, 0, 30)
            })
            e.points.pen.lines(ctx, 'purple', 2)

        })

        // this.point.pen.fill(ctx, '#880000')
    }
}


stage = MainStage.go(/*{ loop: true }*/)

================================================================================
END: emitter-6.js
================================================================================



================================================================================
FILE: emitter-sun.js
================================================================================

/*
title: Emitter Sun
categories: emitter
     gradient
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/text/beta.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/text/styler.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/gradient.js
 */
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        this.textPos = new Point(100, 100, 20)
        // this.events.wake()
        // let e1 = this.e1 = new Emitter(200,200, 80)

        // let e1 = this.e1 = new RandomPointEmitter(400,400, 60)

        // // e1.radiusVariant = .1
        // e1.directionVariant = 100
        // e1.particleSpeed = .6
        // e1.lifetime = 600
        // e1.fromEdge = true
        // e1.tickModulo = 2
        // // e1.speed = 100
        // e1.birthrate = 1
        // e1.pointLimit = 1000
        // debugger;
        let e1 = this.e1 = new RandomPointEmitter()
        e1.update({
            x: 400
            , y: 400
            , radius: 60
            // , radiusVariant: .1
            , directionVariant: 100
            , particleSpeed: .6
            , lifetime: 200
            , fromEdge: true
            , spawnOffset: true
            , tickModulo: 2
            // , speed: 100
            , birthrate: .6
            , pointLimit: 1000
        })

        e1.wake()

        // e1.direction = {x:-1, y:0} //inward.

        this.e1 = e1
        this.g = (new Gradient).radial(this.e1)

        let c1 = '#fbc148'
        let c2 = '#d64b02'

        this.g.addStops({
            0: {color: c1}
            ,1: {color: c2} // dark
            // ,1: {color: '#c31a01'} // dark
        })
        // e1.wake()

        this.dragging.add(this.point, this.e1)
    }

    draw(ctx){
        this.clear(ctx)
        this.e1.step()
        this.g.radial() // refresh hack.
        let grad = this.g.getObject(ctx)

        // let v = this.point.speed2D.absFloat() + 10
        // let vh = (v * .5)
        // let speed = (1+v) * .1
        // speed = clamp((speed * speed) * .5, .1, 10)

        // this.e1.points.forEach(p => {
        //     if (p._vx == undefined) {


================================================================================
END: emitter-sun.js
================================================================================



================================================================================
FILE: emitter.js
================================================================================

/*
title: Emitter
category: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js


---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()
        this.e1 = new Emitter(200,200, 80)
        this.e1.wake()

        let e2 = new Emitter(400,400, 60)
        e2.direction = {x:-1, y:0} //inward.
        e2.fromEdge = true
        e2.tickModulo = 10
        e2.wake()
        this.e2 = e2


        // let e3 = new Emitter(500,200, 60)
        let e3 = new Emitter(500,200, 60)
        e3.fromEdge = true
        e3.tickModulo = 10
        e3.birthrate = 1
        e3.lifetime = 200
        e3.wake()
        this.e3 = e3

        this.dragging.add(this.e1, e2, e3)
    }

    draw(ctx){
        this.clear(ctx)
        let es = [this.e1, this.e2, this.e3]

        es.forEach(e=>{
            e.step()
            e.rotation += 1
            // e.lookAt(this.mouse.point)
            e.pen.circle(ctx)
            e.points.pen.indicators(ctx)
        })

        this.point.pen.fill(ctx, '#880000')
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: emitter.js
================================================================================



================================================================================
FILE: flapper.js
================================================================================

/*
title: Example
categories: basic
    dragging
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    stroke
    ../point_src/constrain-distance.js
    ../point_src/relative.js
    ../point_src/keyboard.js

---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.speed = .2
        this.spread = 8
        this.tick = 0
        this.size = 10
        this.points = new PointList(
                        [450 , 150, 4]
                        , [450 , 270]
                        , [450 , 190]
                        , [250 , 200]
                    ).cast()
        this.points[0].vx = 0
        this.points[0].vy = 0
        this.keyboardSetup(this)
        this.dragging.add(...this.points)
    }

    draw(ctx){
        this.clear(ctx)
        this.tick += 1
        let ps = this.points
        let size = this.size + (ps[1].radius)
        let spread = (this.powerDown? this.spread: 0) * this.speed

        ps[1].lookAt(ps[0], Math.sin(this.tick * this.speed) * spread, .1)
        ps[1].leash(ps[0], size * .8)
        ps[3].leash(ps[2], size * .6)
        let power = this.powerDown? 0.01: 0
        ps[1].rotation += clamp(this.rotationSpeed, -10, 10)
        this.rotationSpeed *= .99
        this.impart(power * this.speed * this.spread)
        this.addMotion(ps[0])
        ps[2].xy = ps[1].project((ps[0].distanceTo(ps[1]) - size) - 20)

        ps[0].rotation = ps[1].rotation
        ps[0].pen.indicator(ctx, {color:'#55ddcc'})
        // ps[1].pen.indicator(ctx, 'green')
        // ps[2].pen.fill(ctx, 'green')
        ps.pen.quadCurve(ctx, 'green', 0)
    }

    addMotion(point, speed=1) {
        /* Because we're in a zero-gravity space, the velocity is simply _added_
        to the current XY, pushing the point in the direction of forced. */
        point.x += point.vx
        point.y += point.vy
        point.vx *= .99
        point.vy *= .99
    }

    keyboardSetup(stage) {
        let kb = stage.keyboard
        kb.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        kb.onKeyup(KC.UP, this.onUpKeyup.bind(this))
        kb.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        kb.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))
        kb.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))
        kb.onKeyup(KC.DOWN, this.onDownKeyup.bind(this))

        this.rotationSpeed = 0
        this.powerDown = false
        this.reverseDown = false
    }

    onUpKeydown(ev) {
        /* On keydown we add some to the throttle.
        As keydown first repeatedly, this will raise the power until
        keyup */
        this.powerDown = true
    }

    onUpKeyup(ev) {
        /* Reset the throttle */
        this.powerDown = false
    }


================================================================================
END: flapper.js
================================================================================



================================================================================
FILE: flower-2.js
================================================================================

/*
title: Egg 2
src_dir: ../point_src/
categories: curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    ../point_src/split.js

---

 */
class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        this.generate()
        this.dragging.add(...this.points)
        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this.events.wake()
    }

    onMouseUp(){
        this.generate()
    }
    generate() {

        /* The general radius of the flower. */
        let radius = random.int(10, 200)
        /* A count of petals. */
        let count = random.int(3, 10)
        /* The size of petals (Their point radius) */
        let size = random.int(20, 200)
        /* We copy the center point to save keystrokes. */
        let p = this.point = this.center.copy().update({radius})

        /* Split on a point, returns many points around the radius. */
        this.points = p.split(count)
        this.points.each.radius = size
        this.size = size;
        let lines = this.lines = []
        let length = this.points.length;

        /* Generate many curves. connecting pairs. */
        for (var i = 0; i < length; i++) {
            let nextValue = i + 1;
            if(nextValue == length) {
                nextValue = 0 // wrap around.
            }
            let line = new BezierCurve(this.points[i], this.points[nextValue])
            lines.push(line)
        }

    }

    draw(ctx){
        this.clear(ctx)
        this.points.pen.indicator(ctx, {color: '#336600'})
        let mouse = this.mouse.position
        this.points.forEach((p)=>{
            let d = p.distanceTo(mouse) * .7
            let td = d
            p.radius = this.size + (clamp(this.size - td, -50, 50) *2)
        })
        let lineStroke = this.lineStroke
        lineStroke.set(ctx)

        this.lines.forEach((l)=>{
            l.render(ctx);
        });

        lineStroke.unset(ctx)

    }
}



================================================================================
END: flower-2.js
================================================================================



================================================================================
FILE: flower-fill.js
================================================================================

/*
title: Flower!
src_dir: ../point_src/
categories: curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    ../point_src/split.js
    ../point_src/gradient.js
    ../point_src/jiggle.js

---

*/


class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        this.point = this.center.copy()
        this.generate()
        this.dragging.add(this.point)
        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this.events.wake()
    }

    onEmptyDown(){
        this.generate()
    }

    generate() {

        /* The general radius of the flower. */
        let radius = random.int(5, 80)
        /* A count of petals. */
        let count = random.int(5, 20)
        /* The size of petals (Their point radius) */
        let size = radius * 3 // random.int(100, 200)
        /* We copy the center point to save keystrokes. */
        let p = this.point.update({radius})

        /* Split on a point, returns many points around the radius. */
        this.points = p.split(count)
        this.points.each.radius = size

        let lines = this.lines = []
        let length = this.points.length;

        /* Generate many curves. connecting pairs. */
        for (var i = 0; i < length; i++) {
            let nextValue = i + 1;
            if(nextValue == length) {
                nextValue = 0 // wrap around.
            }
            let line = new BezierCurve(this.points[i], this.points[nextValue])
            line.doTips = false;
            lines.push(line)
        }

        this.grad = this.setupGradient(this.point,size)
    }

    setupGradient(p, size) {
        var g = new Gradient(null, 'Linear', [p.add(size * .5), p.subtract(size * .5)])
        g.addStops({
            0: "hsl(244deg 71% 56%)"
            , 1: "hsl(299deg 62% 44%)"
        })
        return g
    }

    draw(ctx){
        this.clear(ctx)
        // this.points.pen.indicator(ctx, {color: '#336600'})
        ctx.fillStyle = this.grad.getObject(ctx)


================================================================================
END: flower-fill.js
================================================================================



================================================================================
FILE: flower.js
================================================================================

/*
title: Egg 2
src_dir: ../point_src/
categories: curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    ../point_src/split.js

---

 */
class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        this.generate()
        this.dragging.add(...this.points)
        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this.events.wake()
    }

    onMouseUp(){
        this.generate()
    }
    generate() {

        /* The general radius of the flower. */
        let radius = random.int(10, 200)
        /* A count of petals. */
        let count = random.int(3, 10)
        /* The size of petals (Their point radius) */
        let size = random.int(20, 200)
        /* We copy the center point to save keystrokes. */
        let p = this.point = this.center.copy().update({radius})

        /* Split on a point, returns many points around the radius. */
        this.points = p.split(count)
        this.points.each.radius = size

        let lines = this.lines = []
        let length = this.points.length;

        /* Generate many curves. connecting pairs. */
        for (var i = 0; i < length; i++) {
            let nextValue = i + 1;
            if(nextValue == length) {
                nextValue = 0 // wrap around.
            }
            let line = new BezierCurve(this.points[i], this.points[nextValue])
            lines.push(line)
        }

    }

    draw(ctx){
        this.clear(ctx)
        this.points.pen.indicator(ctx, {color: '#336600'})

        let lineStroke = this.lineStroke
        lineStroke.set(ctx)

        this.lines.forEach((l)=>{
            l.render(ctx);
        });

        lineStroke.unset(ctx)

    }
}

;stage = MainStage.go();

================================================================================
END: flower.js
================================================================================



================================================================================
FILE: follow-and-constrain-point.js
================================================================================

/*
title: Point Follow And Constrain
categories: constraints
files:
    ../point_src/core/head.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    point
    stage
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/constrain-distance-locked.js
    ../point_src/constrain-distance.js
---

Follow the mouse position with `track`, `avoid`, and `leash`

*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.size = 150
        this.orbitPoint = new Point({
             x: 250, y: 150
            , radius: 10
        })

        this.innerPoint = new Point({
            radius: 20
        })

        this.orbitPet = new Point()

        this.outerPoint = new Point({
             x: 400, y: 320
             , radius: 20
        })
    }

    draw(ctx){
        this.clear(ctx)
        ctx.fillStyle = 'green'
        ctx.strokeStyle = 'yellow'

        let mouse = Point.mouse
        let mp = mouse.position

        let size = mouse.clampWheelSize(5, 20)
        let r = size * size
        mp.radius = r

        this.orbitPoint.track(mp, r)
        this.orbitPet.track(this.orbitPoint, 50)
        this.outerPoint.avoid(mp, r + this.outerPoint.radius)
        this.innerPoint.leash(mp, r - this.innerPoint.radius)

        mp.pen.circle(ctx)

        this.orbitPoint.pen.fill(ctx)
        this.innerPoint.pen.circle(ctx)
        this.orbitPet.pen.circle(ctx)
        this.outerPoint.pen.fill(ctx)
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: follow-and-constrain-point.js
================================================================================



================================================================================
FILE: follow-no-gravity.js
================================================================================

/*
title: Raw Point follow (no gravity)
sr_dir: ../point_src/
categories: constraints
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/rel.js
    dragging
---

 */

// var gravity = -0.05; // Gravity constant for helium balloon.
var gravity = {x: 0, y:0.95}; // Gravity constant

var stringLength = 100; // The length of the "string"
var damping = 0.98; // Damping to reduce energy over time

// Variables to store the previous mouse position
let prevMouseX = 0//mouse.x;
let prevMouseY = 0//mouse.y;

const stepBadUpperArc = function(followPoint, mouse) {
    // Calculate the mouse velocity based on the change in position
    mouseVx = mouse.x - prevMouseX;
    mouseVy = mouse.y - prevMouseY;

    // Update the previous mouse position for the next frame
    prevMouseX = mouse.x;
    prevMouseY = mouse.y;

    // Apply gravity to the follow point's vertical velocity
    followPoint.vy += gravity;

    // Update the follow point's position based on its velocity
    followPoint.x += followPoint.vx;
    followPoint.y += followPoint.vy;

    // Calculate the vector from the mouse to the follow point
    let dx = followPoint.x - mouse.x;
    let dy = followPoint.y - mouse.y;

    // Calculate the current distance between the follow point and the mouse
    let distance = Math.sqrt(dx * dx + dy * dy);

    // If the distance exceeds the string length, we need to constrain the follow point
    if (distance > stringLength) {
        // Normalize the direction vector
        dx /= distance;
        dy /= distance;

        // Set the follow point's position to be exactly on the circumference of the string length
        followPoint.x = mouse.x + dx * stringLength;
        followPoint.y = mouse.y + dy * stringLength;

        // Calculate the radial velocity (velocity along the string)
        let radialVelocity = followPoint.vx * dx + followPoint.vy * dy;

        // Calculate the tangential velocity component (perpendicular to the string)
        let tangentVx = followPoint.vx - radialVelocity * dx;
        let tangentVy = followPoint.vy - radialVelocity * dy;

        // Project mouse velocity onto the tangent vector
        let mouseInfluence = ((mouseVx * -dy + mouseVy * dx) / distance) * 20;

        // Modify the tangential velocity based on the direction of the mouse pull
        let mouseTangentInfluence = (mouseVx * -dy + mouseVy * dx) / Math.sqrt(dx * dx + dy * dy);
        if (mouseTangentInfluence > 0) {
            // If pulling in the direction of the tangent, amplify the influence
            tangentVx += mouseInfluence * -dy;
            tangentVy += mouseInfluence * dx;
        }

        // Update the follow point's velocity
        followPoint.vx = tangentVx;
        followPoint.vy = tangentVy;
    }

    // Apply damping continuously to smooth the motion
    followPoint.vx *= damping;
    followPoint.vy *= damping;
};


const noodleStringStep = function(followPoint, mouse) {
    // Calculate the mouse velocity based on the change in position
    mouseVx = mouse.x - prevMouseX;
    mouseVy = mouse.y - prevMouseY;



================================================================================
END: follow-no-gravity.js
================================================================================



================================================================================
FILE: follow-point.js
================================================================================

/*
src_dir: ../point_src/
title: Follow Point
categories: constraints
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    pointlist
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/constrain-distance-locked.js
    stroke
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                 x: 250, y: 150
                , radius: 10
                , vx: 1, vy: 0
                , mass: 2
            })
            , new Point({
                 x: 400, y: 320
                , vx: -1, vy: 0
                , radius: 10
                , mass: 10
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            , new Point({
                 x: 450, y: 580
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
        )
    }

    draw(ctx){
        this.clear(ctx)

        let mouse = Point.mouse.position
        followPoint(mouse, this.points[0], 50)
        followPoint(this.points[0], this.points[1], 50)
        followPoint(this.points[1], this.points[2], 50)
        followPoint(this.points[2], this.points[3], 50)
        followPoint(this.points[3], this.points[4], 50)
        followPoint(this.points[4], this.points[5], 50)
        // this.points.last().rotation += 2
        this.points.pen.indicators(ctx)

    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: follow-point.js
================================================================================



================================================================================
FILE: follow-track-points.js
================================================================================

/*
title: Follow
categories: constraints
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/distances.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/constrain-distance-locked.js
    ../point_src/constrain-distance.js
    ../point_src/setunset.js
    ../point_src/stroke.js
---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                 x: 250, y: 150
                , radius: 10
                , vx: 1, vy: 0
                , mass: 2
            })
            , new Point({
                 x: 400, y: 320
                , vx: -1, vy: 0
                , radius: 10
                , mass: 10
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
        )
    }

    draw(ctx){
        this.clear(ctx)

        let mouse = Point.mouse.position
        // followPoint(mouse, this.points[0], 50)
        // followPoint(this.points[1], this.points[2], 50)
        // followPoint(this.points[2], this.points[3], 50)
        // followPoint(this.points[3], this.points[4], 50)
        // followPoint(this.points[4], this.points[5], 50)

        this.points[0].track(mouse, 100)
        this.points[1].track(this.points[0], 50)
        this.points[2].track(this.points[1], 50)
        this.points[3].track(this.points[2], 50)
        this.points[4].track(this.points[3], 50)
        this.points[5].track(this.points[4], 50)

        // this.points.last().rotation += 2
        this.points.pen.indicators(ctx)

    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: follow-track-points.js
================================================================================



================================================================================
FILE: follow-with-gravity-2.js
================================================================================

/*
src_dir: ../point_src/
title: Follow With Gravity 2
categories: constraints
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/rel.js
    dragging
    ../point_src/constrain-distance.js

 */

// var gravity = {x: 0, y:-0.05}; // Gravity constant for helium balloon.
var gravity = {x: 0, y:0.95}; // Gravity constant

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        this.mouse.position.vy = this.mouse.position.vx = 0

        this.pins = (new PointList(
                  { x: 200, y: 100, vx: 0, vy: 0}
                , { x: 400, y: 100, vx: 0, vy: 0}
                , { x: 600, y: 100, vx: 0, vy: 0}
                , { x: 800, y: 100, vx: 0, vy: 0}

                , { x: 200, y: 400, vx: 0, vy: 0}
                , { x: 400, y: 400, vx: 0, vy: 0}
                , { x: 600, y: 400, vx: 0, vy: 0}
                , { x: 800, y: 400, vx: 0, vy: 0}
            )).cast()

        this.points = (new PointList(
                 { x: 300, y: 100, vx: 0, vy: 0}
                , { x: 500, y: 100, vx: 0, vy: 0}
                , { x: 700, y: 100, vx: 0, vy: 0}
                , { x: 900, y: 100, vx: 0, vy: 0}

                , { x: 300, y: 500, vx: 0, vy: 0}
                , { x: 500, y: 500, vx: 0, vy: 0}
                , { x: 700, y: 500, vx: 0, vy: 0}
                , { x: 900, y: 500, vx: 0, vy: 0}
            )).cast()

        this.dragging.add(...this.pins)
    }

    draw(ctx) {
        this.clear(ctx);

        let pins = this.pins
        let points = this.points

        let drawSet = function(index, func) {
            func(points[index], pins[index])

            pins[index].pen.circle(ctx, {color:'red'})
            points[index].pen.indicator(ctx)
        }

        let funcs = [
              // (p, pin) => springyString(p, pin)
            (p, pin) => pin.constraint.string(p, {
                            gravity,
                            damping: .98,
                            dotDamping: .2,
                            forceMultiplier: .9
                        })
            , (p, pin) => pin.constraint.string(p, {
                            gravity,
                            damping: .99
                        })
            , (p, pin) => pin.constraint.string(p, {
                            gravity,
                            damping: .98,
                            dotDamping: false,
                            forceMultiplier: .1
                        })
            , (p, pin) => pin.constraint.string(p, {
                            gravity,
                            damping: .99,
                            dotDamping: false
                        })
            , (p, pin) => pin.constraint.string(p, {
                            gravity
                            , dotDamping: 0
                            , damping: .98
                        })


================================================================================
END: follow-with-gravity-2.js
================================================================================



================================================================================
FILE: follow-with-gravity.js
================================================================================

/*
src_dir: ../point_src/
title: Follow With Gravity
categories: constraints
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/rel.js
    dragging

 */

// var gravity = {x: 0, y:-0.05}; // Gravity constant for helium balloon.
var gravity = {x: 0, y:0.95}; // Gravity constant

var stringLength = 200; // The length of the "string"
var damping = 0.98; // Damping to reduce energy over time

// Variables to store the previous mouse position
let prevMouseX = 0//mouse.x;
let prevMouseY = 0//mouse.y;

const stepBadUpperArc = function(followPoint, mouse) {
    // Calculate the mouse velocity based on the change in position
    mouseVx = mouse.x - prevMouseX;
    mouseVy = mouse.y - prevMouseY;

    // Update the previous mouse position for the next frame
    prevMouseX = mouse.x;
    prevMouseY = mouse.y;

    // Apply gravity to the follow point's vertical velocity
    followPoint.vy += gravity;

    // Update the follow point's position based on its velocity
    followPoint.x += followPoint.vx;
    followPoint.y += followPoint.vy;

    // Calculate the vector from the mouse to the follow point
    let dx = followPoint.x - mouse.x;
    let dy = followPoint.y - mouse.y;

    // Calculate the current distance between the follow point and the mouse
    let distance = Math.sqrt(dx * dx + dy * dy);

    // If the distance exceeds the string length, we need to constrain the follow point
    if (distance > stringLength) {
        // Normalize the direction vector
        dx /= distance;
        dy /= distance;

        // Set the follow point's position to be exactly on the circumference of the string length
        followPoint.x = mouse.x + dx * stringLength;
        followPoint.y = mouse.y + dy * stringLength;

        // Calculate the radial velocity (velocity along the string)
        let radialVelocity = followPoint.vx * dx + followPoint.vy * dy;

        // Calculate the tangential velocity component (perpendicular to the string)
        let tangentVx = followPoint.vx - radialVelocity * dx;
        let tangentVy = followPoint.vy - radialVelocity * dy;

        // Project mouse velocity onto the tangent vector
        let mouseInfluence = ((mouseVx * -dy + mouseVy * dx) / distance) * 20;

        // Modify the tangential velocity based on the direction of the mouse pull
        let mouseTangentInfluence = (mouseVx * -dy + mouseVy * dx) / Math.sqrt(dx * dx + dy * dy);
        if (mouseTangentInfluence > 0) {
            // If pulling in the direction of the tangent, amplify the influence
            tangentVx += mouseInfluence * -dy;
            tangentVy += mouseInfluence * dx;
        }

        // Update the follow point's velocity
        followPoint.vx = tangentVx;
        followPoint.vy = tangentVy;
    }

    // Apply damping continuously to smooth the motion
    followPoint.vx *= damping;
    followPoint.vy *= damping;
};


const noodleStringStep = function(followPoint, mouse) {
    // Calculate the mouse velocity based on the change in position
    mouseVx = mouse.x - prevMouseX;
    mouseVy = mouse.y - prevMouseY;

    // Update the previous mouse position for the next frame


================================================================================
END: follow-with-gravity.js
================================================================================



================================================================================
FILE: four-point-drawarc-loop.js
================================================================================

/*
title: Four Point Drawarc Loop
categories: arcs
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    pointlist
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js

*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        const r = 200
        this.points = new PointList(
            this.center.add(-r, 0)
            , this.center.add(0, r * -.5)
            , this.center.add(r, 0)
            , this.center.add(0, r)
        );
        this.points.each.radius = 20
        this.dragging.add(...this.points)
    }

    drawArcs(ctx) {
        this.arcLine(ctx)
        ctx.stroke();
    }

    arcLine(ctx, loop=false) {

        ctx.beginPath();

        let firstFunc = (e,i,a) => {
            // let last = a.last()
            let n = a[i+1]
            // ctx.arcTo(e.x, e.y, e.x, e.y, e.radius);
            // ctx.moveTo(last.x, last.y);
            ctx.moveTo(e.x, e.y);
            // ctx.arcTo(last.x, last.y, e.x, e.y, e.radius);

            func = loopFunc
        }

        let loopFunc = (e,i,a) => {
            let e2 = a[i+1]
            ctx.arcTo(e.x, e.y, e2.x, e2.y, e.radius);
            if(i+1 == a.length-1) { func = endFunc }
        }

        let endFunc = (e,i,a) => {
            let e2 = a[0]
            let e3 = a[1]
            ctx.arcTo(e.x, e.y, e2.x, e2.y, e.radius);
            ctx.arcTo(e2.x, e2.y, e3.x, e3.y, e2.radius);
            let e4 = a[2]
            // ctx.lineTo(e4.x, e4.y);
            func = loopFunc
        }

        let func = firstFunc;
        let first = this.points[0]

        this.points.forEach((e,i,a)=> func(e,i,a))
    }

    draw(ctx){
        this.clear(ctx)
        this.drawCircles(ctx)
        ctx.strokeStyle = 'green'
        ctx.lineWidth = 3
        this.drawArcs(ctx)
        this.drawIris(ctx)
    }

    drawCircles(ctx) {
        // let fillstyle = this.grad
        let fillstyle = "#333" // this.grad
            , lineWidth = 3
            ;

        this.points.pen.circle(ctx, undefined, fillstyle, lineWidth)
        this.points[0].pen.fill(ctx, fillstyle)
    }

    drawIris(ctx) {
        /* The dynamic highlighter. */
        let p = this.dragging.getPoint();
        if(p) {


================================================================================
END: four-point-drawarc-loop.js
================================================================================



================================================================================
FILE: four-point-drawarc.js
================================================================================

/*
title: Four Point Drawarc
categories: arcs
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    pointlist
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/functions/springs.js
    ../point_src/stage.js

*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        const r = 200
        this.points = new PointList(
            this.center.add(-r, 0)
            , this.center.add(0, r * -.5)
            , this.center.add(r, 0)
            , this.center.add(0, r)
        );

        this.points.each.radius = 20
        this.points.update({
            vx: .2, vy: .1
            , mass: 1
        })
        this.dragging.add(...this.points)
    }

    drawArcs(ctx) {
        this.arcLine(ctx)
        ctx.stroke();
    }

    arcLine(ctx, loop=false) {

        ctx.beginPath();

        let firstFunc = (e,i,a) => {
            ctx.moveTo(e.x, e.y);
            func = loopFunc
        }

        let loopFunc = (e,i,a) => {
            let e2 = a[i+1]
            ctx.arcTo(e.x, e.y, e2.x, e2.y, e.radius);
            if(i+1 == a.length-1) { func = endFunc }
        }

        let endFunc = (e,i,a) => {
            ctx.lineTo(e.x, e.y);
            func = loopFunc
        }

        let func = firstFunc;
        let first = this.points[0]

        this.points.forEach((e,i,a)=> func(e,i,a))
    }

    draw(ctx){
        this.clear(ctx)
        this.drawCircles(ctx)
        ctx.strokeStyle = 'green'
        ctx.lineWidth = 3

        this.drawArcs(ctx)
        this.drawIris(ctx)
    }

    drawCircles(ctx) {
        // let fillstyle = this.grad
        let fillstyle = "#333" // this.grad
            , lineWidth = 3
            ;

        this.points.pen.circle(ctx, undefined, fillstyle, lineWidth)
        this.points.spring.chain(150, 2, .3, new Set([this.points[0], this.points.last()]), .1)
        this.points[0].pen.fill(ctx, fillstyle)
    }

    drawIris(ctx) {
        /* The dynamic highlighter. */
        let p = this.dragging.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }
    }


================================================================================
END: four-point-drawarc.js
================================================================================



================================================================================
FILE: fps-example.js
================================================================================

/*
title: FPS Example
categories: fps
    text
files:
    head
    pointlist
    point
    stage
    mouse
    dragging
    fps
---

Render the "frames per second" as text. The FPS will match your screen refresh rate.
Commonly this is 60Hz.

Apply to the draw call.


    draw(ctx) {
        stage.fps.drawFPS(ctx)
    }

this provides a more stable method to rendering the live frames, by taking an
average over the previous few iterations.
*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 , radius: 20, rotation: 45})
        this.dragging.add(this.point)
    }

    draw(ctx){
        this.clear(ctx)
        // this.point.pen.indicator(ctx)
        this.fps.drawFPS(ctx)
        // console.log('draw')

    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: fps-example.js
================================================================================



================================================================================
FILE: gearbox-internal-wheel.js
================================================================================

/*
title: Gears (Internal Wheel)
src_dir: ../point_src/
categories: gears
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    dragging
    pointlist
    mouse
    stroke
    ../point_src/split.js
    ../point_src/stage-clock.js
    ../point_src/touching.js
    ../point_src/coupling.js
    ../point_src/gearbox.js
    xybind
---

A simple example of gear-like rotations
*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.rawPointConf = { circle: { color: 'orange', width: 1}}
        let r = this.generate()
        this.dragging.add(...r)
        this.dragging.onEmptyDown = this.onEmptyDown.bind(this)
    }

    generate(pointCount=2){
        let gb = this.gearBox = new GearBox()

        let ps = new PointList(
            new Point({x:350, y:200, radius: 200}),
            new Point({x:100, y:200, radius: 150, internal: true}),

            new Point({x:600, y:400, radius: 100}),
            new Point({x:100, y:200, radius: 50, motor: 1})

        )

        ps.each.angularVelocity = 0

        gb.points = ps

        gb.bindPinionWheels(ps[0], ps[1])

        return ps
    }


    onEmptyDown(ev) {
        // console.log('onEmptyDown')
        const p = Point.from(ev).update({
                    radius: 60
                    , angularVelocity: 1
                })
        this.gearBox.addGear(p)
        this.dragging.add(p)
    }

    draw(ctx){
        this.clear(ctx)

        this.gearBox.performDraw(ctx)
        let p = this.dragging.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }
    }

}

stage = MainStage.go()

================================================================================
END: gearbox-internal-wheel.js
================================================================================



================================================================================
FILE: gearbox-planetary.js
================================================================================

/*
title: Planetary Gears
src_dir: ../point_src/
categories: gears
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    dragging
    pointlist
    mouse
    stroke
    ../point_src/split.js
    ../point_src/stage-clock.js
    ../point_src/touching.js
    ../point_src/coupling.js
    ../point_src/xybind.js
    ../point_src/gearbox.js
    ../point_src/gearbox-planets.js
---

Planetary gear system with sun, planet, and ring gears.
The planet gears orbit around the sun while rotating on their own axes.
*/


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.rawPointConf = { circle: { color: 'orange', width: 1}}
        this.generate()
        this.setupControls()
        
        // Add all gears to dragging (optional - can make planets draggable)
        // Note: dragging planets will fight with their orbital motion
        this.dragging.add(this.planetary.sun, this.planetary.ring)
    }

    generate(){
        let gb = this.gearBox = new GearBox()
        
        // Create a planetary gear system
        // Motor speed in degrees per frame (not radians!)
        this.planetary = gb.createPlanetarySystem({
            sunXY: { x: 300, y: 300 },
            sunRadius: 60,
            planetRadius: 25,
            // ringRadius will be auto-calculated to properly touch planets
            planetCount: 3,
            sunMotor: 1  // degrees per frame
        })
        
        // Create a second planetary system for comparison
        this.planetary2 = gb.createPlanetarySystem({
            sunXY: { x: 650, y: 300 },
            sunRadius: 40,
            planetRadius: 20,
            // ringRadius will be auto-calculated
            planetCount: 4,
            sunMotor: -1.5  // opposite direction, degrees per frame
        })
        
        console.log('Planetary systems created')
        console.log('System 1 - Sun:', this.planetary.sun, 'Planets:', this.planetary.planets)
        console.log('System 2 - Sun:', this.planetary2.sun, 'Planets:', this.planetary2.planets)
        
        return gb.points
    }

    setupControls() {
        // Keyboard controls
        this.keys = {}
        window.addEventListener('keydown', (e) => {
            this.keys[e.key] = true
            this.handleKeyPress(e.key)
        })
        window.addEventListener('keyup', (e) => {
            this.keys[e.key] = false
        })
    }

    handleKeyPress(key) {
        switch(key) {
            case ' ': // spacebar - toggle sun motor
                let current = this.planetary.sun.motor
                this.planetary.setSunMotor(current === 0 ? 1 : 0)
                break
            case 'ArrowUp': // speed up
                this.planetary.sun.motor += 0.5
                break
            case 'ArrowDown': // speed down
                this.planetary.sun.motor -= 0.5
                break
            case 'r': // reverse


================================================================================
END: gearbox-planetary.js
================================================================================



================================================================================
FILE: gearbox-recursive-clean.js
================================================================================

/*
title: Gears (Nearly)
src_dir: ../point_src/
categories: gears
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    dragging
    pointlist
    mouse
    stroke
    ../point_src/split.js
    ../point_src/stage-clock.js
    ../point_src/touching.js
    ../point_src/coupling.js
    ../point_src/xybind.js
    ../point_src/gearbox.js
---

A simple example of gear-like rotations
*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.rawPointConf = { circle: { color: 'orange', width: 1}}
        let r = this.generate()
        this.dragging.add(...r)
        this.dragging.onEmptyDown = this.onEmptyDown.bind(this)
    }

    generate(pointCount=2){
        let gb = this.gearBox = new GearBox()

        let ps = new PointList(
            new Point({x:350, y:200, radius: 150}),
            new Point({x:700, y:200, radius: 75}),

            new Point({x:600, y:400, radius: 100}),
            new Point({x:600, y:100, radius: 20}),

            new Point({x:659, y:500, radius: 120}),
            new Point({x:150, y:450, radius: 20}),

            new Point({x:180, y:150, radius: 140}),
            new Point({x:180, y:150, radius: 15}),

            new Point({x:100, y:200, radius: 70, motor: 1}),
            new Point({x:800, y:300, radius: 70, motor: -.5})
        )

        ps.each.angularVelocity = 0

        gb.points = ps
        gb.bindPinionWheels(ps[0], ps[1])
        gb.bindPinionWheels(ps[2], ps[3])
        gb.bindPinionWheels(ps[4], ps[5])
        gb.bindPinionWheels(ps[6], ps[7])

        return ps
    }


    onEmptyDown(ev) {
        // console.log('onEmptyDown')
        const p = Point.from(ev).update({
                    radius: 60
                    , angularVelocity: 1
                })
        this.gearBox.addGear(p)
        this.dragging.add(p)
    }

    draw(ctx){
        this.clear(ctx)

        this.gearBox.performDraw(ctx)
        let p = this.dragging.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }
    }

}

stage = MainStage.go()

================================================================================
END: gearbox-recursive-clean.js
================================================================================



================================================================================
FILE: gearbox.js
================================================================================

/*
title: Gears (Internal Wheel)
src_dir: ../point_src/
categories: gears
files:
    head
    point
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    stage
    dragging
    pointlist
    mouse
    stroke
    ../point_src/split.js
    ../point_src/stage-clock.js
    ../point_src/touching.js
    ../point_src/coupling.js
    ../point_src/xybind.js
    ../point_src/gearbox.js
    ../point_src/json.js
---

A simple example of gear-like rotations
*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.rawPointConf = { circle: { color: 'orange', width: 1}}
        let r = this.generate()

        let p = new Point(400, 400, 140)
        p.rachet = -1
        let pin = p.copy().update({
            radius: p.radius * .5
            , ratchet: -1
        })
        // let pin2 = p.copy().update({ radius: p.radius * .3 })
        this.p1 = p
        this.pin1 = pin
        this.gearBox.addGear(p)
        this.gearBox.addGear(pin)
        // this.gearBox.addGear(pin2)
        this.gearBox.bindPinionWheels(p, pin)
        this.dragging.add(p, pin)

        this.dragging.add(...r)
        this.dragging.onEmptyDown = this.onEmptyDown.bind(this)
    }

    generate(pointCount=2){
        let gb = this.gearBox = new GearBox()
        gb.createMotor({x:100, y:300, radius: 30})
        gb.createGear({x:100, y:200, radius: 100})
        gb.createReductionGear({x:200, y:200, radius: 100})
        gb.createReductionGear({x:300, y:200, radius: 100})
        gb.createReductionGear({x:400, y:200, radius: 100})
        gb.createInternalGear({x:400, y:300, radius: 60})
        gb.createInternalGear({x:400, y:300, radius: 60})
        return gb.points
    }


    onEmptyDown(ev) {
        // console.log('onEmptyDown')
        const p = Point.from(ev).update({
                    radius: 60
                    , angularVelocity: 1
                })
        this.gearBox.addGear(p)
        this.dragging.add(p)
    }

    draw(ctx){
        this.clear(ctx)

        this.gearBox.performDraw(ctx)
        ctx.fillStyle = 'white'


        this.gearBox.points.forEach((p)=>{
            let radtodeg = (p.angularVelocity / 360
                        * 60 /*fps */
                        // * 60 /* seconds */
                        )
            p.text.string(ctx, radtodeg.toFixed(2))
        })

        let p = this.dragging.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }

    }



================================================================================
END: gearbox.js
================================================================================



================================================================================
FILE: gears-recursive-raw.js
================================================================================

/*
title: Gears (Nearly)
categories: gears
src_dir: ../point_src/
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    dragging
    pointlist
    mouse
    stroke
    ../point_src/split.js
    ../point_src/stage-clock.js
    ../point_src/touching.js
    ../point_src/coupling.js


---

A simple example of gear-like rotations
*/


function gearWheel(originPoint, receiverPoint) {
    /*
     A Gear defines a point edge meeting another point edge.
     Calculate and apply the angularVelocity using the origin and receiver radius.

     Note the originPoint.angularVelocity must exist.
    */
  // originPoint and receiverPoint each have:
  //   radius: number
  //   angularVelocity: number (radians per second or degrees per second)

  // Angular velocity of B given A:
  receiverPoint.angularVelocity = -(originPoint.radius / receiverPoint.radius) * originPoint.angularVelocity;
  // circleB.rotation += circleB.angularVelocity
}

function wheelWheel(parentPoint, boundPoint) {
    /*
    The parentPoint was rotated by the origin, the bound point should receive its rotation
    being an inner wheel of the parentPoint
     */
    //
    boundPoint.angularVelocity = parentPoint.angularVelocity;
}


const doubleTouchCV = function(originPoint, touchPoint) {
    // Angular velocity it given by a previous, and now this.
    // B should be the max of itself or the given.

    // console.warn('double touch', hitTick)
    // Average.
    if(originPoint.angularVelocity == touchPoint.angularVelocity) {
        // Same - no change required.
        touchPoint.doubleHit = false
        return
    }

    touchPoint.doubleHit = true
    // let newA = circleA.angularVelocity
    // if(circleA.angularVelocity < 0){
    //     newA = Math.min(circleB.angularVelocity, circleA.angularVelocity)
    // }

    // if(circleA.angularVelocity > 0){
    //     newA = Math.max(circleB.angularVelocity, circleA.angularVelocity)
    // }

    // circleB.angularVelocity = newA
    // circleB.rotation += circleB.angularVelocity
}


const isMotor = function(point) {
    let mv = point.motor
    if(mv === undefined || mv === false) {
        return false
    }

    return true
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){

        /* For xy bound wheels */
        this.bindMap = new Map()


================================================================================
END: gears-recursive-raw.js
================================================================================



================================================================================
FILE: gears-simple.js
================================================================================

/*
title: Gears (Nearly)
categories: gears
src_dir: ../point_src/
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    dragging
    pointlist
    mouse
    stroke
    ../point_src/split.js
    ../point_src/stage-clock.js
    ../point_src/touching.js

---

A simple example of gear-like rotations
*/


function cv(circleA, circleB) {
  // circleA and circleB each have:
  //   radius: number
  //   angularVelocity: number (radians per second or degrees per second)

  // Angular velocity of B given A:
  circleB.angularVelocity = -(circleA.radius / circleB.radius) * circleA.angularVelocity;
  circleB.rotation += circleB.angularVelocity
}


const isMotor = function(point) {
    let mv = point.motor
    if(mv === undefined || mv === false) {
        return false
    }

    return true
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.rawPointConf = { circle: { color: 'orange', width: 1}}
        this.generate()
        this.dragging.add(...this.randomPoints)
    }

    generate(pointCount=2){
        this.randomPoints = new PointList(
           new Point({x:300, y:200, radius: 70, motor: true, angularVelocity: 1}),
           new Point({x:500, y:200, radius: 150, angularVelocity: 0}),
           new Point({x:700, y:200, radius: 70, angularVelocity: 0}),
           new Point({x:800, y:300, radius: 70, angularVelocity: 0}),
        )
    }

    draw(ctx){
        this.clear(ctx)
        this.drawView(ctx)

        let ps = this.randomPoints

        ps.forEach(p=> {
            if(isMotor(p)) {
                p.rotation += p.motor
            }
        })

        let prev = ps[0]

        for (let i = 1; i < ps.length; i++) {
            let p = ps[i]
            let distance = prev.distanceTo(p) - p.radius
            if(distance < prev.radius) {
                let ip = prev.copy().update({radius:distance})
                ip.pen.circle(ctx, {color:'#444'})
            }

            if(pointToPointContact(prev, p)) {
                let chained = cv(prev, p)
                prev = p
            }
        }

        let p = this.dragging.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }
    }


================================================================================
END: gears-simple.js
================================================================================



================================================================================
FILE: general-event-position.js
================================================================================

/*
category: events
title: General Event Position
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js

Events are captured on the stage. In this example we spawn a point from the
click event:

    onClick(ev) {
        clickPoint = Point.from(ev)
    }

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point(300, 300, 20)
        this.events.wake()
    }

    onClick(ev) {
        this.clickPoint = Point.from(ev)
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.circle(ctx, {color:'#eee'})
        this.clickPoint && this.clickPoint.pen.fill(ctx, '#880000')
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: general-event-position.js
================================================================================



================================================================================
FILE: gradient-class-radial-two-point.js
================================================================================

/*
title: Radial Gradient (2 Points)
category: gradient
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/functions/within.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/automouse.js
    ../point_src/gradient.js
 */

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let c = this.center

        c.radius = 200

        this.point = c.copy()

        this.innerPoint = c.copy().update({color:"hsl(299deg 62% 44%)"})
        this.outerPoint = c.copy().update({color: "hsl(244deg 71% 56%)"}) // dark
        this.innerPoint.radius = 70

        this.g = (new Gradient).radial(this.innerPoint, this.outerPoint)
        // this.g = (new Gradient).radial(this.innerPoint, this.outerPoint)
        this.dragging.add(
                this.innerPoint,
                this.outerPoint,
                this.point)

        this.g.addStops({
            0: this.innerPoint,
            1: this.outerPoint
        })
    }

    draw(ctx){
        this.clear(ctx)
        // this.g.radial() // refresh hack.
        let grad = this.g.getObject(ctx)

        this.point.pen.fill(ctx, grad)
        // this.point.pen.circle(ctx, undefined, '#000', 3)

        // this.point0.pen.line(ctx, this.point1, '#111111', 2)
        this.innerPoint.pen.fill(ctx, 'white', 2)
        this.innerPoint.pen.circle(ctx, undefined, 'white', 1)
        this.outerPoint.pen.circle(ctx, undefined, '#DDD', 1)
    }

}

;stage = MainStage.go();

================================================================================
END: gradient-class-radial-two-point.js
================================================================================



================================================================================
FILE: gradient-conic.js
================================================================================

/*
title: Radial Gradient (1 Point)
category: gradient
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/functions/within.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/automouse.js
    ../point_src/gradient.js
---

In this example we create a radial gradient with _one_ point, allowing a simple
colour gradient from the x/y of the origin.

Notice the x/y of the stop points is not relevant - only the color.
 */

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let c = this.center

        c.radius = 200

        this.point = c.copy()

        this.innerPoint = c.copy().update({radius: 40, rotation: 30})
        this.g = (new Gradient).conic(this.innerPoint)

        this.dragging.add(
                this.innerPoint,
                this.point)

        this.g.addStops({
            0: {color:"hsl(299deg 62% 44%)"},
            1: {color: "hsl(244deg 71% 56%)"} // dark
        })
    }

    draw(ctx){
        this.clear(ctx)
        this.g.conic() // refresh hack.
        this.innerPoint.rotation -= .5
        let grad = this.g.getObject(ctx)

        this.point.pen.fill(ctx, grad)

        this.innerPoint.pen.fill(ctx, 'white', 2)
        this.innerPoint.pen.circle(ctx, undefined, 'white', 1)
        // this.outerPoint.pen.circle(ctx, undefined, '#DDD', 1)
    }

}

;stage = MainStage.go();



================================================================================
END: gradient-conic.js
================================================================================



================================================================================
FILE: gradient-drag-example.js
================================================================================

/*
title: Draggable Gradient
category: gradient
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
---

In this example the gradient is generated using the standard `ctx.createLinearGradient`
*/
class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        // this.point = new Point(50, 50)
        const r = 200
        const shareSize = 15
        this.center.radius = r
        this.point0 = this.center.add(-r, 0)
        this.point1 = this.center.add(r, 0)
        this.point0.radius = this.point1.radius = shareSize
        this.point0.color = "hsl(299deg 62% 44%)"
        this.point1.color = "hsl(244deg 71% 56%)"
        this.near = this.center.copy()
        this.regenerateGradient()

        // this.dis = new Distances
        // this.dis.addPoints(this.center, this.point0, this.point1)
        this.dis = new Dragging
        this.dis.initDragging(this)
        this.dis.onDragMove = this.onDragMove.bind(this)
        this.dis.onDragEnd = this.onDragEnd.bind(this)
        this.dis.addPoints(this.center, this.point0, this.point1)

    }

    regenerateGradient() {
        this.grad = this.generateGrad(this.ctx, this.point0, this.point1)
    }

    draw(ctx){
        this.clear(ctx)
        this.center.pen.fill(ctx, this.grad)
        // this.center.pen.indicator(ctx, {color: '#fff', width: 1})
        this.point0.pen.line(ctx, this.point1, '#111111', 2)
        // this.point0.pen.line(ctx, this.point1, '#ffffff22', 2)
        this.point0.pen.fill(ctx)
        this.point1.pen.fill(ctx)
        this.point0.pen.circle(ctx, undefined, '#111', 4)
        this.point1.pen.circle(ctx, undefined, '#111', 4)

        let p = this.dis.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }

    }

    onDragMove(ev) {
        this.dis.applyXY(ev.x, ev.y)
        if(this.live) {
            this.regenerateGradient()
        }
    }

    onDragEnd(ev) {
        this.regenerateGradient()
    }

    generateGrad(ctx, a, b) {
        let gradient = ctx.createLinearGradient(a.x, a.y, b.x, b.y)
        // gradient.addColorStop(0,"#000000");
        gradient.addColorStop(0, a.color);
        // gradient.addColorStop(1,"red");
        gradient.addColorStop(1, b.color);
        return gradient
    }
}

;MainStage.go();

================================================================================
END: gradient-drag-example.js
================================================================================



================================================================================
FILE: gradient-example.js
================================================================================

/*
title: Gradient
category: gradient
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
*/
class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        // this.point = new Point(50, 50)


        const r = 200
        const shareSize = 15
        this.center.radius = r
        this.point0 = this.center.add(-r, 0)
        this.point1 = this.center.add(r, 0)
        this.point0.radius = this.point1.radius = shareSize
        this.point0.color = "hsl(299deg 62% 44%)"
        this.point1.color = "hsl(244deg 71% 56%)"

        this.grad = this.generateGrad(this.ctx, this.point0, this.point1)
    }

    draw(ctx){
        this.clear(ctx)
        this.center.pen.fill(ctx, this.grad)
        // this.center.pen.indicator(ctx, {color: '#fff', width: 1})
        this.point0.pen.line(ctx, this.point1, '#111111', 2)
        // this.point0.pen.line(ctx, this.point1, '#ffffff22', 2)
        this.point0.pen.fill(ctx)
        this.point1.pen.fill(ctx)
        this.point0.pen.circle(ctx, undefined, '#111', 4)
        this.point1.pen.circle(ctx, undefined, '#111', 4)
    }

    generateGrad(ctx, a, b) {
        let gradient = ctx.createLinearGradient(a.x, a.y, b.x, b.y)
        // gradient.addColorStop(0,"#000000");
        gradient.addColorStop(0, a.color);
        // gradient.addColorStop(1,"red");
        gradient.addColorStop(1, b.color);
        return gradient
    }
}

;MainStage.go();

================================================================================
END: gradient-example.js
================================================================================



================================================================================
FILE: gradient-linear-one-point.js
================================================================================

/*
title: Radial Gradient (2 Points)
category: gradient
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/functions/within.js
    ../point_src/functions/rel.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/automouse.js
    ../point_src/gradient.js
    ../point_src/split.js
 */

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let c = this.center

        c.radius = 150

        this.point = c.copy()

        this.innerPoint = c.copy().update({
                radius:c.radius + 40
                , color:"hsl(299deg 62% 44%)"
            })

        this.g = (new Gradient).linear(this.innerPoint)

        this.dragging.add(
                this.innerPoint,
                this.point)

        this.g.addStops({
            0: "hsl(299deg 62% 44%)",
            1: "hsl(244deg 71% 56%)"
        })
    }

    draw(ctx){
        this.clear(ctx)
        this.g.linear() // refresh hack.
        let grad = this.g.getObject(ctx)

        this.innerPoint.rotation += .5

        this.point.pen.fill(ctx, grad)
        this.innerPoint.pen.indicator(ctx, {color: 'white'})
        this.innerPoint.pen.circle(ctx, undefined, 'white', 1)
    }

}

;stage = MainStage.go();

================================================================================
END: gradient-linear-one-point.js
================================================================================



================================================================================
FILE: gradient-linear-two-point.js
================================================================================

/*
title: Radial Gradient (2 Points)
category: gradient
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/functions/within.js
    ../point_src/functions/rel.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/automouse.js
    ../point_src/gradient.js
 */

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let c = this.center

        c.radius = 200

        this.point = c.copy()

        this.innerPoint = c.copy().update({radius: 20, color:"hsl(299deg 62% 44%)"})
        this.outerPoint = c.copy().update({radius: 20, color: "hsl(244deg 71% 56%)"}) // dark
        this.innerPoint.update({x:rel(-250), y:rel(-200)})
        this.outerPoint.update({x:rel(200), y:rel(250)})

        this.g = (new Gradient).linear(this.innerPoint, this.outerPoint)

        this.dragging.add(
                this.innerPoint,
                this.outerPoint,
                this.point)

        this.g.addStops({
            0: this.innerPoint,
            1: this.outerPoint
        })
    }

    draw(ctx){
        this.clear(ctx)
        this.g.linear() // refresh hack.
        let grad = this.g.getObject(ctx)

        this.point.pen.fill(ctx, grad)
        // this.point.pen.circle(ctx, undefined, '#000', 3)

        // this.point0.pen.line(ctx, this.point1, '#111111', 2)
        this.innerPoint.pen.fill(ctx, 'white', 2)
        this.innerPoint.pen.circle(ctx, undefined, 'white', 1)
        this.outerPoint.pen.circle(ctx, undefined, '#DDD', 1)
    }

}

;stage = MainStage.go();

================================================================================
END: gradient-linear-two-point.js
================================================================================



================================================================================
FILE: gradient-psuedo-blur.js
================================================================================

/*
title: Psuedo Blur
category: gradient
tags: blur
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/functions/rel.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/gradient.js

Here we attempt a psuedo _blur_ by generating a gradient layer matching
the primary point.

Inspired by this beautiful unsplash https://unsplash.com/@randomrenders

 */
class MainStage extends Stage {
    canvas='playspace'
    mounted(){

        let a = this.a = this.center.copy().update({
                radius: 150
                , x: rel(350)
                , y: rel(100)
            });

        this.b = this.center.copy().update({
                radius: 300
                , x: rel(-200)
                , y: rel(-200)
            })
        this.mountGrad()
    }

    mountGrad(){
        let c = this.center
        this.primaryPoint = c.copy().update({
                radius: 350
                , x: rel(20)
                , y: rel(200)
            })

        let darkPurple = '#7301bd'
        let polyPink = 'hsl(299deg 62% 44%)'
        let brightPink = '#ae28fd'
        let blurPink = '#9e2ce6'
        let grey = "#272729"
        let darkGrey = '#171719'
        let peak = "#c62cfd"

        this.gradInner = this.primaryPoint.copy().update({radius: rel(-190), color:blurPink})
        this.gradOuter = this.primaryPoint.copy().update({
                radius: rel(90)
                , y: rel(-90)
                , color: grey
            })
        this.gradOutest = this.primaryPoint.copy().update({ radius: rel(90), color: darkGrey})

        this.pointGradInner = this.primaryPoint.copy().update({ radius: rel(-250), color:blurPink})
        this.pointGradOuter = this.primaryPoint.copy().update({ radius: rel(-10), color: darkPurple}) // dark
        // this.gradOuter = c.copy().update({color: "hsl(244deg 71% 56%)"}) // dark
        // this.g = (new Gradient).radial(this.gradInner, this.gradOuter)
        this.dragging.add(
                // this.gradInner,
                // this.gradOuter,
                // this.gradOutest,
                // this.pointGradInner,
                // this.pointGradOuter,
                this.a,
                this.b,
                this.primaryPoint
            )

        this.blurGrad = (new Gradient).radial(this.gradInner, this.gradOuter)
        this.blurGrad.addStops({
            0: peak,
            0.1: this.gradInner,
            ".6": this.gradOuter,
            1: this.gradOutest
        })

        this.pointGrad = (new Gradient).radial(this.pointGradInner, this.pointGradOuter)
        this.pointGrad.addStops({
            0: this.pointGradInner,
            1: this.pointGradOuter
        })


================================================================================
END: gradient-psuedo-blur.js
================================================================================



================================================================================
FILE: gradient-radial-one-point.js
================================================================================

/*
title: Radial Gradient (1 Point)
category: gradient
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/functions/within.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/automouse.js
    ../point_src/gradient.js

---

In this example we create a radial gradient with _one_ point, allowing a simple
colour gradient from the x/y of the origin.

Notice the x/y of the stop points is not relevant - only the color.
 */

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let c = this.center

        c.radius = 200

        this.point = c.copy()

        this.innerPoint = c.copy()
        this.outerPoint = c.copy().update({radius: 70})

        // this.g = (new Gradient).radial(this.innerPoint, this.outerPoint)
        this.g = (new Gradient).radial(this.outerPoint)
        //
        this.dragging.add(
                this.innerPoint,
                this.outerPoint,
                this.point)

        this.g.addStops({
            0: {color:"hsl(299deg 62% 44%)"},
            1: {color: "hsl(244deg 71% 56%)"} // dark
        })
    }

    draw(ctx){
        this.clear(ctx)
        this.g.radial() // refresh hack.
        let grad = this.g.getObject(ctx)

        this.point.pen.fill(ctx, grad)

        this.innerPoint.pen.fill(ctx, 'white', 2)
        this.innerPoint.pen.circle(ctx, undefined, 'white', 1)
        this.outerPoint.pen.circle(ctx, undefined, '#DDD', 1)
    }

}

;stage = MainStage.go();

================================================================================
END: gradient-radial-one-point.js
================================================================================



================================================================================
FILE: gradient-random-example.js
================================================================================

/*
title: Random Gradient
category: gradient
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/random.js
    ../point_src/point.js
    ../point_src/stage.js


*/
class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        // this.point = new Point(50, 50)
        this.gen()

        addButton('generate', {
            label: "Generate"
            , onclick: (ev, proxySelf) =>{

                this.gen()
            }

        })
    }

    gen(){
        const r = 200
        const shareSize = 15
        this.center.radius = r
        let r2 = r + random.int(r) +  random.int(-r)

        this.point0 = this.center.add(-r2, random.int(-r) + random.int(r))
        this.point1 = this.center.add(r2, random.int(-r) + random.int(r))
        this.point0.radius = this.point1.radius = shareSize

        let rf = ()=> 1 + random.int(100) - 1
        let df = ()=> 1 + random.int(360) - 1

        this.point0.color = `hsl(${df()}deg ${rf()}% ${rf()}%)`
        this.point1.color = `hsl(${df()}deg ${rf()}% ${rf()}%)`

        this.grad = this.generateGrad(this.ctx, this.point0, this.point1)
    }

    draw(ctx){
        this.clear(ctx)
        this.center.pen.fill(ctx, this.grad)
        // this.center.pen.indicator(ctx, {color: '#fff', width: 1})
        this.point0.pen.line(ctx, this.point1, '#111111', 2)
        // this.point0.pen.line(ctx, this.point1, '#ffffff22', 2)
        this.point0.pen.fill(ctx)
        this.point1.pen.fill(ctx)
        this.point0.pen.circle(ctx, undefined, '#111', 4)
        this.point1.pen.circle(ctx, undefined, '#111', 4)
    }

    generateGrad(ctx, a, b) {
        let gradient = ctx.createLinearGradient(a.x, a.y, b.x, b.y)
        // gradient.addColorStop(0,"#000000");
        gradient.addColorStop(0, a.color);
        // gradient.addColorStop(1,"red");
        gradient.addColorStop(1, b.color);
        return gradient
    }
};

const stage = MainStage.go();

================================================================================
END: gradient-random-example.js
================================================================================



================================================================================
FILE: graph-chain-follow-raw-2.js
================================================================================

/*
title: Graph Chain Follow Points 2
categories:
    raw
    graph
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    stroke

---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point(250, 150, 10)
            , new Point(400, 320, 10)
            , new Point(300, 520, 8)

            , new Point(340, 580, 8)
            , new Point(380, 520, 8)

            , new Point(410, 520, 8)
            , new Point(450, 520, 8)

            , new Point(430, 520, 8)
            , new Point(400, 520, 8)
        )

        this.collisionBox = new CollisionBox(this.points)
        this.g = new G;

        this.head = 0

        this.g.connect(0, 1, 2, 3, 4)
        this.g.connect(2, 5)
        this.g.connect(5, 6, 7, 8)

        this.dragging.add(...this.points)
    }

    onMousedown(ev, p) {
        // console.log(this.dragging._near)
        this.head = this.points.indexOf(this.dragging._near)
    }

    draw(ctx){
        this.clear(ctx)
        this.collisionBox.shuffle()

        // let mouse = Point.mouse.position
        // followPoint(mouse, this.points[0], 50)

        this.graphChain2()
        this.points.pen.indicators(ctx)

        // head
        this.points[0].pen.fill(ctx, '#992211')
        // tri joint
        this.points[2].pen.fill(ctx, '#00cc33')
    }

    graphChain2() {
        let head = this.head
        let ps = this.points

        let pairCallback = (key, fromKey, allTargets)=>{
            // console.log('from=', fromKey, 'key=', key, )
            // constraints.within(ps[fromKey], ps[key], 50)
            constraints.distance(ps[fromKey], ps[key], 50)
        }

        this.g.walkForward(head, pairCallback)
    }

}


class G {
    constructor(){
        this.forward = {}
        this.reverse = {}
        /* neighbours by connections.


================================================================================
END: graph-chain-follow-raw-2.js
================================================================================



================================================================================
FILE: graph-chain-follow-raw.js
================================================================================

/*
title: Graph Chain Follow Points
categories:
    raw
    graph
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    stroke

---

> [!NOTE]
> V3 is better.

The `followPoint` method allows a point to _follow_ another point, at a distance.
This is a lot like constraints but with a _one to one_ relationship in a single
direction.

This _graph chain_ stores those one to one relationships, with methods to iterate
the chain in two directions. This allows use to grab the standard `A -> B -> C`,
and `C -> B -> A`.

The graph can resolve a "star based" configuration:

    A      C
      \   /
        B
        |
        D
        |
        E

Each connection is given in a pair, from an origin node (the `head`)

    head = B

    B -> C
    B -> D [ -> E ]
    D -> E
    B -> A


 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point(250, 150, 10)
            , new Point(400, 320, 10)
            , new Point(300, 520, 8)

            , new Point(340, 580, 8)
            , new Point(380, 520, 8)

            , new Point(410, 520, 8)
            , new Point(450, 520, 8)

            , new Point(430, 520, 8)
            , new Point(400, 520, 8)
        )

        this.reverse = true
        this.collisionBox = new CollisionBox(this.points)

        this.g = new G;
        // let forwardGraph = {
        //       0: [1]
        //     , 1: [2]
        //     , 2: [3, 5]
        //     , 3: [4]
        //     , 5: [6]
        // }
        const pid = (v) => this.points[v].uuid
        this.g.head = this.points[0]

        console.log(0, pid(0))

        let con = (a,b) => this.g.add(pid(a), pid(b))

        con(0, 1)
        con(1, 2)

        con(2, 3)
        con(2, 5)



================================================================================
END: graph-chain-follow-raw.js
================================================================================



================================================================================
FILE: graph-directional.js
================================================================================

/*
title: Directional Graph
categories:
    graph
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    point
    stage
    mouse
    ../point_src/graph-connections.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    ../point_src/functions/springs.js
    ../point_src/velocity.js
    stroke
---

A directional graph connects nodes in one direction (`a=>b`).
Clicking on a single node highlights the children.

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        let ps = this.points = new PointList(
            {x:250, y:150, radius:10 }
            , {x:400, y:320, radius:10 }
            , {x:300, y:520, radius:8 }

            , {x:340, y:580, radius:8 }
            , {x:380, y:520, radius:8 }

            , {x:410, y:520, radius:8 }
            , {x:450, y:520, radius:8 }

            , {x:430, y:520, radius:8 }
            , {x:400, y:520, radius:8 }
        ).cast()

        this.collisionBox = new CollisionBox(this.points)
        // this.g = new GraphConnections;
        this.g = new DirectionalGraphConnections;

        this.head = 5

        this.g.connect(0, 1, 2, 3, 4)
        this.g.connect(2, 5)
        this.g.connect(5, 6, 7, 8)

        this.dragging.add(...this.points)
    }

    onMousedown(ev, p) {
        // console.log(this.dragging._near)
        this.head = this.points.indexOf(this.dragging._near)
    }

    draw(ctx){
        this.clear(ctx)
        this.collisionBox.shuffle()

        let ps = this.points

        this.graphChain(ctx, this.head, ps)
        this.points.pen.indicators(ctx)

        // head
        this.points[this.head]?.pen.fill(ctx, '#44cc33')
        this.points[0].pen.fill(ctx, '#99221155')
        // tri joint
        this.points[2].pen.fill(ctx, '#00cc3355')
    }

    graphChain(ctx, head, ps) {

        // this.g.walkForward(this.head, (key, fromPoint, allTargets)=>{
        //     ps[key].pen.circle(ctx, ps[fromPoint].radius + 3, 'red')
        // })

        this.g.getChain(this.head, (key, leaf)=>{
            ps[key]?.pen.circle(ctx, ps[key].radius + 3, leaf? 'green': 'red')
        })

        this.g.walkForward(this.head, (key, fromPoint, allTargets)=>{
            ps[key].pen.line(ctx, ps[fromPoint])
            // key.rotation = fromPoint.rotation
        })
    }

}


================================================================================
END: graph-directional.js
================================================================================



================================================================================
FILE: graph-follow-better.js
================================================================================

/*
title: Graph Based Rotation
categories:
    raw
    graph
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    point
    stage
    mouse
    ../point_src/graph-connections.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    ../point_src/functions/springs.js
    ../point_src/velocity.js
    stroke

---

Rotating any one point rotates them all.

---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({x:250, y:150, radius:10, vx: .1, vy: 0, mass: 1 })
            , new Point({x:400, y:320, radius:10, vx: .1, vy: 0, mass: 1 })
            , new Point({x:300, y:520, radius:8, vx: .1, vy: 0, mass: 1 })

            , new Point({x:340, y:580, radius:8, vx: .1, vy: 0, mass: 1 })
            , new Point({x:380, y:520, radius:8, vx: .1, vy: 0, mass: 1 })

            , new Point({x:410, y:520, radius:8, vx: .1, vy: 0, mass: 1 })
            , new Point({x:450, y:520, radius:8, vx: .1, vy: 0, mass: 1 })

            , new Point({x:430, y:520, radius:8, vx: .1, vy: 0, mass: 1 })
            , new Point({x:400, y:520, radius:8, vx: .1, vy: 0, mass: 1 })
        )

        this.collisionBox = new CollisionBox(this.points)
        this.g = new GraphConnections;

        this.head = 0

        this.g.connect(0, 1, 2, 3, 4)
        this.g.connect(2, 5)
        this.g.connect(5, 6, 7, 8)

        this.dragging.add(...this.points)
    }

    onMousedown(ev, p) {
        // console.log(this.dragging._near)
        this.head = this.points.indexOf(this.dragging._near)
    }

    draw(ctx){
        this.clear(ctx)
        this.collisionBox.shuffle()

        // let mouse = Point.mouse.position
        // followPoint(mouse, this.points[0], 50)
        let ps = this.points

        this.graphChain(this.head, ps)
        this.points.pen.indicators(ctx)

        // head
        this.points[0].pen.fill(ctx, '#99221155')
        // tri joint
        this.points[2].pen.fill(ctx, '#00cc3355')


    }

    graphChain(head, ps) {

        let pairCallback = (key, fromKey, allTargets)=>{
            // console.log('from=', fromKey, 'key=', key, )
            constraints.within(ps[fromKey], ps[key], 50)
            // constraints.distance(ps[fromKey], ps[key], 50)
        }

        this.g.walkForward(head, pairCallback)
    }

}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: graph-follow-better.js
================================================================================



================================================================================
FILE: graph-lines.js
================================================================================

/*
title: Graph Based Rotation
categories:
    raw
    graph
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    point
    stage
    mouse
    ../point_src/graph-connections.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    ../point_src/functions/springs.js
    ../point_src/velocity.js
    stroke

---

Rotating any one point rotates them all.

---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({x:250, y:150, radius:10, vx: .1, vy: 0, mass: 1 })
            , new Point({x:400, y:320, radius:10, vx: .1, vy: 0, mass: 1 })
            , new Point({x:300, y:520, radius:8, vx: .1, vy: 0, mass: 1 })

            , new Point({x:340, y:580, radius:8, vx: .1, vy: 0, mass: 1 })
            , new Point({x:380, y:520, radius:8, vx: .1, vy: 0, mass: 1 })

            , new Point({x:410, y:520, radius:8, vx: .1, vy: 0, mass: 1 })
            , new Point({x:450, y:520, radius:8, vx: .1, vy: 0, mass: 1 })

            , new Point({x:430, y:520, radius:8, vx: .1, vy: 0, mass: 1 })
            , new Point({x:400, y:520, radius:8, vx: .1, vy: 0, mass: 1 })
        )

        this.collisionBox = new CollisionBox(this.points)
        this.g = new GraphConnections;

        this.head = 0

        this.g.connect(0, 1, 2, 3, 4)
        this.g.connect(2, 5)
        this.g.connect(5, 6, 7, 8)

        this.dragging.add(...this.points)
    }

    onMousedown(ev, p) {
        // console.log(this.dragging._near)
        this.head = this.points.indexOf(this.dragging._near)


        let ps = this.points
    }

    draw(ctx){
        this.clear(ctx)
        this.collisionBox.shuffle()

        // let mouse = Point.mouse.position
        // followPoint(mouse, this.points[0], 50)
        let ps = this.points

        this.graphChain(ctx, this.head, ps)
        this.points.pen.indicators(ctx)

        // head
        this.points[0].pen.fill(ctx, '#99221155')
        // tri joint
        this.points[2].pen.fill(ctx, '#00cc3355')


    }

    graphChain(ctx, head, ps) {
        // let head = this.head
        // let ps = this.points
        let visits = {}

        this.g.walkForward(head, (key, fromKey, allTargets)=>{
            let fromPoint = ps[fromKey]
            ps[key].pen.line(ctx, fromPoint)
            // ps[key].rotation = fromPoint.rotation
        })



================================================================================
END: graph-lines.js
================================================================================



================================================================================
FILE: graph-rotation.js
================================================================================

/*
title: Graph Based Rotation
categories:
    raw
    graph
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    point
    stage
    mouse
    ../point_src/graph-connections.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    ../point_src/functions/springs.js
    ../point_src/windings.js
    ../point_src/velocity.js
    stroke

---

Rotating any one point rotates them all.

---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({x:250, y:150, radius:20, vx: .1, vy: 0, mass: 1 })
            , new Point({x:400, y:320, radius:20, vx: .1, vy: 0, mass: 1 })
            , new Point({x:300, y:520, radius:20, vx: .1, vy: 0, mass: 1 })

            , new Point({x:340, y:580, radius:20, vx: .1, vy: 0, mass: 1 })
            , new Point({x:380, y:520, radius:20, vx: .1, vy: 0, mass: 1 })

            , new Point({x:410, y:420, radius:20, vx: .1, vy: 0, mass: 1 })
            , new Point({x:450, y:570, radius:20, vx: .1, vy: 0, mass: 1 })

            , new Point({x:430, y:450, radius:20, vx: .1, vy: 0, mass: 1 })
            , new Point({x:400, y:420, radius:20, vx: .1, vy: 0, mass: 1 })
        )

        this.collisionBox = new CollisionBox(this.points)
        this.g = new DirectionalGraphConnections;

        this.head = 0

        this.g.connect(0, 1, 2, 3, 4)
        this.g.connect(2, 5)
        this.g.connect(5, 6, 7, 8)

        this.dragging.add(...this.points)
    }

    onMousedown(ev, p) {
        // console.log(this.dragging._near)
        this.head = this.points.indexOf(this.dragging._near)
    }

    draw(ctx){
        this.clear(ctx)
        this.collisionBox.shuffle()

        // let mouse = Point.mouse.position
        // followPoint(mouse, this.points[0], 50)
        let ps = this.points

        this.graphChain(this.head, ps)
        this.points.pen.indicators(ctx)

        // head
        this.points[0].pen.fill(ctx, '#99221155')
        // tri joint
        this.points[2].pen.fill(ctx, '#00cc3355')
        ctx.fillStyle = 'white'
        this.g.walkForward(this.head, (key, fromPoint, allTargets)=>{
            ps[key].pen.line(ctx, ps[fromPoint])
            ps[key].text.label(ctx)
            // key.rotation = fromPoint.rotation
        })

    }

    graphChain(head, ps) {
        this.g.walkForward(head, function(k,i){
            if(!ps[i]){ return };

            ps[k].rotation = ps[i]?.rotation

        })



================================================================================
END: graph-rotation.js
================================================================================



================================================================================
FILE: gravity-pairwise.js
================================================================================

/*
title: Gravity Pairwise
categories:
    gravity
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/screenwrap.js
---

moved to functions/springs
*/
/**
 * @param {Point[]} points - Array of Point objects
 * @param {number} G       - Gravitational constant
 * @param {number} dt      - Timestep (e.g., 0.1, 0.01, etc.)
 */
function updatePoints(points, G=.1, dt=1) {
  // Temporary array to store net forces
  const forces = points.map(() => ({ fx: 0, fy: 0 }));

  // Calculate pairwise gravitational force
  for (let i = 0; i < points.length; i++) {
    for (let j = i + 1; j < points.length; j++) {
      const p1 = points[i];
      const p2 = points[j];

      // Distance components
      const dx = p2.x - p1.x;
      const dy = p2.y - p1.y;
      const distSq = dx * dx + dy * dy; // distance squared
      const dist = Math.sqrt(distSq);

      // Avoid division by zero if points overlap
      if (dist === 0) continue;

      // Gravitational force magnitude: F = G * (m1 * m2) / r^2
      const F = (G * p1.mass * p2.mass) / distSq;

      // Direction from p1 to p2
      const fx = F * (dx / dist);
      const fy = F * (dy / dist);

      // Accumulate forces
      forces[i].fx += fx;
      forces[i].fy += fy;

      // Opposite reaction force on p2
      forces[j].fx -= fx;
      forces[j].fy -= fy;
    }
  }

  // Now update velocities and positions
  for (let i = 0; i < points.length; i++) {
    const p = points[i];
    const f = forces[i];

    // Acceleration = F / m
    const ax = f.fx / p.mass;
    const ay = f.fy / p.mass;

    // Update velocity
    p.vx += ax * dt;
    p.vy += ay * dt;

    // Update position
    p.x += p.vx * dt;
    p.y += p.vy * dt;
  }
}

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        // this.screenWrap = new ScreenWrap()
        this.points = new PointList(
            new Point({
                 x: 150, y: 230
                , radius: 10
                , vx: .1, vy: 0


================================================================================
END: gravity-pairwise.js
================================================================================



================================================================================
FILE: gravity-points-2.js
================================================================================

/*
title: Gravity Points 2
categories: gravity
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
 */
/* moved to functions/gravity */
const applyGravityAndBounds = function(point, gravityVector, bounds, dampingFactor) {
    // Apply gravity
    point.vx += gravityVector.x;
    point.vy += gravityVector.y;

    // Update position based on velocity
    point.x += point.vx;
    point.y += point.vy;

    // Check for collision with bounds and bounce
    if (point.x <= bounds.left) {
        point.x = bounds.left;
        point.vx = -point.vx * dampingFactor;
    }
    if (point.x >= bounds.right) {
        point.x = bounds.right;
        point.vx = -point.vx * dampingFactor;
    }
    if (point.y <= bounds.top) {
        point.y = bounds.top;
        point.vy = -point.vy * dampingFactor;
    }
    if (point.y >= bounds.bottom) {
        point.y = bounds.bottom;
        point.vy = -point.vy * dampingFactor;
    }
}

const applyGravityAndBoundsAngular0 = function(point, gravityVector, bounds, dampingFactor) {
    // Apply gravity
    point.vx += gravityVector.x;
    point.vy += gravityVector.y;

    // Update position based on velocity
    point.x += point.vx;
    point.y += point.vy;

    // Check for collision with bounds and bounce
    if (point.x <= bounds.left) {
        point.x = bounds.left;
        point.vx = -point.vx * dampingFactor;
        point.omega += Math.abs(point.vy) / point.radius; // Increase angular velocity based on y-velocity
    }
    if (point.x >= bounds.right) {
        point.x = bounds.right;
        point.vx = -point.vx * dampingFactor;
        point.omega -= Math.abs(point.vy) / point.radius; // Decrease angular velocity based on y-velocity
    }
    if (point.y <= bounds.top) {
        point.y = bounds.top;
        point.vy = -point.vy * dampingFactor;
        point.omega += Math.abs(point.vx) / point.radius; // Increase angular velocity based on x-velocity
    }
    if (point.y >= bounds.bottom) {
        point.y = bounds.bottom;
        point.vy = -point.vy * dampingFactor;
        point.omega -= Math.abs(point.vx) / point.radius; // Decrease angular velocity based on x-velocity
    }

    // Apply damping to reduce angular velocity over time
    point.omega *= dampingFactor;

    // Update rotation based on angular velocity
    point.rotation += radiansToDegrees(point.omega)
}

const applyGravityAndBoundsAngular1 = function(point, gravityVector, bounds, linearDampingFactor, angularDampingFactor, friction) {
    // Apply gravity
    point.vx += gravityVector.x;
    point.vy += gravityVector.y;

    // Update position based on velocity
    point.x += point.vx;
    point.y += point.vy;

    // Check for collision with bounds and bounce
    if (point.x <= bounds.left) {
        point.x = bounds.left;
        point.vx = -point.vx * linearDampingFactor;

        // Apply tangential velocity and adjust angular velocity


================================================================================
END: gravity-points-2.js
================================================================================



================================================================================
FILE: gravity-rk4.js
================================================================================

/*
title: Gravity RK4
categories:
    gravity
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
---

moved to functions/springs
*/
/**
 * @param {Point[]} points - Array of Point objects
 * @param {number} G       - Gravitational constant
 * @param {number} dt      - Timestep (e.g., 0.1, 0.01, etc.)
 */



// 1) Define your initial points (like your old "Point" objects)
const points = new PointList(
    { x: 500, y: 300, vx: 0.2, vy: 0.2, mass: 10, radius: 10 },
    { x: 400, y: 340, vx: 0.0, vy: 0.0, mass: 40, radius: 40 },
    { x: 150, y: 200, vx: 0.7, vy: 0.1, mass: 5, radius: 5 },
  // ... etc
).cast()

// 2) Convert to an array-based state
const N = points.length;
const masses = new Array(N);
const state = new Float64Array(4 * N);

for (let i = 0; i < N; i++) {
    masses[i] = points[i].mass;      // store mass
    state[4 * i + 0] = points[i].x;  // x
    state[4 * i + 1] = points[i].y;  // y
    state[4 * i + 2] = points[i].vx; // vx
    state[4 * i + 3] = points[i].vy; // vy
}

// 3) Parameters
const G = 1;
const dt = 1;  // time step

function animate() {
  // 4) Update the state using RK4
  const newState = rk4Step(state, masses, G, dt);

  // 5) Copy newState back to 'state'
  state.set(newState);

  // 6) (Optional) Update your 'points' array if you want to draw them
  for (let i = 0; i < N; i++) {
    points[i].x  = state[4 * i + 0];
    points[i].y  = state[4 * i + 1];
    points[i].vx = state[4 * i + 2];
    points[i].vy = state[4 * i + 3];
  }

  // 7) Draw your points on canvas (or console, etc.)
  // renderPoints(points);
}



class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = points
        this.dragging.add(...this.points)
    }

    // onDragStart(ev, p) {
    //     this.dragPoint = p
    // }

    // onDragEnd(ev, p) {
    //     this.dragPoint = undefined
    // }

    onWheel(ev, p) {


================================================================================
END: gravity-rk4.js
================================================================================



================================================================================
FILE: grid-3.js
================================================================================

/*
title: A Grid.
category: grid
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    stroke
    mouse

---

A grid of points (also draggable)

    PointList.generate.grid(100, 10, 50)
*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = PointList.generate.grid(100, 10, 50)
        this.dragging.add(...this.points)
    }

    draw(ctx){
        this.clear(ctx)
        this.points.pen.indicators(ctx)
    }
}

stage = MainStage.go()


================================================================================
END: grid-3.js
================================================================================



================================================================================
FILE: grid-example.js
================================================================================

/*
title: Grid Example
categories:
    grid
    raw
files:
    head
    point
    pointlist
    mouse
    stage
    ../point_src/math.js
    ../point_src/extras.js
    stroke

---

A grid of points can be built through _shaping_ and existing list of points.

This example doesn't use a stage, opting for a draw _canvas_ drawing, but utilising
polypoint functions.

    pointList = PointList.generate.list(100, 0)

To set the position of the grid generator, we can just edit the first point:

    pointList[0].set(50, 50)

Then reshape internally

    pointList.shape.grid(pointSpread, rowCount)
*/
const canvas = document.getElementById('playspace');
const ctx = canvas.getContext('2d');
Point.mouse.mount(canvas)


// var t = 0;
// let spinSpeed = 2
let pointSpread = 55 /* Distance between points */
let rowCount = 10 /* How many items per row within the grid */

const pointList = PointList.generate.list(100, 0)

/* To set the position of the grid generator, we can just edit the
first point. */
pointList[0].set(50, 50)
/* Then reshape internally */
pointList.shape.grid(pointSpread, rowCount)

pointList.forEach(p=>{
    p.radius=10
    p.rotation = Math.random() * 360
})

const update = function() {
    ctx.beginPath()
    drawGrid()
}

const drawGrid = function(){

    /* set the position of the polygon point */
    // pointList[0].set(Point.mouse.position)
    // pointList.draw.pointLine(ctx)
    quickStroke('red', 1)
    // t = (t + 1) % 360

    let mousePoint = Point.mouse.position
    /* Draw each point; wrapping the _draw_ call_ with our own functionality.*/
    pointList.pen.points(ctx, (item,f)=>{
        ctx.beginPath();

        // item._rotationDegrees = item.UP + (t * spinSpeed) % 360
        // item.rotation += spinSpeed
        item.lookAt(mousePoint)

        f(item)
        item.project().draw.lineTo(ctx, item)
        // item.project().draw.line(ctx, 1);
        quickStroke('pink', 1)
    })

    // pointList[0].pen.ngon(ctx, 5, 90)
}


function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    update()
    requestAnimationFrame(draw);
}


let rect = canvas.getBoundingClientRect()
ctx.canvas.width  = rect.width;
ctx.canvas.height = rect.height;
draw()



================================================================================
END: grid-example.js
================================================================================



================================================================================
FILE: grid-flag.js
================================================================================

/*
title: Grid Flag
categories: minimal
    grid
files:
    ../point_src/unpack.js
    head
    point
    pointlist
    stage
    stroke
    dragging
    mouse
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/


addSliderControlSet({
    color: { min: 0, max: 361, value: 190
        , onchange(ev, unit) {
            stage.baseColor = Number(ev.currentTarget.value)
            unit.value = ev.currentTarget.value

        }
    }
    , growth: { min: 0, max: 40, value: 6
        , onchange(ev, unit) {
            stage.growth = Number(ev.currentTarget.value)
            unit.value = ev.currentTarget.value

        }
    }
    , min: { min: .5, max: 40, value: 5, step: .5
        , onchange(ev, unit) {
            stage.min = Number(ev.currentTarget.value)
            unit.value = ev.currentTarget.value

        }
    }
})

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.point = this.center.copy().update({ radius: 30})
        // this.points = PointList.generate.grid(500, 20, 15, point(100, 100))
        this.points = PointList.generate.grid({
            count:500
            , rowCount:20
            , spread:15
            , position:point(100, 100)
        })

        this.tick = 0
        this.speed = .02
        this.phase = this.point.radians = .3
        this.growth = 6
        this.min = 3
        this.baseColor = 190
        this.dragging.add(this.point)
    }

    draw(ctx){
        this.clear(ctx)
        this.tick += 1
        this.phase = this.point.radians
        this.speed = this.point.radius * .001
        this.points.pen.fill(ctx)
        this.point.pen.indicator(ctx)
        let baseColor = this.baseColor
        this.points.each.radius = (p, i) => {
                    return this.min + (
                            Math.cos(i
                                * this.phase
                                + this.tick
                                * this.speed
                            )
                            * this.growth
                        )
                }

        this.points.each.color = (p,i)=>{
            return `hsl(${baseColor+Math.sin(i * this.speed * this.phase) * 40} 80% 50%)`
        }
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: grid-flag.js
================================================================================



================================================================================
FILE: grid-panning-2.js
================================================================================

/*
title: Grid Panning
category: grid plane
files:
    head
    point
    pointlist
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/gridplane.js
    stage
    mouse
    dragging
    stroke
 */

// var gravity = {x: 0, y:-0.05}; // Gravity constant for helium balloon.
var gravity = {x: 0, y:1}; // Gravity constant


class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        // this.mouse.position.vy = this.mouse.position.vx = 0

        // new Point({ x: 200, y: 200, radius: 140, vx: 0, vy: 0})
        this.point = this.center.copy().update({radius: 50})
        //new Point({ x: 300, y: 100, vx: 0, vy: 0})
        this.pin = this.center.copy().update({radius: 10})
        this.dragging.add(this.pin, this.point)
        this.plane = new GridPlane(this.dimensions)
        this.plane.mounted(this.pin, this.point)
    }

    onContextmenu(e) {
        e.preventDefault()
        e.stopImmediatePropagation()
        return false;
    }

    onMousedown(ev) {
        // console.log('down')
        if(ev.button == 2) {
            this.plane.trackDown(Point.from(ev))
        }
    }

    onMouseup(ev) {
        // console.log('Up')
        if(ev.button == 2) {
            this.plane.trackUp(Point.from(ev))
        }
    }

    draw(ctx) {
        this.clear(ctx);
        let mp = this.mouse.point;
        let b = this.plane.panPlane(mp)
        this.panOffset = b
        this.plane.drawLines(ctx, ~~this.point.radius, b)

        let other = this.point
        let pin = this.pin
        other.pen.circle(ctx, {color:'red'})
        pin.pen.indicator(ctx)
    }

}

const stage = MainStage.go()


================================================================================
END: grid-panning-2.js
================================================================================



================================================================================
FILE: grid-panning-raw.js
================================================================================

/*
title: Grid Panning
category: grid plane
files:
    head
    point
    pointlist
    ../point_src/extras.js
    ../point_src/math.js
    stage
    mouse
    dragging
    stroke
 */

// var gravity = {x: 0, y:-0.05}; // Gravity constant for helium balloon.
var gravity = {x: 0, y:1}; // Gravity constant

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        // this.mouse.position.vy = this.mouse.position.vx = 0

        // new Point({ x: 200, y: 200, radius: 140, vx: 0, vy: 0})
        this.point = this.center.copy().update({radius: 50})
        //new Point({ x: 300, y: 100, vx: 0, vy: 0})
        this.pin = this.center.copy().update({radius: 10})
        this.dragging.add(this.pin, this.point)
        this.move = 0
        this.panning = { speed: {x: 0, y:0 }, cached: {x:0, y:0}, track: false, tick: 0 }
        this.padding = {
            top: 50
            , left: 60
            , right: 400
            , bottom: 50
            , get x() {
                return this.left
            }
            , get y() {
                return this.bottom
            }
        }
    }

    onContextmenu(e) {
        e.preventDefault()
        e.stopImmediatePropagation()
        return false;
    }

    onMousedown(ev) {
        // console.log('down')
        if(ev.button == 2) {
            this.trackDown(Point.from(ev))
        }
    }

    onMouseup(ev) {
        // console.log('Up')
        if(ev.button == 2) {
            this.trackUp(Point.from(ev))
        }
    }

    trackDown(evPoint) {
        this.panning.track = true
        let s = evPoint
        let c = this.panning.cached
        s.x += c.x
        s.y += c.y
        this.panning.start = s
        // this.panning.startTime = +(new Date)
        this.lastPoint = evPoint
        this.panning.tick = 0
        this.panning.speed = { x: 0, y: 0}
    }

    trackUp(evPoint) {
        let p = this.panning
        p.track = false
        p.end = evPoint
        p.cached = p.start.distance2D(p.end)
        // p.endTime = +(new Date)
        // p.speed = evPoint.distance2D(this.lastPoint)
        // this.lastPoint = evPoint
    }

    draw(ctx) {
        this.clear(ctx);
        let b = this.panPlane(ctx)
        this.drawLines(ctx, ~~this.point.radius, b)

        let other = this.point
        let pin = this.pin
        other.pen.circle(ctx, {color:'red'})
        pin.pen.indicator(ctx)
    }

    panPlane(ctx){


================================================================================
END: grid-panning-raw.js
================================================================================



================================================================================
FILE: grid-pillow.js
================================================================================

/*
title: Grid Pillow
category: grid
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/distances.js
 */

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.center.radius = 50

        let pointSpread = 55 /* Distance between points */
        let rowCount = 10 /* How many items per row within the grid */

        const pointList = PointList.generate.list(100, 0)

        /* To set the position of the grid generator, we can just edit the
        first point. */
        pointList[0].set(50, 50)
        /* Then reshape internally */
        pointList.shape.grid(pointSpread, rowCount)
        pointList.forEach(p => p.radius = 10)
        // pointList.each.radius = 10

        this.points = pointList
    }

    draw(ctx){
        this.clear(ctx)

        let mousePoint = Point.mouse.position
        /* Draw each point; wrapping the _draw_ call_ with our own functionality.*/
        this.points.pen.points(ctx, (item,f)=>{
            item.lookAt(mousePoint)
            /* Perform the given rendering function*/
            f(item)
            /* to draw _cushion_ style, we _project_ towards the mouse,
            then draw a point.*/
            item.project().pen.indicator(ctx, item)
        })
    }
}

stage = MainStage.go()


================================================================================
END: grid-pillow.js
================================================================================



================================================================================
FILE: hairy-ball.js
================================================================================

/*
title: Hairy Ball
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/automouse.js
    ../point_src/setunset.js
    ../point_src/text/styler.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/rope.js
    fps
    ../point_src/collisionbox.js
    ../point_src/gravity.js
    ../point_src/constrain-distance.js
    ../point_src/random.js

    */

const stringLength = 200

const heavyStep = function(followPoint, mouse, gravity,
                           damping=.9, dotDamping=.2, forceMultiplier=.1, forceValue=undefined) {
    // Apply gravity to the follow point's vertical velocity
    // Calculate the vector from the mouse to the follow point
    // let dx = followPoint.x - mouse.x ;
    // let dy = followPoint.y - mouse.y ;
    let dx = mouse.x - followPoint.x;
    let dy = mouse.y - followPoint.y;

    // Calculate the current distance between the follow point and the mouse
    let distance = Math.sqrt(dx * dx + dy * dy);

    // Set the follow point's position to be exactly on the circumference of the string length
    // const force = (distance - stringLength) * 0.01; // Tweak this factor as needed

    // If the distance exceeds the string length, we need to constrain the follow point
    if (distance > stringLength) {

        // Normalize the direction vector
        dx /= distance;
        dy /= distance;

        if(dotDamping!==false) {
            // Adjust the velocity so that it reflects the string tension
            let dotProduct = (followPoint.vx * dx + followPoint.vy * dy) * dotDamping;
            followPoint.vx -= dotProduct * dx;
            followPoint.vy -= dotProduct * dy;
        }

        if(forceMultiplier!==false){
            const force = forceValue? forceValue: (distance - stringLength) * forceMultiplier; // Tweak this factor as needed
            followPoint.vx += force * dx;
            followPoint.vy += force * dy;
        }

    }

    // Apply gravity
    if(gravity){
        followPoint.vy += gravity.y;
        followPoint.vx += gravity.x;
    }

    // Update the follow point's position based on its velocity
    followPoint.x += followPoint.vx;
    followPoint.y += followPoint.vy;

    if(damping) {
        // Apply damping continuously to smooth the motion
        followPoint.vx *= damping;
        followPoint.vy *= damping;
    }
};


const flutter = ()=>{
    stage.cable.visibleRopeGravity.y = -.05 + (random.float(-1, 1) * .1)
    setTimeout(flutter, random.float(2, 5))
};

// setTimeout(flutter, random.float(0.5, 2))




================================================================================
END: hairy-ball.js
================================================================================



================================================================================
FILE: hole-example.js
================================================================================

/*
title: a "Hole"
categories: hole
files:
    head
    point
    mouse
    stage
    dragging
    ../point_src/image.js
---

Cut a _hole_ through another vector.
In this example we have a _box_ and a _circle_.

Because the second entity (the `hole`) is drawn immediately after the first
entity (the `box`). The canvas pen _cuts_ through the previous drawing.

The polypus `image` is applied _before_ the overlay.
*/

class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        this.image = new ImageLoader("../images/polypus.png")

        this.box = this.center.copy().update({radius:200})
        this.hole = this.box.copy().update({radius: 100})
        this.image.position.xy = this.box.xy

        this.dragging.add(this.box, this.hole, this.image.position)
    }

    draw(ctx){
        this.clear(ctx)
        this.image.draw(ctx)
        ctx.fillStyle = '#544466'
        ctx.beginPath()
        this.box.draw.box(ctx)
        this.hole.draw.arc(ctx)
        ctx.fill()
    }
}


;stage = MainStage.go();

================================================================================
END: hole-example.js
================================================================================



================================================================================
FILE: hover-action.js
================================================================================

/*
title: Hover Action
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js



 */
class MyPoint extends Point {
    onClick(ev) {
        console.log('Clicked!')
    }

    onMousemove(ev) {
        // console.log('move')
    }

    onMousedown(ev) {
        console.log('down')
    }

    onMouseup(ev) {
        console.log('up')
    }

    onDragStart(ev) {
        console.log('drag start')
    }

    onDragEnd(ev) {
        console.log('drag end')
    }

    onDragMove(ev) {
        // console.log('drag move')
    }

    onLongClick(ev, delta) {
        let args = Array.from(arguments)
        console.log('onLongClick', args)
    }

    onWheel(ev) {
        let args = Array.from(arguments)
        console.log(args)
    }
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.stroke = new Stroke({
            dash: [5,5]
            , color: 'grey'
            , width: 2
        })

        let p = this.point = new MyPoint(233,142)
        this.dragging.add(p)
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.indicator(ctx)
    }
}


stage = MainStage.go()

================================================================================
END: hover-action.js
================================================================================



================================================================================
FILE: hue-point.js
================================================================================

/*
title: Example
categories: basic
    dragging
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    ../point_src/easing.js
---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 , radius: 20, rotation: 45})
        this.dragging.add(this.point)
    }

    draw(ctx){
        this.clear(ctx)
        let p = this.point
        let r = p.rotation
        let s =  clamp((p.x*.24) - 50, 0, 100)
        let se = quadEaseOut(s * .01) * 100
        let l = 100 - clamp((p.y*.24) - 50, 0, 100)
        let le = quadEaseOut(l * .01) * 100
        let color = `hsl(${r}deg ${se}% ${le}%)`
        this.point.pen.indicator(ctx, {color, width: 4})
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: hue-point.js
================================================================================



================================================================================
FILE: hut-example.js
================================================================================

/*
title: Hut Example
categories: gravity
    raw
    quad-tree
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js


moved to functions/springs */


// 2) Choose parameters
const G = 0.1;     // gravitational constant
const theta = 0.5; // opening angle
const dt = 1;

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                 x: 150, y: 230
                , radius: 10
                , vx: .1, vy: 0
                , mass: 10
            })
            , new Point({
                 x: 350, y: 200
                , vx: 0, vy: 0
                , radius: 120
                , mass: 120
            })
            , new Point({
                 x: 250, y: 270
                , vx: .1, vy: 0
                , radius: 8
                , mass: 8
            })
        )

        // 1) Create some bodies
        this.bodies = new PointList(
          new Body(100, 100, 0.5, 0.4, 10),
          new Body(300, 100, 0, 0, 20),
          new Body(200, 200, -0.2, 0.1, 5),
          // ...
        )

        this.timestep = 1
        this.dragging.add(...this.points)
    }

    onDragStart(ev, p) {
        this.dragPoint = p
    }

    onDragEnd(ev, p) {
        this.dragPoint = undefined
    }

    onWheel(ev, p) {
        p.mass = p.radius
    }

    draw(ctx){
        this.clear(ctx)

        barnesHutUpdate(this.bodies, G, theta, dt);

        this.bodies.forEach(p=>{
            (new Point(p)).pen.indicator(ctx)
        })

    }
}


class Body{
  constructor(x, y, vx, vy, mass) {
    this.x = x;


================================================================================
END: hut-example.js
================================================================================



================================================================================
FILE: hyperway-stepper-example.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    pointlist
    stage
    stroke
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/
class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {

        this.points = PointList.generate.list(8, new Point(100, 0), new Point(100, 200))
        this.points.each.radius = 15
        this.point = this.points[2].copy()
        this.point.radius = 30
    }

    draw(ctx){
        this.clear(ctx)
        this.points.pen.line(ctx,{width: 4, color: '#444'})
        this.points.pen.fill(ctx, 'purple')
        this.point.pen.circle(ctx, {color: '#8f6faf'})
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: hyperway-stepper-example.js
================================================================================



================================================================================
FILE: image-data.js
================================================================================

/*
title: PNG Image
categories: images
    svg
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/image.js

---

For loading _images_, you can load _image content_ at a position.

    let fp = "../images/mail.png"
    const image = new ImageLoader(fp)

The `ImageLoader` class offsets the download and storage of image data. It also
has a Point, used for position, scale, and rotation of the image

    let imagePoint = this.image.position
    imagePoint.rotation += 1
    // wraps the image.
    imagePoint.pen.circle(ctx)

    // Draw the image data.
    // respecting the point positon
    image.draw(ctx)

*/

let path = `M395.065.638c-.445-.068-2.723-.343-3.789.907a2.37,2.37,0,0,0-.344,
            2.4.49.49,0,0,1-.032.436,3.829,3.829,0,0,1-2.1,
            1.154c-.027.006-.046.024-.072.032a9.326,9.326,0,0,0-6.309-2.092,
            10.548,10.548,0,0,0-7.077,3.135l-8.115,8.115c-4,4-4.2,10.293-.457,
            14.036a9.252,9.252,0,0,0,6.6,2.679A10.55,10.55,0,0,0,380.8,
            28.3l8.114-8.114a10.061,10.061,0,0,0,1.32-13.018,4.693,4.693,
            0,0,0,2.4-1.8,2.482,2.482,0,0,0,
            .2-2.039c-.086-.268-.082-.441-.042-.488a3.093,3.093,0,0,1,1.968-.229,
            1,1,0,1,0,.3-1.977ZM382.486,5.469c.1,0,.2,0,.294,0a7.257,7.257,0,0,
            1,4.808,1.763l-3.531,3.531a1.473,1.473,0,0,
            0-1.685.235l-.976.975-4.281-4.281A8.508,8.508,0,0,1,
            382.486,5.469Zm-.53,8.84a.462.462,0,0,1-.634,0l-.11-.109a.45.45,
            0,0,1,0-.634l1.867-1.866a.46.46,0,0,1,.632,0l.111.111a.448.448,
            0,0,1,0,.633Zm-2.568,12.576c-3.218,3.217-8.247,
            3.419-11.209.457s-2.759-7.992.457-11.208l7.756-7.755,4.3,
            4.3-.184.184a1.451,1.451,0,0,0,0,2.048l.11.109h0a1.452,1.452,0,0,
            0,2.048,0l.183-.184,4.3,4.3Zm8.446-8.479-4.28-4.281.975-.975a1.442,
            1.442,0,0,0,.424-1.024,1.414,1.414,0,0,
            0-.185-.666l3.525-3.525A7.951,7.951,0,0,1,387.834,18.406Z`

class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.image = new ImageLoader("../images/mail.png")
        this.path = new PathData(path)
        this.dragging.add(this.image.position, this.path.position)
    }

    draw(ctx){
        this.clear(ctx)

        let ip = this.image.position
        ip.rotation += 1
        ip.pen.circle(ctx)
        this.image.draw(ctx)

        this.path.position.rotation += 2
        this.path.position.pen.circle(ctx)
        this.path.draw(ctx)

        let pos = this.mouse.position
        pos.pen.circle(ctx)
    }


}


;stage = MainStage.go();

================================================================================
END: image-data.js
================================================================================



================================================================================
FILE: image-pixel-data-crop.js
================================================================================

/*
title: Image Data Boundry Edge Detection
categories: imagedata
    raw
files:
    head
    pointlist
    point
    stage
    stroke
    ../point_src/random.js
    ../point_src/image.js
    ../point_src/image-edge-detection.js
    ../point_src/recttools.js
    ../point_src/offscreen.js
---


*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        // this.dragging.add()
        this.point = new Point(100, 100, 50)
        this.points = PointList.generate.random(3, [100, 200], [50, 50, 10, 0])
    }

    firstDraw(ctx) {
        // this.clear(ctx)
        this.drawAll(ctx)
    }

    detectEdges(ctx) {
        const imageData = ctx.getImageData(0, 0, 400, 400)
        const data = imageData.data;
        let place = detectEdges(imageData.data, imageData.width)
        return place;
    }

    drawAll(ctx=this.ctx){
        this.clear(ctx)
        this.points.pen.fill(ctx, '#999')
        this.points.pen.indicator(ctx, {width:1})

        // this.point.pen.indicator(ctx)

        const imageData = ctx.getImageData(0, 0, 400, 400)
        const data = imageData.data;

        // sepia(data)
        // ctx.putImageData(imageData, 200, 10);

        // invert(data)
        // ctx.putImageData(imageData, 400, 30);

        // grayscale(data)
        // ctx.putImageData(imageData, 600, 30);

        // const reImageData = ctx.getImageData(0, 0, 800, 600)
        let place = detectEdges(imageData.data, imageData.width)

        ctx.putImageData(imageData, 0, 300);

        this.place = place

        this.plotEdgePoints(place)
        this.drawPins(ctx)
    }

    plotEdgePoints(place){
        this.boxPoints = new PointList(
                [place.left, place.top]
                , [place.left, place.bottom]
                // , [place.right, place.bottom]
                // , [place.right, place.top]
                // , [place.left, place.top]
            ).cast()
        this.boxPoints2 = new PointList(
                // [place.left, place.top]
                // , [place.left, place.bottom]
                 [place.right, place.bottom]
                , [place.right, place.top]
                // , [place.left, place.top]
            ).cast()
    }

    drawPins(ctx){
        this.boxPoints.pen.indicator(ctx, {color: 'red'})
        this.boxPoints2.pen.indicator(ctx, {color: 'yellow'})
    }

    onResize(ev) {
        console.log('Resize', this)
        /* Resize may occur before mounted().
        As such - easy back-out... */
        if(this.points) {
            this.drawAll()
        }


================================================================================
END: image-pixel-data-crop.js
================================================================================



================================================================================
FILE: image-pixel-reshading.js
================================================================================

/*
title: Image Data Reshading
categories: imagedata
    raw
files:
    head
    pointlist
    point
    stage
    stroke
    ../point_src/random.js
    ../point_src/image.js
---

*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        // this.dragging.add()
        this.points = PointList.generate.random(30, [100, 200], [40,20, 10, 0])
    }

    firstDraw(ctx) {
        // this.clear(ctx)
        this.points.pen.fill(ctx, '#999')
        this.points.pen.indicator(ctx)
        const imageData = ctx.getImageData(0, 0, 400, 400)
        const data = imageData.data;

        sepia(data)
        ctx.putImageData(imageData, 200, 10);

        invert(data)
        ctx.putImageData(imageData, 400, 30);

        grayscale(data)
        ctx.putImageData(imageData, 600, 30);

        // blur(data, 400, 150)
        // blur3(data, 400, 150, 10)
        // blurSeparable(data, 400, 150, 3)

    }

    draw(ctx){
    }
}


;stage = MainStage.go();

================================================================================
END: image-pixel-reshading.js
================================================================================



================================================================================
FILE: intersection-line-line.js
================================================================================

/*
title: Intersection Line Line
categories: intersections
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/pointlistpen.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/mirror.js
    ../point_src/stage.js
    ../point_src/text/label.js
    ../point_src/intersections.js

---

Discover the intersection of two straight _lines_, the returned point
will be the intersection of those lines.

A line is a list of two points [{x:10, y:10}, {x:50, y:50}]

        lineA = new PointList(
                new Point({x:406, y:76, radius: 20})
                , new Point({x:145, y:397, radius: 20})
            )

        lineB = new PointList(
                new Point({x:206, y:176, radius: 20})
                , new Point({x:245, y:297, radius: 20})
            )

        checkLinesIntersection(lineA, lineB)

We can project (at a length) from line a _through_ line b, essentially as a
ray beam for a defined distance.

    checkLinesIntersection(lineA, lineB, 400)

When ray projecting, the _lineB_ is essentially a _direction_ rather than just
a collision.
*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.lineA = new PointList(
                new Point({x:406, y:76, radius: 20})
                , new Point({x:145, y:397, radius: 20})
            )

        this.lineB = new PointList(
                new Point({x:206, y:176, radius: 20})
                , new Point({x:245, y:297, radius: 20})
            )

        this.dragging.addPoints(...this.lineA, ...this.lineB)

        let l = new Label(this.ctx, {
            text: 'Milkshake before breakfast.'
            , fontSize: 14
            // , fontName: 'barlow'
            // , fontName: 'Arial'
            // , fillStyle: 'green'
        })
        l.position = new Point(100, 100)
        l.position.rotation = 0 // l.position.radians % Math.PI
        this.l = l

    }

    draw(ctx){
        this.clear(ctx)

        this.lineA.pen.line(ctx)
        this.lineB.pen.line(ctx)

        let int = checkLinesIntersection(this.lineA, this.lineB)
        if(int) {
            let iPoint = (new Point).copy(int).update({radius: 30})
            // iPoint.radius = 30
            iPoint.pen.indicator(ctx)
        }

        this.l.text = `Denominator: ${int.denominator}`
        this.l.draw(ctx)
        this.dragging.drawIris(ctx)
    }
}




================================================================================
END: intersection-line-line.js
================================================================================



================================================================================
FILE: intersection-point-line.js
================================================================================

/*
title: Intersection Point Line
categories: intersections
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/mirror.js
    ../point_src/stage.js
    ../point_src/text/label.js
    ../point_src/intersections.js

---

Discover the intersection of two straight _lines_, the returned point
will be the intersection of those lines.

A line is a list of two points [{x:10, y:10}, {x:50, y:50}]

        lineA = new PointList(
                new Point({x:406, y:76, radius: 20})
                , new Point({x:145, y:397, radius: 20})
            )

        lineB = new PointList(
                new Point({x:206, y:176, radius: 20})
                , new Point({x:245, y:297, radius: 20})
            )

        checkLinesIntersection(lineA, lineB)

We can project (at a length) from line a _through_ line b, essentially as a
ray beam for a defined distance.

    checkLinesIntersection(lineA, lineB, 400)

When ray projecting, the _lineB_ is essentially a _direction_ rather than just
a collision.
*/


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.line = new PointList(
                new Point({x:406, y:76, radius: 20})
                , new Point({x:145, y:397, radius: 20})
            )

        this.other = new Point({x:200,y:200, radius: 140})
        this.dragging.addPoints(...this.line, this.other)
    }

    draw(ctx){
        this.clear(ctx)

        this.line.pen.line(ctx)
        this.other.pen.indicator(ctx)

        this.dragging.drawIris(ctx)

        let i2 = checkPointIntersectionWithin(this.line, this.other, this.other.radius)
        if(i2) {

            let iPoint = (new Point).copy(i2).update({radius: 20})
            // iPoint.radius = 30
            iPoint.pen.indicator(ctx)
        }

        i2 = checkPointIntersectionEdge(this.line, this.other, this.other.radius)
        if(i2.length > 0) {

            i2.forEach((xy)=>{
                let iPoint = (new Point).copy(xy).update({radius: 5})
                // iPoint.radius = 30
                iPoint.pen.fill(ctx, '#CC00BB')
            })
        }

    }
}


;stage = MainStage.go();

================================================================================
END: intersection-point-line.js
================================================================================



================================================================================
FILE: intersection-point-point.js
================================================================================

/*
title: Point Intersection
category: intersections
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/mirror.js
    ../point_src/stage.js
    ../point_src/text/label.js
    ../point_src/intersections.js

---

Discover the intersection of two points, the returned points
are the intersection of those points.

    getCircleCircleIntersections(pointA, pointB)

*/


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = new Point({x:200,y:200, radius:90})
        this.pointB = new Point({x:390,y:240, radius:130})
        this.dragging.addPoints(this.pointA, this.pointB)
        this.events.wake()

    }

    draw(ctx){
        this.clear(ctx)

        this.pointA.pen.indicator(ctx)
        this.pointB.pen.indicator(ctx, {color: this.pointB.color})

        let i2 = getCircleCircleIntersections(this.pointA, this.pointB)
        if(i2.length > 0) {

            i2.forEach((xy)=>{
                let iPoint = (new Point).copy(xy).update({radius: 5})
                // iPoint.radius = 30
                iPoint.pen.fill(ctx, '#CC00BB')
            })
        }
    }
}


;stage = MainStage.go();

================================================================================
END: intersection-point-point.js
================================================================================



================================================================================
FILE: iterator-example.js
================================================================================

/*
title: Iterator Example
categories: iteration
    mutators
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/iter/beta.js
---

An iterator can automatically count between a range.

*/
/* iter/beta */

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        const mutators = new Mutators(this)
        let x = 200
            , y = 200
            , amplitude = this.amplitude = 90
            , c = this.c = new Point(x,y)
            , p = this.point = new Point(x, y)
            ;
        p.radius = 30
        c.radius = amplitude

        this.xIter = new Iterator(x, [
                (v)=> mutators.stageLimit(v, 'width')
                // , (v)=>mutators.sin(v, amplitude)
            ])
        this.yIter = new Iterator(y, [
                (v)=>mutators.stageLimit(v, 'height')
                // , (v)=>mutators.cos(v, amplitude)
            ])
        this.rotIter = new Iterator(0, [
                (v)=>mutators.modulus(v, 360)
            ])
    }

    draw(ctx){
        this.clear(ctx)
        let c = this.c
        let p = this.point
        let speed = .02
        let amplitude = this.amplitude

        p.x = c.x + Math.sin(this.xIter.step(speed)) * amplitude
        p.y = c.y + Math.cos(this.yIter.step(speed)) * amplitude

        p.rotation = this.rotIter.step(-2)

        c.pen.indicator(ctx, {color:'grey'})
        p.pen.indicator(ctx, {color:'green'})
    }
}

stage = MainStage.go()


================================================================================
END: iterator-example.js
================================================================================



================================================================================
FILE: jelly-example.js
================================================================================

/*
title: Flame
categories: soft-body
    raw
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/bisector.js
    ../point_src/functions/clamp.js
    dragging
    mouse
    ../point_src/random.js
    stage
    ../point_src/velocity.js

*/

var canvas;


// const SPACING = 6;
// const ITERATIONS = 8;
// const MOUSE = SPACING * 2;
// let GRAVITY = 0.01;
// let SPEED = .8;

const SPACING = 14;
const ITERATIONS = 14;
const MOUSE = SPACING * 5;
let GRAVITY = 0.05;
let SPEED = 1;


// const canvas = document.querySelector('canvas');
// const ctx = canvas.getContext('2d');

// canvas.width = 800;
// canvas.height = 600;

const mouse = {
    x: 0,
    y: 0,
    px: 0,
    py: 0,
    points: [],
};


class MainStage extends Stage {
    canvas = 'playspace'

    mounted() {
        // this.indicator = new Point({x: 300, y: 300}); // Start the draggable point somewhere

        // this.dragging.add(this.a, this.b)
        this.events.wake();
        canvas = this.canvas

        const hue = 100;
        const squares = Array(2).fill(0).map((_, i) => {
            const size = 5 + i;
            return new Other(
                    size,
                    size,
                    5,
                    hue + i * 20,
            );
        });

        this.allPoints = [].concat(...squares.map(({ points }) => points));
        this.squares = squares
    }

    draw(ctx) {
        // this.clear(ctx);
        //
        update(ctx, this.allPoints, this.squares);
    }

    onmousedown(e) {
        this.onmousemove(e);
        mouse.down = true;

        for (const point of this.allPoints) {
                if (point.pos.distance(mouse) < MOUSE
                    && !mouse.points.includes(point)) {
                    mouse.points.push(point);
                    point.mouseDiff = JellyVector.sub(point.pos, new JellyVector(mouse.x, mouse.y));
                    point.velocity.mul(0);
                    point.force.mul(0);
                }
        }
    }

    onmouseup(){
        mouse.points = [];
        mouse.down = false;


================================================================================
END: jelly-example.js
================================================================================



================================================================================
FILE: jiggle-double.js
================================================================================

/*
---
title: Jiggle
categories: iteration
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/automouse.js
    ../point_src/dragging.js
    ../point_src/iter/alpha.js
    ../point_src/text/alpha.js
    ../point_src/text/label.js
    ../point_src/text/beta.js
    ../point_src/jiggle.js

---

Speedy motion at a singular position.
https://youtube.com/clip/UgkxbshWOsMf_ukuMO-Zq9Mimj1UYlFDIQ9Q?si=RgotghYr0We685BC
 */
class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.origin = this.center.copy().update({radius: 9})
        this.jiggler = new Jiggler(undefined, this.origin)
        this.jiggler2 = new Jiggler()

        this.dragging.addPoints(this.origin)
    }

    draw(ctx){
        this.clear(ctx)

        let jPoint = this.jiggler.point
        let updates = this.calcDistanceChanges(jPoint)

        this.jiggler.step(updates)
        this.jiggler2.step()
        let j2 = this.jiggler2.point.add(this.center.copy())

        jPoint.pen.fill(ctx, '#22BB55')
        j2.pen.fill(ctx, '#000')

    }

    calcDistanceChanges(jPoint) {
        let reducer = (20 / this.mouse.point.distanceTo(jPoint))
        reducer = clamp(reducer, .1, 1)
        return {
            width: clamp(reducer * 10, 1, 3)
            , height: clamp(reducer * 10, 1, 3)
            , reducer
        }

    }
}

;stage = MainStage.go();

================================================================================
END: jiggle-double.js
================================================================================



================================================================================
FILE: jiggle-plain.js
================================================================================

/*
---
title: Jiggle
categories: iteration
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/automouse.js
    ../point_src/dragging.js
    ../point_src/iter/alpha.js
    ../point_src/text/alpha.js
    ../point_src/text/label.js
    ../point_src/text/beta.js
    ../point_src/jiggle.js

---

Speedy motion at a singular position.
https://youtube.com/clip/UgkxbshWOsMf_ukuMO-Zq9Mimj1UYlFDIQ9Q?si=RgotghYr0We685BC
 */
class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.a = this.center.copy().update({radius: 20})
        this.lockPoint = this.center.copy().update({radius: 20})
        this.dragging.addPoints(this.lockPoint)
        // this.iter = new Iter(1, 4, 20)
        this.ticker = 0
        this.jiggleOptions = {
            /* defaults */
            speedReducer: .2
            , xSpeed: .7
            , ySpeed: .5
            , width: 3
            , height: 3
            , tick: 1
        }
    }

    getJiggle(lock=this.lockPoint, settings) {

        const o = Object.assign(this.jiggleOptions, settings)

        let xO = Math.cos(o.tick * (o.speedReducer * o.xSpeed))
        let yO = Math.sin(o.tick * (o.speedReducer * o.ySpeed))

        return {
            x: lock.x + (xO * o.width)
            , y: lock.y + (yO * o.height)
        }

    }

    draw(ctx){
        this.clear(ctx)
        let tick = this.ticker += 1
        const a = this.a
        let speedReducer = (20 / this.mouse.point.distanceTo(this.lockPoint))
        speedReducer = clamp(speedReducer, .1, 1)
        let width = clamp(speedReducer * 10, 1, 3)
        let height = clamp(speedReducer * 10, 1, 3)
        a.radius = this.lockPoint.radius
        a.update(this.getJiggle(this.lockPoint, { tick, width, height }))
        this.lockPoint.text.value = width.toFixed(2)
        a.pen.fill(ctx, '#22BB55')
        ctx.fillStyle = '#000'
        this.lockPoint.text.fill(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: jiggle-plain.js
================================================================================



================================================================================
FILE: jiggle-pointlist.js
================================================================================

/*
---
title: Jiggle
categories: iteration
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/automouse.js
    ../point_src/dragging.js
    ../point_src/iter/alpha.js
    ../point_src/text/alpha.js
    ../point_src/text/label.js
    ../point_src/text/beta.js
    ../point_src/jiggle.js

---

Speedy motion at a singular position.
https://youtube.com/clip/UgkxbshWOsMf_ukuMO-Zq9Mimj1UYlFDIQ9Q?si=RgotghYr0We685BC
 */
class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let pl = new PointList()
        this.origin = this.center.copy().update({radius: 9})
        this.jiggler = new Jiggler(undefined, this.origin)
        this.jiggler2 = new Jiggler()

        this.pl = pl
        pl.push(new Jiggler())
        pl.push(new Jiggler())
        pl.push(new Jiggler())
        pl.push(new Jiggler())

        this.dragging.addPoints(this.origin)
    }

    draw(ctx){
        this.clear(ctx)

        this.pl.each.step()
        this.pl.forEach(p=>{
            p.point.pen.fill(ctx, '#22BB55')
        })
        let jPoint = this.jiggler.point
        let updates = this.calcDistanceChanges(jPoint)

        this.jiggler.step(updates)
        this.jiggler2.step()

        let j2 = this.jiggler2.point.add(this.center.copy())

        jPoint.pen.fill(ctx, '#22BB55')
        j2.pen.fill(ctx, '#000')

    }

    calcDistanceChanges(jPoint) {
        let reducer = (20 / this.mouse.point.distanceTo(jPoint))
        reducer = clamp(reducer, .1, 1)
        return {
            width: clamp(reducer * 10, 1, 3)
            , height: clamp(reducer * 10, 1, 3)
            , reducer
        }

    }
}

;stage = MainStage.go();

================================================================================
END: jiggle-pointlist.js
================================================================================



================================================================================
FILE: jiggle.js
================================================================================

/*
---
title: Jiggle
categories: iteration
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/automouse.js
    ../point_src/dragging.js
    ../point_src/iter/alpha.js
    ../point_src/text/alpha.js
    ../point_src/text/label.js
    ../point_src/text/beta.js
    ../point_src/jiggle.js

---

Speedy motion at a singular position.
https://youtube.com/clip/UgkxbshWOsMf_ukuMO-Zq9Mimj1UYlFDIQ9Q?si=RgotghYr0We685BC
 */
class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.originA = this.center.copy().update({radius: 9})
        this.originA.y -= 100

        this.originB = this.center.copy().update({radius: 9})
        this.originB.y -= 20

        this.originC = this.center.copy().update({radius: 9})
        this.originC.y += 70

        this.originD = this.center.copy().update({radius: 9})
        this.originD.y += 160

        this.jigglerA = new Jiggler(undefined, this.originA)

        this.jigglerB = new Jiggler({
            speedReducer: 1
            , xSpeed: .5
            , ySpeed: .7
        }, this.originB)

        this.jigglerC = new Jiggler({
            speedReducer: .3
            , width: 10
            , height: 10
            , xSpeed: .5
            , ySpeed: .7
        }, this.originB)

        this.jigglerD = new Jiggler({
            speedReducer: 2
            , width: 10
            , height: 1
            , xSpeed: .2
            , ySpeed: .1
        }, this.originC)

        this.jigglerE = new Jiggler({
            speedReducer: .7
            , width: 3
            , height: 10
            , xSpeed: .5
            , ySpeed: .4
        }, this.originD)

        this.dragging.addPoints(this.originA,
                                this.originB,
                                this.originC,
                                this.originD)
    }

    draw(ctx){
        this.clear(ctx)

        this.jigglerA.step()
        this.jigglerB.step()
        this.jigglerC.step()
        this.jigglerD.step()
        this.jigglerE.step()

        this.jigglerA.point.pen.fill(ctx, '#22BB55')

        this.jigglerC.point.pen.fill(ctx, '#009911')
        this.jigglerB.point.pen.fill(ctx, '#22BB55')



================================================================================
END: jiggle.js
================================================================================



================================================================================
FILE: json-example.js
================================================================================

/*
title: JSON Save Restore
categories: json
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    mouse
    dragging
    stroke
---

We can convert a `Point` or `PointList` to JSON.
Any pointlist will cast and parse from a string:

    const strPoints = points.toJSON()
    `[
        [250,150,10,270],
        [450,520,8,270]
    ]`
    points.fromJSON(stringPoints)

In this example, any change is written to `localStorage`.
Refreshing the page will restore the previous changes.
A JSON dump of `stage.points` exists in `localStorage["polypoint-json-example"]`

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.restoreJSON()

        if(this.points == undefined) {
            this.points = new PointList(
                new Point({
                     x: 250, y: 150
                    , radius: 10
                    , vx: 1, vy: 0
                    , mass: 2
                })
                , new Point({
                     x: 400, y: 320
                    , vx: -1, vy: 0
                    , radius: 20
                    , mass: 10
                })
                , new Point({
                     x: 200, y: 320
                    , vx: .4, vy: -.1
                    , radius: 10
                    , mass: 8
                })
                , new Point({
                     x: 110, y: 220
                    , vx: .4, vy: -.1
                    , radius: 8
                    , mass: 8
                })
                , new Point({
                     x: 230, y: 120
                    , vx: .4, vy: -.1
                    , radius: 22
                    , mass: 8
                })
                , new Point({
                     x: 450, y: 520
                    , vx: .4, vy: -.1
                    , radius: 8
                    , mass: 8
                })
            )
        }

        this.dragging.add(...this.points)
        let d = this.saveButton = {
            label: "Save JSON"
            , onclick: (ev, proxySelf) =>{
                console.log('Save')
                this.saveJSON()
            }

        }
        addButton('save', d)

        addButton('restore', {
            label: "Restore JSON"
            , onclick: (ev, proxySelf) =>{
                console.log('restore')
                this.restoreJSON()
            }



================================================================================
END: json-example.js
================================================================================



================================================================================
FILE: label-example-2.js
================================================================================

/*
category: text
title: Label Example 2
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/text/alpha.js
    ../point_src/text/label.js
    ../point_src/text/beta.js
 */
let rotationPoint = new Point(300, 300)


class MainStage extends Stage {
    canvas = 'playspace'
    rot = 0

    mounted(){

        // let t = new TextAlpha(ctx, 'Bananas')
        // t.position = new Point(100, 100)
        // t.writeText('red')
        let h = new Label(this.ctx, {
            fontSize: 30
            , text: "Greek delta: \u03B4" // &#x03B4;
            // , textAlign: "center"
            , fontName: '"lexend deca"'
        })


        h.position = new Point(300, 300, 10, 30)
        this.textA = h;

        this.pointA = new Point(200, 300, 10, 20)
        this.pointB = new Point(230, 330, 10, 20)
    }

    draw(ctx){

        this.clear(ctx)

        let p = new Point(300, 300)
        // p.pen.circle(ctx)
        //&#10763;    &#x2A0B;
        this.pointA.text.plain(ctx, 'Summation with Integral: \u2A0B')

        // this.pointA.text.plain(ctx, '&#x2A0B;')
        let h = this.textA
        h.draw(ctx)
        h.writeText(ctx)
        h.position.pen.indicator(ctx, { color: 'white'})
    }

}


;stage = MainStage.go()

================================================================================
END: label-example-2.js
================================================================================



================================================================================
FILE: label-example.js
================================================================================

/*
category: text
title: Label Example
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/text/alpha.js
    ../point_src/text/label.js
 */
let rotationPoint = new Point(300, 300)


class MainStage extends Stage {
    canvas = 'playspace'
    rot = 0

    mounted(){
        let l = new Label(this.ctx, {
            text: 'Milkshake before breakfast.'
            , fontSize: 16
            , fontName: 'barlow'
            // , fontName: 'Arial'
            // , fillStyle: 'green'
        })
        l.position = new Point(100, 100)
        l.position.rotation = 45 // l.position.radians % Math.PI

        this.l = l

        // let t = new Text(ctx, 'Bananas')
        // t.position = new Point(100, 100)
        // t.writeText('red')
        let h = new Label(this.ctx, {
            fontSize: 50
            , text: "Large eyebrows"
            , textAlign: "center"
            , fontName: '"lexend deca"'
        })

        h.fillStyle = 'orange'
        h.position = new Point(300, 300)
        this.logo = h;
    }

    draw(ctx){

        this.clear(ctx)

        let p = new Point(300, 300)
        p.pen.circle(ctx)

        this.l.draw(ctx)
        this.l.position.pen.indicator(ctx, { color: 'orange'})

        let h = this.logo
        h.writeText(ctx)
        h.position.pen.indicator(ctx, { color: 'white'})
    }

    generateGrad(ctx, pos, width, fontSize) {
        let gradient = ctx.createLinearGradient(pos.x, pos.y, width, fontSize)

        gradient.addColorStop(0,"hsl(299deg 62% 44%)");
        gradient.addColorStop(1,"hsl(244deg 71% 56%)");
        return gradient
    }

    writeText(ctx, words, pos, fontSize, fillStyle){
        ctx.font = `500 ${fontSize}px lexend deca`;
        ctx.letterSpacing  = `${fontSize*.333}px`;
        // ctx.letterSpacing  = `.335em`;
        ctx.fillStyle = fillStyle;
        ctx.fillText(words, pos.x, pos.y);
    }
}


;stage = MainStage.go()

================================================================================
END: label-example.js
================================================================================



================================================================================
FILE: leash-track-points.js
================================================================================

/*
title: One-way Leash
categories: constraints
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/constrain-distance.js
---

A point can "track" or "leash" to another point. In this setup it works in
one-direction. Where the _locked point_ can pull the secondary point, but will
stay locked when pulled.

+ `leash()` ensures the secondary point is _within_ a set distance.
+ `track()` locks the secondary point at a target distance.

*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point(250, 150, 10)
            , new Point(400, 320, 7)
            , new Point(450, 520,  10)
            , new Point(490, 490,  7)
        )

        this.dragging.add(...this.points)
    }

    draw(ctx){
        this.clear(ctx)

        let mouse = Point.mouse.position

        // point[3] _tracks_ point[2]
        this.points[3].track(this.points[2], 200)
        // point[1] _leashes to_ point[0]
        this.points[1].leash(this.points[0], 200)

        this.points[1].pen.indicator(ctx)
        this.points[3].pen.indicator(ctx)

        this.points[0].pen.fill(ctx, '#33aadd')
        this.points[2].pen.fill(ctx, '#33aadd')

    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: leash-track-points.js
================================================================================



================================================================================
FILE: lerp-curve-lines-2.js
================================================================================

/*
title: Lerp Curve Lines 2
categories: curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js


 */
class MainStage extends Stage {
    canvas='playspace'
    live = true
    mounted(){
                        // x, y, width, rotation
        this.pointA = new Point(150, 150, 100, 120)
        this.pointB = new Point(300, 400, 100) // default rotation == 0 (looking right)
        this.line = new BezierCurve(this.pointA, this.pointB)
        this.controlPointA = this.pointA.project()
        this.controlPointB = this.pointB.project()

        this.dragging.add(this.pointB, this.pointA,
                        this.controlPointA, this.controlPointB)

        this.controlPointA.onDragMove = this.updatePointsToControl.bind(this)
        this.controlPointB.onDragMove = this.updatePointsToControl.bind(this)

        this.lineStroke = new Stroke({
            color: 'green'
            , width: 2
            , dash: [7, 4]
        })

        this.indicator = new Point(344,344)
        this.startIndicatorT = this.indicatorT;
        this.startMousePos = this.indicator.copy();
                // The parameter 't' corresponding to the indicator's position on the curve
        this.indicatorT = 0.5; // Start in the middle of the curve

        // The point that will move along the curve
        this.indicator = new Point();

        // Update the indicator's position based on 'indicatorT'
        this.updateIndicatorPosition();
        this.events.wake()

    }


    xonMousemove(ev) {
        let p = this.mouse.position;
        let minDist = Infinity;
        let closestPoint = null;

        // Sample points along the Bezier curve
        let steps = 100;
        for (let i = 0; i <= steps; i++) {
            let t = i / steps;
            let oneMt = 1 - t;
            let omtp3 = Math.pow(oneMt, 3)
            let tpow3 = Math.pow(t, 3)
            let tpow2 = Math.pow(t, 2)
            let omtp2 = Math.pow(oneMt, 2)

            // Calculate the point on the cubic Bezier curve at parameter t
            let x =
                omtp3 * this.pointA.x +
                3 * omtp2 * t * this.controlPointA.x +
                3 * (oneMt) * tpow2 * this.controlPointB.x +
                tpow3 * this.pointB.x;

            let y =
                omtp3 * this.pointA.y +
                3 * omtp2 * t * this.controlPointA.y +
                3 * (oneMt) * tpow2 * this.controlPointB.y +
                tpow3 * this.pointB.y;

            let dx = p.x - x;
            let dy = p.y - y;
            let distSq = dx * dx + dy * dy;

            if (distSq < minDist) {
                minDist = distSq;
                closestPoint = { x: x, y: y };
            }


================================================================================
END: lerp-curve-lines-2.js
================================================================================



================================================================================
FILE: lerp-curve-lines.js
================================================================================

/*
title: Lerp Curve Lines
categories: curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
---

*/
const findNearestPoint = function(bezierStack, p, divisor=100) {

    let minDist = Infinity;
    let closestPoint = null;

    let pointA = bezierStack.line.a
    let pointB = bezierStack.line.b
    let controlPointA = bezierStack.controlPoints.a
    let controlPointB = bezierStack.controlPoints.b

    // Sample points along the Bezier curve
    for (let i = 0; i <= divisor; i++) {
        let t = i / divisor;
        let oneMt = 1 - t;
        let omtp3 = Math.pow(oneMt, 3)
        let tpow3 = Math.pow(t, 3)
        let tpow2 = Math.pow(t, 2)
        let omtp2 = Math.pow(oneMt, 2)

        // Calculate the point on the cubic Bezier curve at parameter t
        let x = omtp3 * pointA.x + 3
                * omtp2 * t * controlPointA.x + 3
                * (oneMt) * tpow2 * controlPointB.x
                + tpow3 * pointB.x
                ;

        let y = omtp3 * pointA.y + 3
                * omtp2 * t * controlPointA.y + 3
                * (oneMt) * tpow2 * controlPointB.y
                + tpow3 * pointB.y
                ;

        let dx = p.x - x;
        let dy = p.y - y;
        let distSq = dx * dx + dy * dy;

        if (distSq < minDist) {
            minDist = distSq;
            closestPoint = { x: x, y: y };
        }
    }

    return closestPoint
}


class MainStage extends Stage {
    canvas='playspace'
    live = true
    mounted(){
                        // x, y, width, rotation
        this.pointA = new Point(150, 150, 100, 120)
        this.pointB = new Point(300, 400, 100) // default rotation == 0 (looking right)
        this.line = new BezierCurve(this.pointA, this.pointB)
        this.controlPointA = this.pointA.project()
        this.controlPointB = this.pointB.project()

        this.dragging.add(this.pointB, this.pointA,
                        this.controlPointA, this.controlPointB)

        this.controlPointA.onDragMove = this.updatePointsToControl.bind(this)
        this.controlPointB.onDragMove = this.updatePointsToControl.bind(this)

        this.lineStroke = new Stroke({
            color: 'green'
            , width: 2
            , dash: [7, 4]
        })

        this.indicator = new Point(344,344)
        this.events.wake()
    }

    onMousemove(ev) {
        let p = this.mouse.position;


================================================================================
END: lerp-curve-lines.js
================================================================================



================================================================================
FILE: lerp-line.js
================================================================================

/*
---
title: Lerpy Lerpy Lerpingson
categories: curve
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/curve-extras.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/functions/within.js
    ../point_src/automouse.js
---

# Line LERP

Lerp a point along a straight line
*/

/*
    ---
    title: Lerpy Lerpy Lerpingson
    layout: post
    published-on: 1 January 2000
    tags:
        Line, Lerp, other
    related:
        lerp-curve-lines
    imports:
        lerp-line.html
    files:
        ../literal/path.js
    ---

    markdown content
*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted() {
        this.indicator = new Point({x: 300, y: 300}); // Start the draggable point somewhere
        this.a = new Point({x: 100, y: 100});
        this.b = new Point({x: 500, y: 500});

        this.dragging.add(this.a, this.b)
        this.line = new Line(this.a, this.b);

        this.stroke = new Stroke({
            color: '#eee',
            width: 1,
            dash: [7, 4]
        });

        this.events.wake();
    }

    onMousemove(ev) {
        let p = this.mouse.point;
        // let f = this.findNearestPoint(this.line, p)
        let f = this.line.findPoint(p)

        // Update the draggable point to the projection on the line
        this.indicator.set(f)
        // this.indicator.x = f.x;
        // this.indicator.y = f.y;
    }

    draw(ctx) {
        this.clear(ctx);

        // Draw the line
        this.stroke.set(ctx);
        this.line.render(ctx, { color: '#90000' });
        this.stroke.unset(ctx);

        // Draw the draggable point along the line
        this.indicator?.pen.fill(ctx, 'green');
    }
};



const findNearestPoint = function(line, point) {
    /* Find the point along the line of which is _closest_ to the given
    point. */

    let b = line.b
    let a = line.a


================================================================================
END: lerp-line.js
================================================================================



================================================================================
FILE: lerp-map-1.js
================================================================================

/*
title: Lerp Mapping.
categories: lerp
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
---

An example of _pure lerp mapping_ without any polypoint Lerp tools.
The `StaticLerpMap` hosts its own set of values for all points.

*/

class LerpMap {
    constructor(conf) {
        this.conf = conf
    }

    start() {
        /* A _wake_ with a begin. allowing _Step_ to function */
    }

    step() {
        /*
        iter all points in A, lerping B.
         */
    }

}

class StaticLerpMap extends LerpMap {

    start() {
        /* Copy to the largest. */
        let a = this.conf.start
        let b = this.conf.end
        let m = Math.max(this.conf.start.length, b.length)
        // this.lerps = new Array(m)
        this.lerps = Array.from({length:m}, (u,i) => {
                return {
                    _from: a[i]
                    , _to: b[i]
                    , x: { _from: a[i].x, _to: b[i].x, step: 0 }
                    , y: { _from: a[i].y, _to: b[i].y, step: 0 }
                    , radius: { _from: a[i].radius, _to: b[i].radius, step: 0 }
                }
        })
        // console.log(this.lerps)
        this.seconds = 5
        this.currentTime = 0
    }

    step() {
         let spl = 1 / (60 * this.seconds)
         this.currentTime += spl
         this.lerps.forEach((o, i)=>{
            o.x.step = this.currentTime
            o.y.step = this.currentTime
            o.radius.step = this.currentTime
        })
    }
}
/* A static lerp stores a _Value_ for all vars. */

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let count = 30
        this.a = PointList.generate.random(count, [300,300, 10, 0], [100, 100, 1, 1])
        this.b = PointList.generate.random(count, [400,400, 10, 0], [400, 100, 1, 1])
        this.c = PointList.generate.random(count)

        let lm = this.lerpMap = new StaticLerpMap({
            start: this.a
            , end: this.b
        })

        lm.start()
    }

    draw(ctx) {
        this.clear(ctx)
        this.b.pen.fill(ctx, 'purple')
        this.a.pen.fill(ctx, 'green')
        this.lerpMap.step()

        const lerps = this.lerpMap.lerps
        let commonVal = new Value()
        commonVal.doneStop = true
        commonVal.setEasing(quarticEaseInOut)



================================================================================
END: lerp-map-1.js
================================================================================



================================================================================
FILE: lerp-point-custom-easing.js
================================================================================

/*
title: Lerp Mapping.
categories: lerp
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
    ../theatre/apple-motion-algo.js
---

An example of _pure lerp mapping_ without any polypoint Lerp tools.
The `StaticLerpMap` hosts its own set of values for all points.

The stepMotion function:

```js
(t)=>stepMotion(t, .01, 0.5, .6, 8)
```

+ **t**: time delta: 0-1
+ anticipation: `.1`
+ midpoint: `.5`
+ oscilation: `.1`
+ damping: `.1`

*/


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let count = 30
        this.point = new Point(200, 200)
        this.a = new Point(100, 100)
        this.b = new Point(500, 500)
        let commonVal = this.commonVal = new Value()
        commonVal.doneStop = true
        this.currentTime = 0
        this.seconds = 1
        commonVal.setEasing((t)=>stepMotion(t, .01, 0.5, .6, 8))
    }
    onclick(e) {
        console.log(arguments)
        this.a = this.point.copy()
        this.b = Point.from(e)
        this.currentTime = 0
    }
    draw(ctx) {
        this.clear(ctx)

        let spl = 1 / (60 * this.seconds)
        this.point.pen.fill(ctx, 'green')

        let p = this.point;
        let k = 'x'
        let a = this.a;
        let b = this.b;
        let l = this.currentTime += spl
        p.x = this.commonVal.pluck(a.x, b.x, l)
        p.y = this.commonVal.pluck(a.y, b.y, l)

        this.a.pen.fill(ctx, '#880000')


    }

}



;stage = MainStage.go();

================================================================================
END: lerp-point-custom-easing.js
================================================================================



================================================================================
FILE: lerp-pointlist-through-2.js
================================================================================

/*
title: PointList Lerper method
categories: lerp
files:
    head
    pointlist
    point
    stage
    mouse
    stroke
    ../point_src/random.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
    ../theatre/apple-motion-algo.js
---

In this example, we use the `PointList.lerper.through(a, b)`, but edit one of
the elements.

Importantly the settings for the lerper must be static, else updates to the
_current time_ of a unique node is forgotten.
*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let count = 50
        this.a = PointList.generate.random(count, [200,350, 20, 200], [60, 150, 1, 1])
        this.b = PointList.generate.radius({count: count, offset: {radius:3}}, 140, new Point(500, 300))
        this.c = PointList.generate.random(count)

        addButton('button', {
            label: 'reset'
            , onclick() {
                console.log('click')
                stage.c.lerper.currentTime = 0
            }
        })

        this.persistentLerperSettings = {
            seconds: 3
            , easing: quadEaseOut
            , 10: {
                // easing: exponentialEaseInOut
                // easing: { x: exponentialEaseInOut, y: bounceEaseOut }
                // easingX: exponentialEaseInOut
                easing: (t)=>stepMotion(t, .1, 0.8, 4, 3)
                // , seconds: .7
                 , delay: 2.6
                 // , currentTime: -(2.6/.7)
            }
        }
    }


    resetTime() {
        /*Relay the time to 0*/
        this.currentTime = 0
    }


    draw(ctx) {
        this.clear(ctx)

        this.a.pen.indicator(ctx, 'green')
        this.b.pen.indicator(ctx, {color:'#333'})

        this.c.lerper.through(this.a, this.b, this.persistentLerperSettings)
        this.c.pen.indicator(ctx, {color:'purple'})
        this.c[10].pen.fill(ctx, {color:'purple'})
    }
}


;stage = MainStage.go();

================================================================================
END: lerp-pointlist-through-2.js
================================================================================



================================================================================
FILE: lerp-pointlist-through-3.js
================================================================================

/*
title: PointList Lerper method
categories: lerp
files:
    head
    pointlist
    point
    stage
    mouse
    stroke
    ../point_src/random.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
    ../theatre/apple-motion-algo.js
---

In this example, we use the `PointList.lerper.through(a, b)` but all node
delays and timing are slightly altered.

We also edit the last node to be _late_ (for fun.)
*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let count = 400
        this.a = PointList.generate.random(count, [200,350, 20, 200], [60, 150, 1, 1])
        this.b = PointList.generate.grid(count, ~~Math.sqrt(count), 20, new Point(300, 300))
        // this.b = PointList.generate.radius({count: count, offset: {radius:3}}, 140, new Point(500, 300))
        this.c = PointList.generate.random(count)

        let s = this.persistentLerperSettings = {
            seconds: 5
            // , easing: this.customEasing({ oscilation: [1,3]})
            , easing: exponentialEaseInOut
            // , easing: bounceEaseOut
            // , 10: this.createChunk()
            , randomizeShape: {
                delay: [1, 2]
                // , seconds: [.4, 1]
            }
        }

        this.c.lerper.setup(s)

        let one = s[40]
        // one.delay = 3.5
        // one.easing = quadEaseOut
        // one.seconds = .7
        // one.currentTime = -(one.delay/one.seconds)
        let delay = 6.5
        let easing = this.customEasing({ oscilation: [1,2], anticipation: [.3,.5]})
        let seconds = .4
        Object.assign(one, this.c.lerper.genChunk(seconds, delay, easing))

    }

    customEasing(shape){
        let fl = function(pair, defaultPair) {
            if(pair == undefined){pair=defaultPair}
            return random.float(pair[0], pair[1])
        }

        let anticipation = fl(shape.anticipation, [.1, .2])
            , midpoint = fl(shape.midpoint, [.6, 0.8])
            , oscilation = fl(shape.oscilation, [3,4])
            , damping = fl(shape.damping, [2, 8])
            , defaultEasing = (t) => stepMotion(t, anticipation, midpoint, oscilation, damping)
            ;

        return defaultEasing
    }

    draw(ctx) {
        this.clear(ctx)

        // this.a.pen.indicator(ctx, 'green')
        // this.b.pen.indicator(ctx, {color:'#333'})

        this.c.lerper.through(this.a, this.b, this.persistentLerperSettings)
        // this.c.pen.indicator(ctx, {color:'purple'})
        this.c.pen.fill(ctx, {color:'purple'})
    }
}


Polypoint.head.installFunctions('PointListLerper', {
    /* PointList lerper randomise addons, allowing the _settings_ and composition
    of randomize seconds and delays per node. */

    setup(settings={}) {
        /* store the settings into the lerper instance.

        This is required if the settings are randomised, as the _currentTime_
        for each unit is stored uniquely. If the storage of that object is
            not persistent, the updates wont persist though draw cycles.
        */
        this._settings = settings
        if(settings.randomizeShape){


================================================================================
END: lerp-pointlist-through-3.js
================================================================================



================================================================================
FILE: lerp-pointlist-through-4.js
================================================================================

/*
title: PointList Lerper method
categories: lerp
files:
    head
    pointlist
    point
    stage
    mouse
    stroke
    ../point_src/random.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
    ../theatre/apple-motion-algo.js
---

In this example, we use the `PointList.lerper.through(a, b)` but all node
delays and timing are slightly altered.

We also edit the last node to be _late_ (for fun.)
*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let count = 80
        this.a = PointList.generate.random(count, [300,300, 2, 200], [60, 150, 0, 1])
        // this.a = PointList.generate.grid(count, ~~Math.sqrt(count), 20, new Point(300, 300))
        // this.a.each.x = this.center.x
        // this.a.each.y = this.center.y
        // this.b = PointList.generate.grid(count, ~~Math.sqrt(count), 20, new Point(300, 300))
        this.b = PointList.generate.radius({
                        count: count
                        , multiplier: [0, 0, 0, 0]
                        , offset: {radius:5}
                    }, 140, this.center.copy()
                )
        this.c = PointList.generate.random(count)
        this.c.each.color = ()=>random.color([220, 221], [70, 94], [40, 80])

        let s = this.persistentLerperSettings = {
            seconds: 4
            // , easing: this.customEasing({ oscilation: [0,1]})
            , easing: exponentialEaseInOut
            // , easing: bounceEaseOut
            // , easing: elasticEaseOut
            // , easing: backEaseOut
            // , 10: this.createChunk()
            , randomizeShape: {
                delay: [0,3]
                , seconds: [3,6]
            }
        }

        this.c.lerper.setup(s)

        // let one = s[40]
        // one.delay = 3.5
        // one.easing = quadEaseOut
        // one.seconds = .7
        // one.currentTime = -(one.delay/one.seconds)
        // let delay = 6.5
        // let easing = this.customEasing({ oscilation: [1,2], anticipation: [.3,.5]})
        // let seconds = .4
        // Object.assign(one, this.c.lerper.genChunk(seconds, delay, easing))

    }

    customEasing(shape){
        let fl = function(pair, defaultPair) {
            if(pair == undefined){pair=defaultPair}
            return random.float(pair[0], pair[1])
        }

        let anticipation = fl(shape.anticipation, [.1, .2])
            , midpoint = fl(shape.midpoint, [.6, 0.8])
            , oscilation = fl(shape.oscilation, [3,4])
            , damping = fl(shape.damping, [2, 8])
            , defaultEasing = (t) => stepMotion(t, anticipation, midpoint, oscilation, damping)
            ;

        return defaultEasing
    }

    draw(ctx) {
        this.clear(ctx)

        // this.a.pen.indicator(ctx, 'green')
        // this.b.pen.indicator(ctx, {color:'#333'})

        this.c.lerper.through(this.a, this.b, this.persistentLerperSettings)
        // this.c.pen.indicator(ctx, {color:'purple'})
        this.c.pen.fill(ctx)
    }
}


Polypoint.head.installFunctions('PointListLerper', {
    /* PointList lerper randomise addons, allowing the _settings_ and composition


================================================================================
END: lerp-pointlist-through-4.js
================================================================================



================================================================================
FILE: lerp-pointlist-through.js
================================================================================

/*
title: PointList Lerper method
categories: lerp
files:
    head
    pointlist
    point
    stage
    mouse
    stroke
    ../point_src/random.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
    ../theatre/apple-motion-algo.js
---

In this example, we use the `PointList.lerper.through(a, b)` to lerp all the points

    points.lerper.through(
        startPositions
        , endPositions
        , {seconds: 5}
    )
*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let count = 50
        this.a = PointList.generate.random(count, [200,350, 20, 200], [60, 150, 1, 1])
        this.b = PointList.generate.radius({count: count, offset: {radius:3}}, 140, new Point(500, 300))
        this.c = PointList.generate.random(count)
    }

    draw(ctx) {
        this.clear(ctx)

        this.a.pen.indicator(ctx, 'green')
        this.b.pen.indicator(ctx, {color:'#333'})

        this.c.lerper.through(this.a, this.b, {
            seconds: 3
            , easing: quadEaseOut
        })

        this.c.pen.indicator(ctx, {color:'purple'})
    }
}


;stage = MainStage.go();

================================================================================
END: lerp-pointlist-through.js
================================================================================



================================================================================
FILE: lerp-pointlist-value-only.js
================================================================================

/*
title: Raw PointList Lerping
categories: lerp
files:
    head
    pointlist
    point
    stage
    mouse
    ../point_src/random.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
---

Lerp points C without affecting points A or B, using a single `Value()` instance.
*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let count = 50
        // this.a = PointList.generate.grid(count, 10, 20,  new Point(200, 200))
        this.a = PointList.generate.random(count, [200,350, 10, 0], [60, 150, 1, 1])
        this.b = PointList.generate.radius(count, 140, new Point(500, 300))
        // this.b = PointList.generate.random(count, [400,400, 10, 0], [300, 100, 1, 1])
        this.c = PointList.generate.random(count)
        this.currentTime = 0
        this.seconds = 4

        let commonVal = this.commonVal = new Value()
        commonVal.doneStop = true
        commonVal.setEasing(quarticEaseInOut)
    }

    draw(ctx) {
        this.clear(ctx)

        this.a.pen.fill(ctx, 'green')
        this.b.pen.fill(ctx, '#333')

        let spl = 1 / (60 * this.seconds)
        let lerpKeys = ['x', 'y', 'radius']
        let commonVal = this.commonVal
        let lerps = this.lerps
        let pa = this.a
        let pb = this.b

        let l = this.currentTime += spl

        this.c.forEach((p,i)=> {
            let a = pa[i]
            let b = pb[i]

            lerpKeys.forEach(k=>{
                p[k] = commonVal.pluck(a[k], b[k], l)
            })
        })

        this.c.pen.fill(ctx, 'purple')
    }
}

;stage = MainStage.go();

================================================================================
END: lerp-pointlist-value-only.js
================================================================================



================================================================================
FILE: limit-projection.js
================================================================================

/*
title: Limited Projection
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/automouse.js




class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 10, this.compass.right)
        this.limitPoint = new Point(500, 200, 10, this.compass.up)
        this.dragging.add(this.point)
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.indicator(ctx)
        this.limitPoint.pen.indicator(ctx)
    }
}

stage = MainStage.go()
*/

class MainStage extends Stage {
    canvas = 'playspace'

    mounted() {
        this.point = new Point(350, 300, 10, this.compass.right)
        this.limitPointA = new Point(100, 100, 10, this.compass.up + 90)
        this.limitPointB = new Point(700, 100, 10, this.compass.up + -10)
        this.dragging.add(this.point, this.limitPointA, this.limitPointB)
    }

    draw(ctx) {
        this.clear(ctx)
        this.point.lookAt(this.mouse.position)
        this.point.pen.indicator(ctx)
        this.limitPointA.pen.indicator(ctx)
        this.limitPointB.pen.indicator(ctx)

        // Calculate the endpoint of the projected line
        let endPoint = this.calculateLineEndpoint(
            this.point,
            this.limitPointA
        )

        if(endPoint == Infinity) {
            /* reverse direction projected inverse to the stage edge.*/
            // endPoint = this.point.project(100)
            // endPoint = this.calculateLineEndpoint(
            //     this.point,
            //     {x:800, y:800}
            // )
            endPoint = this.calculateLineEndpoint(
                this.point,
                this.limitPointB
            )
        }

        // Draw the projected line
        ctx.beginPath()
        ctx.moveTo(this.point.x, this.point.y)
        ctx.lineTo(endPoint.x, endPoint.y)
        ctx.strokeStyle = 'yellow'
        ctx.stroke()
    }

    calculateLineEndpoint(a, b) {
        let [x0, y0, theta0] = [a.x, a.y, a.radians]
        let [limitX, limitY, thetaLim] = [b.x, b.y, b.radians]
        const cosTheta0 = Math.cos(theta0)
        const sinTheta0 = Math.sin(theta0)
        const cosThetaLim = Math.cos(thetaLim)
        const sinThetaLim = Math.sin(thetaLim)
        let D = sinTheta0 * cosThetaLim - cosTheta0 * sinThetaLim

        if (Math.abs(D) < 1e-10) {
            return Infinity // Lines are parallel; no intersection
        }


================================================================================
END: limit-projection.js
================================================================================



================================================================================
FILE: line-animated-curvy-arrows.js
================================================================================

/*
title: Line Animated Curvy Arrows
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../others/curve_src/curve.js
    ../point_src/extras.js
    ../point_src/curve-extras.js
    ../point_src/iter/alpha.js
    ../point_src/setunset.js
    ../point_src/stroke.js

 */
var riter = new Iter(100, .02, 20)
var riter2 = new Iter(70, .03, 30)
var rotiter = new Iter(90, .04, 90)
var yiter = new Iter(250, .03, 150)

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'
    tick = 0
    mounted(){
        this.curvyLineA = new BezierCurve(...this.pointPair())
    }

    pointPair() {
        let cumX = 0
            , cumOffset = 200
            , globalY = 100
            , offset = ()=> cumX+=cumOffset
            , c = this.compass
            ;

        let ps = new PointList(
            new Point({
                name: "a"
                // , rotation: c.right + 45
                , modulusRotate: false
                , x: offset()
                , y: globalY
                , radius: riter
                , rotation: riter2
            })
            , new Point({
                name: "b"
                , modulusRotate: false
                // , modulusRotate: true
                , rotation: rotiter
                , x: offset()
                // , y: globalY + 50
                , y: yiter
                , radius: riter
            })
        )

        return ps;
    }

    draw(ctx){
        this.clear(ctx)
        this.curvyLineA.points.pen.indicators(ctx, {color: '#444'})
        this.curvyLineA.render(ctx, { width: 2, color: '#8f08d5'})
        this.tick += 1
        riter.step(this.tick)
        // this.curvyLineA.b.rotation = rotiter.step(this.tick)
        rotiter.step(this.tick*.4)
        riter2.step(this.tick)
        yiter.step(this.tick*.5)
    }

}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: line-animated-curvy-arrows.js
================================================================================



================================================================================
FILE: line-arrow.js
================================================================================

/*
title: Line Arrow
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../others/curve_src/curve.js
    ../point_src/extras.js
    ../point_src/curve-extras.js
    ../point_src/iter/alpha.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/catenary-curve.js
    ../point_src/distances.js
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        let cumX = 0
            , cumOffset = 120
            , globalY = 100
            , offset = ()=> cumX+=cumOffset
            , c = this.compass
            ;

        this.points = new PointList(
            new Point({
                name: "a"
                , rotation: c.right
                , x: offset(), y: globalY
            })
            , new Point({
                name: "b"
                , rotation: c.left // RIGHT_DEG
                , x: offset(), y: globalY + 50
            })
        )

        this.points.setMany(20, 'radius');

        this.line = new Line([100, 200], [200, 200], 'green', 2)
        this.curvyLine = new BezierCurve(...this.points)
        this.cantenary = new CantenaryCurve(...this.points)
        // this.cantenary.sine = 30
        this.cantenary.restLength = 140

        this.tick = 0
    }


    draw(ctx){
        this.clear(ctx)

        // this.curvyLine.render(ctx)
        this.line.render(ctx)

        this.drawCantenary(ctx)
        // this.drawPoints(ctx)
        // this.drawRandomLine(ctx)

        // if(this.tick % 2 == 0
        //     && cantenary.sine > .1) {
        //     cantenary.sine *= cantenary.reductionRate
        //     cantenary.length = cantenary._restLength + (Math.sin(this.tick * cantenary.bounceRate) * cantenary.sine)
        // }

        /* Draw a line from the point, projected from the center (by 1)*/
        // let pLine = new Line(this.points[0].project(), this.points[1].project(), 'pink', 1)
        // pLine.draw(ctx)

        // this.drawCurvyLine(ctx)
        this.tick += 1
    }

    drawCantenary(ctx) {
        let cantenary = this.cantenary;

        cantenary.render(ctx)

        let tail = new Point(cantenary.b)
        let tailNode = this.drawArrowTip(ctx, tail)

        // tailNode.pen.indicator(ctx, {color: 'green'})

        let tip = new Point(cantenary.a)
        let tipNode = this.drawArrowTail(ctx, tip)

        if(this.tick % 1 == 0) {
            cantenary.update(this.tick)
        }
    }



================================================================================
END: line-arrow.js
================================================================================



================================================================================
FILE: line-connected-main.js
================================================================================

/*
title: Line Connected Main
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    stroke
    ../point_src/catenary-curve.js
*/

/* moved to line/Line */
class Line {
    constructor(p1, p2, color='red', width=1){
        // new Line([90, 130], [200, 300], 420)
        this.create.apply(this, arguments)
    }

    create(p1, p2, color='red', width=1) {
        this.a = point(p1)
        this.b = point(p2)
        this.color = color
        this.width = width
    }

    render(ctx) {
        this.start(ctx)
        this.draw(ctx)
        this.close(ctx)
    }

    start(ctx) {
        ctx.beginPath();
        let a = this.a;
        ctx.moveTo(a[0], a[1])
    }

    draw(ctx, color=undefined) {
        ctx.strokeStyle = color == undefined? this.color: color
        ctx.lineWidth = this.width == undefined? 1: this.width
        this.perform(ctx)

        ctx.stroke()
    }


    perform(ctx) {
        let b = this.b;
        ctx.lineTo(b[0], b[1])
    }

    close(ctx) {
        ctx.closePath()
    }
}

/* moved to curvy-line */
class BezierCurve extends Line {

    // create(p1, p2, color='red', width=1) {
    // }

    getControlPoints() {
        let a = this.a
          , b = this.b
          ;
        let midDistance = a.distanceTo(b)*.5
        let offset = this.offset == undefined? 0: this.offset

        /*A bezier requires two control points */
        return [
              a.project(midDistance + offset)
            , b.project(midDistance + offset)
        ]

    }

    perform(ctx) {
        let b = this.b;
        let cps = this.getControlPoints()
        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/bezierCurveTo
        let bp = b
        ctx.bezierCurveTo(cps[0].x, cps[0].y, cps[1].x, cps[1].y, bp.x, bp.y)
    }
}


class CantenaryCurve extends Line {

    create(a,b, length=undefined, color='red', width=1) {
        super.create(a,b,color,  width)
        this.length = length
    }

    getCurveLength(a, b) {
        let l = this.length
        if(l == undefined){
            return distance(a, b) * 1.5


================================================================================
END: line-connected-main.js
================================================================================



================================================================================
FILE: line-rider-a.js
================================================================================

/*
title: Line Rider
src_dir: ../point_src/
files:
    ../point_src/core/head.js
    ../point_src/stage.js
    ../point_src/point-content.js
    ../point_src/point.js
---

A simple example of gear-like rotations
*/

class Ball {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.vx = 0; // Horizontal velocity
    this.vy = 0; // Vertical velocity
    this.gravity = 0.2; // Gravity strength
    this.friction = 0.8; // Friction to simulate rolling resistance
  }

  applyGravity() {
    this.vy += this.gravity;
  }

  update(centerX, centerY, boundaryRadius) {
    // Apply gravity
    this.applyGravity();

    // Update position
    this.x += this.vx;
    this.y += this.vy;

    // Calculate distance from center
    const dx = this.x - centerX;
    const dy = this.y - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // If the ball exceeds the boundary, constrain it
    const maxDistance = boundaryRadius - this.radius;
    if (distance > maxDistance) {
      // Project the ball back onto the circle's inner edge
      const angle = Math.atan2(dy, dx)
      this.x = centerX + Math.cos(angle) * maxDistance;
      this.y = centerY + Math.sin(angle) * maxDistance;

      // Reflect velocity along the tangent (simulate rolling)
      const normalAngle = angle;
      const tangentAngle = (normalAngle - Math.PI)

      // Decompose velocity
      const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
      this.vx = Math.cos(tangentAngle) * speed * this.friction;
      this.vy = Math.sin(tangentAngle) * speed * this.friction;
    }
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = 'blue';
    ctx.fill();
    ctx.stroke();
  }
}

class CircleBoundary {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

// Initialize ball and boundary
const boundary = new CircleBoundary(300, 300, 150);
const ball = new Ball(50, 180, 10);

function draw(ctx) {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  // Update ball movement
  ball.update(boundary.x, boundary.y, boundary.radius);

  // Draw boundary and ball
  boundary.draw(ctx);
  ball.draw(ctx);

  requestAnimationFrame(() => draw(ctx));


================================================================================
END: line-rider-a.js
================================================================================



================================================================================
FILE: line-rider-draggable.js
================================================================================

/*
title: Line Rider
src_dir: ../point_src/
files:
    ../point_src/core/head.js
    ../point_src/stage.js
    ../point_src/point-content.js
    ../point_src/point.js
---

A simple example of gear-like rotations
*/

class Ball {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.vx = 0; // Horizontal velocity
    this.vy = 0; // Vertical velocity
    this.gravity = 0.3; // Gravity strength
    this.friction = 0.995; // Friction to simulate rolling resistance
    this.bounceFactor = 0.7; // Coefficient of restitution (bounciness)
  }

  applyGravity() {
    this.vy += this.gravity;
  }

  update(centerX, centerY, boundaryRadius, boundaryVx, boundaryVy) {
    // Apply gravity
    this.applyGravity();

    // Update position
    this.x += this.vx;
    this.y += this.vy;

    // Calculate distance from center
    const dx = this.x - centerX;
    const dy = this.y - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // If the ball exceeds the boundary, constrain it
    const maxDistance = boundaryRadius - this.radius;
    if (distance > maxDistance) {
      // Project the ball back onto the circle's inner edge
      const angle = Math.atan2(dy, dx);
      this.x = centerX + Math.cos(angle) * maxDistance;
      this.y = centerY + Math.sin(angle) * maxDistance;

      // Decompose velocity into normal and tangent components
      const normalVelocity = (this.vx * Math.cos(angle)) + (this.vy * Math.sin(angle));
      const tangentVelocity = (-this.vx * Math.sin(angle)) + (this.vy * Math.cos(angle));

      // Apply bounce to the normal velocity and add boundary's velocity
      const bouncedNormalVelocity = -normalVelocity * this.bounceFactor;
      const combinedVx = boundaryVx * this.bounceFactor;
      const combinedVy = boundaryVy * this.bounceFactor;

      // Combine velocities
      this.vx = Math.cos(angle) * (bouncedNormalVelocity + combinedVx) - Math.sin(angle) * tangentVelocity * this.friction;
      this.vy = Math.sin(angle) * (bouncedNormalVelocity + combinedVy) + Math.cos(angle) * tangentVelocity * this.friction;
    }
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = 'blue';
    ctx.fill();
    ctx.stroke();
  }
}

class CircleBoundary {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.previousX = x;
    this.previousY = y;
    this.vx = 0; // Velocity in x direction
    this.vy = 0; // Velocity in y direction
    this.dragging = false;
  }

  startDrag(mouseX, mouseY) {
    const dx = mouseX - this.x;
    const dy = mouseY - this.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance <= this.radius) {
      this.dragging = true;
    }
  }

  drag(mouseX, mouseY) {
    if (this.dragging) {
      this.previousX = this.x;
      this.previousY = this.y;
      this.x = mouseX;


================================================================================
END: line-rider-draggable.js
================================================================================



================================================================================
FILE: line-rider-good.js
================================================================================

/*
title: Line Rider
src_dir: ../point_src/
files:
    ../point_src/core/head.js
    ../point_src/stage.js
    ../point_src/point-content.js
    ../point_src/point.js
---

A simple example of gear-like rotations
*/

class Ball {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.vx = 0; // Horizontal velocity
    this.vy = 0; // Vertical velocity
    this.gravity = 0.3; // Gravity strength
    this.friction = 0.9999; // Friction to simulate rolling resistance
  }

  applyGravity() {
    this.vy += this.gravity;
  }

  update(centerX, centerY, boundaryRadius) {
    // Apply gravity
    this.applyGravity();

    // Update position
    this.x += this.vx;
    this.y += this.vy;

    // Calculate distance from center
    const dx = this.x - centerX;
    const dy = this.y - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // If the ball exceeds the boundary, constrain it
    const maxDistance = boundaryRadius - this.radius;
    if (distance > maxDistance) {
      // Project the ball back onto the circle's inner edge
      const angle = Math.atan2(dy, dx);
      this.x = centerX + Math.cos(angle) * maxDistance;
      this.y = centerY + Math.sin(angle) * maxDistance;

      // Decompose velocity into normal and tangent components
      const normalVelocity = (this.vx * Math.cos(angle)) + (this.vy * Math.sin(angle));
      const tangentVelocity = (-this.vx * Math.sin(angle)) + (this.vy * Math.cos(angle));
      const tangentAngle = angle

      // Cancel normal velocity to prevent bouncing and apply friction to tangent velocity
      this.vx = -tangentVelocity * Math.sin(tangentAngle) * this.friction;
      this.vy = tangentVelocity * Math.cos(tangentAngle) * this.friction;
    }
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = 'blue';
    ctx.fill();
    ctx.stroke();
  }
}

class CircleBoundary {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

// Initialize ball and boundary
const boundary = new CircleBoundary(300, 300, 150);
const ball = new Ball(300, 180, 10);

function draw(ctx) {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  // Update ball movement
  ball.update(boundary.x, boundary.y, boundary.radius);

  // Draw boundary and ball
  boundary.draw(ctx);
  ball.draw(ctx);

  requestAnimationFrame(() => draw(ctx));


================================================================================
END: line-rider-good.js
================================================================================



================================================================================
FILE: line-rider-splits.js
================================================================================

/*
---
title: Split
categories: split
    curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
*/
class MainStage extends Stage {
    canvas='playspace'
    live = true
    
    mounted(){
        this.count = 80
        let lpoints4 = [new Point(200, 300, 300, 90), new Point(800, 400, 200, 100)]
        this.curve2 = new BezierCurve(...lpoints4)
        this.dragging.add( ...lpoints4)
        
        // Ball setup
        this.ball = new Point({
            x: 400,
            y: 100,
            radius: 15,
            vx: 0,
            vy: 0
        })
        
        // Physics constants
        this.gravity = 0.05
        this.damping = 0.7  // Reduce bounce by 30% each collision
        this.dragging.add(this.ball)
    }

    draw(ctx){
        this.clear(ctx)

        // Apply gravity to ball
        this.ball.vy += this.gravity
        this.ball.x += this.ball.vx
        this.ball.y += this.ball.vy

        this.curve2.render(ctx, {color: '#777'})
        let normals = this.curve2.split(this.count,  0)

        normals.each.radius = 10
        normals.pen.lines(ctx, 'green', 2)
        
        // Create and draw ray projecting in direction of velocity
        let rayLength = 100
        let rayStart = new Point(this.ball.x, this.ball.y)
        
        // Calculate ray direction from velocity (or default to downward if no velocity)
        let velocityMag = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy)
        let rayDirX, rayDirY
        
        if (velocityMag > 0.01) {
            // Ray points in direction of velocity
            rayDirX = this.ball.vx / velocityMag
            rayDirY = this.ball.vy / velocityMag
        } else {
            // Default to pointing downward if ball is stationary
            rayDirX = 0
            rayDirY = 1
        }
        
        let rayEnd = new Point(
            this.ball.x + rayDirX * rayLength,
            this.ball.y + rayDirY * rayLength
        )
        
        ctx.strokeStyle = 'red'
        ctx.lineWidth = 2
        // ctx.beginPath()
        // ctx.moveTo(rayStart.x, rayStart.y)
        // ctx.lineTo(rayEnd.x, rayEnd.y)
        // ctx.stroke()
        
        // Detect nearby normals along the ray path
        // First, find the closest normal point to use as the origin for sampling
        let closestNormal = null
        let minDist = Infinity
        


================================================================================
END: line-rider-splits.js
================================================================================



================================================================================
FILE: line-rider.js
================================================================================

/*
title: Line Rider
src_dir: ../point_src/
files:
    ../point_src/core/head.js
    ../point_src/stage.js
    ../point_src/point-content.js
    ../point_src/point.js
---

A simple example of gear-like rotations
*/


class Ball {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.vx = 0; // Horizontal velocity
    this.vy = 0; // Vertical velocity
    this.gravity = 0.3; // Gravity strength
    this.friction = 0.995; // Friction to simulate rolling resistance
    this.bounceFactor = 0.7; // Coefficient of restitution (bounciness)
  }

  applyGravity() {
    this.vy += this.gravity;
  }

  update(centerX, centerY, boundaryRadius) {
    // Apply gravity
    this.applyGravity();

    // Update position
    this.x += this.vx;
    this.y += this.vy;

    // Calculate distance from center
    const dx = this.x - centerX;
    const dy = this.y - centerY;
    const distance = Math.sqrt(dx * dx + dy * dy);

    // If the ball exceeds the boundary, constrain it
    const maxDistance = boundaryRadius - this.radius;
    if (distance > maxDistance) {
      // Project the ball back onto the circle's inner edge
      const angle = Math.atan2(dy, dx);
      this.x = centerX + Math.cos(angle) * maxDistance;
      this.y = centerY + Math.sin(angle) * maxDistance;

      // Decompose velocity into normal and tangent components
      const normalVelocity = (this.vx * Math.cos(angle)) + (this.vy * Math.sin(angle));
      const tangentVelocity = (-this.vx * Math.sin(angle)) + (this.vy * Math.cos(angle));

      // Apply bounce to the normal velocity
      const bouncedNormalVelocity = -normalVelocity * this.bounceFactor;

      // Combine the bounced normal velocity with the tangent velocity
      this.vx = Math.cos(angle) * bouncedNormalVelocity - Math.sin(angle) * tangentVelocity * this.friction;
      this.vy = Math.sin(angle) * bouncedNormalVelocity + Math.cos(angle) * tangentVelocity * this.friction;
    }
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = 'blue';
    ctx.fill();
    ctx.stroke();
  }
}

class CircleBoundary {
  constructor(x, y, radius) {
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  draw(ctx) {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.stroke();
  }
}

// Initialize ball and boundary
const boundary = new CircleBoundary(300, 300, 150);
const ball = new Ball(240, 180, 10);

function draw(ctx) {
  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  // Update ball movement
  ball.update(boundary.x, boundary.y, boundary.radius);

  // Draw boundary and ball


================================================================================
END: line-rider.js
================================================================================



================================================================================
FILE: line-spline-bridge.js
================================================================================

/*
title: Line Spline Bridge
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../others/curve_src/curve.js
    ../point_src/extras.js
    ../point_src/curve-extras.js
    ../point_src/iter/alpha.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/catenary-curve.js
    ../point_src/distances.js
    dragging
    mouse
    fps

 */
var superV = 0

class RelativeNumber {
    constructor(parent, offset) {
        this.offset = offset
    }

    compute() {
        this.value = this.offset
    }
}


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = (new Point(100, this.center.y)).quantize(100)
        this.clickPoint = this.center

        this.line = new Line(this.point, this.clickPoint, 'green', 2)

        autoMouse.on(this.canvas, 'click', this.onClick.bind(this))
        this.cantenary = new CantenaryCurve(this.point, this.point)
        this.newFPS = new FPS(this)
        this.newFPS.setup()


        let drag = this.drag = new Dragging
        drag.initDragging(this)
        // drag.onDragMove = this.onDragMove.bind(this)
        // drag.onDragEnd = this.onDragEnd.bind(this)
        drag.addPoints(this.point, this.clickPoint, this.newFPS.position)
    }

    draw(ctx) {
        this.clear(ctx)

        this.point.pen.indicator(ctx, {color:'#333'})
        this.clickPoint.pen.indicator(ctx, {color:'#333'})

        /* Follow the mouse */
        this.drawMouse(ctx)
        this.drawCurveLine(ctx)
        this.line.render(ctx)

        this.newFPS.update()
        this.newFPS.draw(ctx)
        /* The pinned point 100,100 */

        let p = this.drag.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }
    }

    drawCurveLine(ctx) {
        let mouse = Point.mouse
        // let pos = mouse.position.quantize(20)
        let ws = mouse.wheelSize((v)=>v*v)
        this.point.radius = ws + 10
        this.clickPoint.radius = ws + 10
        let c = this.curve  = new BezierCurve(this.point, this.clickPoint)
        c.useCache = false;
        c.render(ctx)
    }

    drawMouse(ctx) {
        let mouse = Point.mouse
        let pos = mouse.position
        // let color = mouse.isDown(0) ? 'red': '#444'
        this.point.radius = pos.radius = mouse.wheelSize((v)=>v*v) + 10
        // pos.pen.indicator(ctx, { color })
        // this.line.b = pos
    }


================================================================================
END: line-spline-bridge.js
================================================================================



================================================================================
FILE: line-spline-rider.js
================================================================================

/*
---
title: Rotate 3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js

---

*/

;(function(){


const dot = (off,
    x = w / 2 - 140 + off,
    y = h / 4,
    ox = x,
    oy = y,
    xo, yo,
    vx = rnd() * 10 - 5,
    vy = rnd() * -10,
    s = 20,
    g = .3 + rnd() * .2,
    intersect
) => () => {
    x += vx
    y += vy

    if (shoot) {
        vy = rnd() * -20;
        vx = rnd() * 10 - 5
        x = ox
        y = oy
    }

    intersect = false;
    for (let i = 0; i < num - 1; i++) {
        let a = pnts[i]
        let b = pnts[i + 1]
        let d = lineDist(a[0], a[1], b[0], b[1], x, y)
        if (d < s) {
            [rvx, rvy] = reflect(vx, vy, a[0], a[1], b[0], b[1]);
            vx = rvx
            vy = rvy
            x = ox;
            y = oy;
            intersect = true;
            break;
        }
    }

    vy += g
    if (!intersect) {
        ox = x;
        oy = y;
    }
    c.fillStyle = 'red'
    c.fillRect(x, y, s, s)
}



const mount = () => {
    c.beginPath()
    c.moveTo(0, h - 100)
    step = w / num
    for (let i = 0; i <= num; i++) {
        x = step * i
        y = h - 600 - 450 * cos(2 + i / 8) + 50 * sin(i * 0xFFFFF)
        pnts[i] = [x, y]
        c.lineTo(x, y)
    };

    c.stroke()
    return () => {
        c.beginPath()
        c.moveTo(0, h - 100)
        for (let i = 0; i <= num; i++) {
            c.lineTo(pnts[i][0], pnts[i][1])
        }
        c.stroke()
    }
}

let { sqrt, cos, sin, random: rnd } = Math



================================================================================
END: line-spline-rider.js
================================================================================



================================================================================
FILE: linear-con-2.js
================================================================================

/*
title: Graph Chain Follow Points 2
categories: graph
    collisions
    constraints
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    stroke

---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point(250, 150, 10)
            , new Point(400, 320, 10)
            , new Point(300, 520, 8)

            , new Point(340, 580, 8)
            , new Point(380, 520, 8)

            , new Point(410, 520, 8)
            , new Point(450, 520, 8)

            , new Point(430, 520, 8)
            , new Point(400, 520, 8)
        )

        this.collisionBox = new CollisionBox(this.points)
        this.g = new G;

        this.head = 0

        this.g.connect(0, 1, 2, 3, 4)
        this.g.connect(2, 5)
        this.g.connect(5, 6, 7, 8)

        this.dragging.add(...this.points)
    }

    onMousedown(ev, p) {
        // console.log(this.dragging._near)
        this.head = this.points.indexOf(this.dragging._near)
    }

    draw(ctx){
        this.clear(ctx)
        this.collisionBox.shuffle()

        // let mouse = Point.mouse.position
        // followPoint(mouse, this.points[0], 50)

        this.graphChain2()
        this.points.pen.indicators(ctx)

        // head
        this.points[0].pen.fill(ctx, '#992211')
        // tri joint
        this.points[2].pen.fill(ctx, '#00cc33')
    }

    graphChain2() {
        let head = this.head
        let ps = this.points
        let visits = {}

        let pairCallback = (key, fromKey, allTargets)=>{
            // console.log('from=', fromKey, 'key=', key, )
            // constraints.within(ps[fromKey], ps[key], 50)


            constraints.distance(ps[fromKey], ps[key], 50)

            if(visits[fromKey] == undefined) { visits[fromKey] = 0 }
            if(visits[key] == undefined) { visits[key] = 0 }

            visits[fromKey] += 1
            visits[key] += 1
        }

        this.g.walkForward(head, pairCallback)
    }


================================================================================
END: linear-con-2.js
================================================================================



================================================================================
FILE: linear-con.js
================================================================================

/*
title: Graph Chain Follow Points 2
categories: graph
    constraints
    collisions
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    stroke

---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point(250, 150, 10)
            , new Point(400, 320, 10)
            , new Point(300, 520, 8)

            , new Point(340, 580, 8)
            , new Point(380, 520, 8)

            , new Point(410, 520, 8)
            , new Point(450, 520, 8)

            , new Point(430, 520, 8)
            , new Point(400, 520, 8)
        )

        this.collisionBox = new CollisionBox(this.points)
        this.g = new G;

        this.head = 0

        this.g.connect(0, 1, 2, 3, 4)
        this.g.connect(2, 5)
        this.g.connect(5, 6, 7, 8)

        this.dragging.add(...this.points)
    }

    onMousedown(ev, p) {
        // console.log(this.dragging._near)
        this.head = this.points.indexOf(this.dragging._near)
    }

    draw(ctx){
        this.clear(ctx)
        this.collisionBox.shuffle()

        // let mouse = Point.mouse.position
        // followPoint(mouse, this.points[0], 50)

        this.graphChain2()
        this.points.pen.indicators(ctx)

        // head
        this.points[0].pen.fill(ctx, '#992211')
        // tri joint
        this.points[2].pen.fill(ctx, '#00cc33')
    }

    graphChain2() {
        let head = this.head
        let ps = this.points
        let visits = {}

        let pairCallback = (key, fromKey, allTargets)=>{
            // console.log('from=', fromKey, 'key=', key, )
            // constraints.within(ps[fromKey], ps[key], 50)


            constraints.distance(ps[fromKey], ps[key], 50)

            if(visits[fromKey] == undefined) { visits[fromKey] = 0 }
            if(visits[key] == undefined) { visits[key] = 0 }

            visits[fromKey] += 1
            visits[key] += 1
        }

        this.g.walkForward(head, pairCallback)
    }


================================================================================
END: linear-con.js
================================================================================



================================================================================
FILE: lines-multi-examples.js
================================================================================

/*
title: Lines Multi Examples
categories: lines
    curve
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    pointlist
    ../point_src/point.js
    mouse
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/stage.js
    # ../others/curve_src/curve.js
    # ../point_src/line.js
    # ../point_src/extras.js
    ../point_src/catenary-curve.js
    ../point_src/curve-extras.js

*/
var superV = 0


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.points = this.pointPair()

        this.linePoints = this.pointPair()
        this.curvePoints = this.pointPair(150)
        this.cantenaryPoints = this.pointPair(300)

         this.line = new Line(...this.linePoints, 'green', 2)
        /*this.line = new Line(...this.points, 'green', 2)*/
        this.curvyLine = new BezierCurve(...this.curvePoints)
        this.cantenary = this.setupCantenary(this.cantenaryPoints)
        /* this.cantenary = this.setupCantenary(this.pointPair(40)) */
        this.tick = 0

        this.setupDragging()
    }

    setupCantenary(points) {
        let c = new CantenaryCurve(...points)
        // this.cantenary.sine = 30
        c.restLength = 430
        c.bounceRate = .08
        c.reductionRate = .999
        c.swingDegrees = 20
        c.elasticity = .09
        return c

    }

    setupDragging() {

        this.dis = new Dragging
        this.dis.initDragging(this)
        // this.dis.onDragMove = this.onDragMove.bind(this)
        // this.dis.onDragEnd = this.onDragEnd.bind(this)
        this.dis.addPoints(  ...this.linePoints
                           , ...this.curvePoints
                           , ...this.cantenaryPoints
                           )
    }

    pointPair(yOffset=0) {
        let cumX = 0
            , cumOffset = 200
            , globalY = 100
            , offset = ()=> cumX+=cumOffset
            , c = this.compass
            ;

        let ps = new PointList(
            new Point({
                name: "a"
                , rotation: c.right
                , x: offset()
                , y: globalY + yOffset
                , radius: 60
            })
            , new Point({
                name: "b"
                , rotation: c.left // RIGHT_DEG
                , x: offset()
                , y: globalY + 50 + yOffset
                , radius: 70
            })
        )

        return ps;
    }




================================================================================
END: lines-multi-examples.js
================================================================================



================================================================================
FILE: locked-coupling-points.js
================================================================================

/*
---
title: Locked Coupling Points
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/pointlist.js
    ../point_src/point-content.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/coupling.js
---

# Locked Coupling

Locked coupling ensures changes _only_ occur in one direction. Changes on the
_second_ node of a coupling will not affect the assigned coupled keys.
 */
class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        let a = this.a = new Point({x:200,y:200, radius: 50})
        let b = this.b = new Point({x:300,y:300, radius: 50})
        let c = this.c = new Point({x:200,y:200, radius: 20})

        this.dragging.add(a, b, c)

        let d = this.coupling = new LockedCoupling()

        /* B.y value is locked at a distance + relative to the C.y

        + a and b are locked
        + using _c_ as an offset value
        + focusing on the `y`.
        */
        d.couple(a, b, c, ['y'])// {x: 10, y: 10})
        d.step()
    }

    draw(ctx){
        this.clear(ctx)

        this.a.rotation += 1
        this.coupling.step()

        this.a.pen.indicator(ctx, {color:'#ddd'})
        this.b.pen.indicator(ctx, {color:'green'})
        this.c.pen.indicator(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: locked-coupling-points.js
================================================================================



================================================================================
FILE: lookat-example.js
================================================================================

/*
title: Lookat Example
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/extras.js
    ../point_src/setunset.js
    ../point_src/stroke.js

 */
const canvas = document.getElementById('playspace');
const ctx = canvas.getContext('2d');
Point.mouse.mount(canvas)


const lookerPoint = point(200, 200)
lookerPoint.radius = 100

const update = function() {
    ctx.beginPath()

    drawView()
}


const drawView = function(){

    // Draw a circle at the origin point.
    lookerPoint.pen.circle(ctx)
    quickStroke('green', 2)

    /* Then project the point; default radius, rotation; and draw a circle. */
    let targetPosition = Point.mouse.position;
    let distanceToMouse = lookerPoint.distanceTo(targetPosition)
    /* Clamp the object. */
    let distance = Math.min(distanceToMouse, lookerPoint.radius);
    // let distance = Math.max(distanceToMouse, lookerPoint.radius);
    /* Alterntively project to the distance of the mouse. */
    const projectedPoint = lookerPoint.project(distance)

    /* Draw from the projected point back to the origin. */
    projectedPoint.pen.line(ctx, lookerPoint)
    quickStroke('red', 1)

    /* And draw a circle at the tip of projection. */
    projectedPoint.pen.circle(ctx)
    quickStroke('yellow', 1)

    // lookatRaw();
    // lookatBuiltin()
    lookatFunc()
}

const lookatBuiltin = function() {
    let targetPosition = Point.mouse.position;
    lookerPoint.radians = lookerPoint.getTheta(targetPosition, Math.PI)
}

const lookatFunc = function() {
    let targetPosition = Point.mouse.position;
    lookerPoint.lookAt(targetPosition)
}

const lookatRaw = function() {
    let targetPosition = Point.mouse.position;
    // Calculate the differences in x and y coordinates
    const deltaX = targetPosition.x - lookerPoint.x;
    const deltaY = targetPosition.y - lookerPoint.y;

    // Calculate the angle in radians
    const angleRadians = Math.atan2(deltaY, deltaX);
    lookerPoint.radians = angleRadians

    // Convert the angle to degrees
    // const angleDegrees = angleRadians * (180 / Math.PI);
    // lookerPoint.rotation = angleDegrees


}


function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    update()
    requestAnimationFrame(draw);
}


let rect = canvas.getBoundingClientRect()
ctx.canvas.width  = rect.width;
ctx.canvas.height = rect.height;
draw()


================================================================================
END: lookat-example.js
================================================================================



================================================================================
FILE: lookat-multiplier.js
================================================================================

/*
title: Lookat Multiplier
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/stage.js
    ../point_src/distances.js
    ../point_src/automouse.js
    ../point_src/extras.js
---

The `turnTo` method acts very similar to the `lookAt` method, but accepts a
speed to denote _how quickly_ the origin point should turn to the target.

    const origin = new Point(200, 200, 20)
    // between 0 and 1
    origin.turnTo(Point.mouse.poition, .01)

*/


const drawView = function(ctx, lookerPoint){

    /* Project to the distance of the mouse. */
    const projectedPoint = lookerPoint.project()
    /* Draw from the projected point back to the origin. */
    projectedPoint.pen.line(ctx, lookerPoint, 'red')
    projectedPoint.pen.circle(ctx, {color: 'red'})
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.pointA = this.center.copy().update({ radius: 100 })
        this.pointB = this.pointA.copy()
        this.pointC = this.pointA.copy()
    }

    draw(ctx){
        this.clear(ctx)
        let targetPosition = Point.mouse.position

        this.pointA.turnTo(targetPosition, .01)
        this.pointB.turnTo(targetPosition, 1)
        this.pointC.turnTo(targetPosition, .001)

        drawView(ctx, this.pointA)
        drawView(ctx, this.pointB)
        drawView(ctx, this.pointC)
    }
}


stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: lookat-multiplier.js
================================================================================



================================================================================
FILE: lorp-2.js
================================================================================

/*
title: Bezier Curve Tube Between Points
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    ../point_src/curve-extras.js
    ../point_src/split.js
    ../point_src/functions/rel.js
---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.b = new Point({x: 250, y: 150 , radius: 20, rotation: 145})
        this.a = new Point({x: 150, y: 150 , radius: 20, rotation: 45})

        this.dragging.add(this.a, this.b)
        this.makeLines()
    }

    makeLines(){
        let pa = this.a.split(2, undefined, degToRad(90))
        pa.each.rotation = this.a.rotation// - 90
        pa.each.rotation = this.a.rotation// - 90
        // pa.each.radius = this.a.radius
        let pb = this.b.split(2, undefined, degToRad(90))
        pb.each.rotation = this.b.rotation //+ 90
        // pb.each.radius = this.b.radius
        let br2 = this.b.radius
        let ar2 = this.a.radius
        let disA = pa[0].distanceTo(pb[0])
        let disB = pa[1].distanceTo(pb[1])
        let da = Math.sqrt(disA)
        let db = Math.sqrt(disB)
        pb[0].radius = Math.max(br2 - da, 30 + da)
        pb[1].radius = Math.max(br2 - db, 30 + db)
        pa[0].radius = Math.max(ar2 - da, 30 + da)
        pa[1].radius = Math.max(ar2 - db, 30 + db)
        // this.bottomLine = new BezierCurve(this.a, this.b)
        this.topLine = new BezierCurve(pa[1], pb[0])
        this.topLine.doTips = false

        this.bottomLine = new BezierCurve(pa[0], pb[1])
        this.bottomLine.doTips = false

    }

    draw(ctx){
        this.clear(ctx)
        this.makeLines()

        this.a.pen.indicator(ctx, {color: '#333'})
        this.b.pen.indicator(ctx, {color: '#333'})
        ctx.strokeStyle = 'yellow'
        // ctx.strokeStyle = 'red'
        ctx.fillStyle = '#777'
        // this.a.pen.arc(ctx, this.bottomLine.points[0], undefined, undefined, undefined, 0)
        ctx.beginPath()


        this.a.draw.arc(ctx, this.a.radius,
            this.a.directionTo(this.bottomLine.points[0]), // bottom left.
            this.a.directionTo(this.topLine.points[0]), //top left
            // this.a.radians,
            0)

        this.topLine.perform(ctx)
        // ctx.stroke()

        // ctx.beginPath()
        // ctx.strokeStyle = 'red'

        // this.bottomLine.render(ctx)
        // ctx.stroke()
        // ctx.beginPath()
        this.b.draw.arc(ctx, this.b.radius,
            this.b.directionTo(this.topLine.points[1]),
            this.b.directionTo(this.bottomLine.points[1]),
            // this.b.radians,
            // this.b.directionTo(this.topLine.points[1]),
            0)
        // ctx.beginPath()
        ctx.stroke()
        // ctx.fill()

        /* Plop step.
        Add a Point _here_ where the pen currently sits.
        Add an index to display where it is. */

        this.bottomLine.start(ctx)
        this.bottomLine.perform(ctx)


================================================================================
END: lorp-2.js
================================================================================



================================================================================
FILE: lorp.js
================================================================================

/*
title: Bezier Curve Between Split Points
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    ../point_src/curve-extras.js
    ../point_src/split.js
---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.b = new Point({x: 250, y: 150 , radius: 20, rotation: 45})
        this.a = new Point({x: 150, y: 150 , radius: 20, rotation: 145})

        this.dragging.add(this.a, this.b)
        this.makeLines()
    }

    makeLines(){
        let pa = this.a.split(2)
        pa.each.rotation = this.a.rotation - 90
        // pa.each.radius = this.a.radius
        let pb = this.b.split(2)
        pb.each.rotation = this.b.rotation + 90
        // pb.each.radius = this.b.radius
        let br2 = this.b.radius
        let ar2 = this.a.radius
        let disA = pa[0].distanceTo(pb[0])
        let disB = pa[1].distanceTo(pb[1])
        let da = Math.sqrt(disA)
        let db = Math.sqrt(disB)
        pb[0].radius = Math.max(br2 - da, 30 + da)
        pb[1].radius = Math.max(br2 - db, 30 + db)
        pa[0].radius = Math.max(ar2 - da, 30 + da)
        pa[1].radius = Math.max(ar2 - db, 30 + db)
        this.line = new BezierCurve(pa[0], pb[0])
        this.line.doTips = false
        this.line2 = new BezierCurve(pa[1], pb[1])
        this.line2.doTips = false
        // this.line = new BezierCurve(this.a, this.b)

    }

    draw(ctx){
        this.clear(ctx)
        this.makeLines()

        this.a.pen.indicator(ctx, {color: '#333'})
        this.b.pen.indicator(ctx, {color: '#333'})
        ctx.strokeStyle = 'red'
        ctx.fillStyle = '#777'
        // this.a.pen.arc(ctx, this.line.points[0], undefined, undefined, undefined, 0)
        ctx.beginPath()
        this.a.draw.arc(ctx, this.a.radius,
            this.a.radians,
            this.a.directionTo(this.line2.points[0]),
            0)

        ctx.stroke()
        ctx.beginPath()
        this.b.draw.arc(ctx, this.b.radius,
            this.b.directionTo(this.line2.points[1]),
            this.b.radians,
            0)
        ctx.stroke()

        // ctx.beginPath()
        // ctx.stroke()
        // ctx.fill()

        // ctx.beginPath()
        // this.line.perform(ctx)
        // ctx.stroke()
        this.line.render(ctx)
        this.line2.render(ctx)


        // this.line.perform(ctx)
        // ctx.stroke()
        // ctx.beginPath()
        // this.line2.perform(ctx)
        // ctx.stroke()
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: lorp.js
================================================================================



================================================================================
FILE: mass-pointer-ring-indicator.js
================================================================================

/*
title: Mass Pointer Ring Indicator
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/automouse.js
    ../point_src/setunset.js
    ../point_src/text/styler.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/rope.js
    ../point_src/collisionbox.js
    ../point_src/gravity.js
    ../point_src/constrain-distance.js
    ../point_src/random.js

    */

const stringLength = 200

const heavyStep = function(followPoint, mouse, gravity,
                           damping=.9, dotDamping=.2, forceMultiplier=.1, forceValue=undefined) {
    // Apply gravity to the follow point's vertical velocity
    // Calculate the vector from the mouse to the follow point
    // let dx = followPoint.x - mouse.x ;
    // let dy = followPoint.y - mouse.y ;
    let dx = mouse.x - followPoint.x;
    let dy = mouse.y - followPoint.y;

    // Calculate the current distance between the follow point and the mouse
    let distance = Math.sqrt(dx * dx + dy * dy);

    // Set the follow point's position to be exactly on the circumference of the string length
    // const force = (distance - stringLength) * 0.01; // Tweak this factor as needed

    // If the distance exceeds the string length, we need to constrain the follow point
    if (distance > stringLength) {

        // Normalize the direction vector
        dx /= distance;
        dy /= distance;

        if(dotDamping!==false) {
            // Adjust the velocity so that it reflects the string tension
            let dotProduct = (followPoint.vx * dx + followPoint.vy * dy) * dotDamping;
            followPoint.vx -= dotProduct * dx;
            followPoint.vy -= dotProduct * dy;
        }

        if(forceMultiplier!==false){
            const force = forceValue? forceValue: (distance - stringLength) * forceMultiplier; // Tweak this factor as needed
            followPoint.vx += force * dx;
            followPoint.vy += force * dy;
        }

    }

    // Apply gravity
    if(gravity){
        followPoint.vy += gravity.y;
        followPoint.vx += gravity.x;
    }

    // Update the follow point's position based on its velocity
    followPoint.x += followPoint.vx;
    followPoint.y += followPoint.vy;

    if(damping) {
        // Apply damping continuously to smooth the motion
        followPoint.vx *= damping;
        followPoint.vy *= damping;
    }
};


const flutter = ()=>{
    stage.cable.visibleRopeGravity.y = -.05 + (random.float(-1, 1) * .1)
    setTimeout(flutter, random.float(2, 5))
};

// setTimeout(flutter, random.float(0.5, 2))


class Cable {



================================================================================
END: mass-pointer-ring-indicator.js
================================================================================



================================================================================
FILE: mass-pointer.js
================================================================================

/*
title: Mass Pointer
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/automouse.js
    ../point_src/setunset.js
    ../point_src/text/styler.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/rope.js
    ../point_src/collisionbox.js
    ../point_src/gravity.js
    ../point_src/random.js

    */

const stringLength = 200

const heavyStep = function(followPoint, mouse, gravity,
                           damping=.9, dotDamping=.2, forceMultiplier=.1, forceValue=undefined) {
    // Apply gravity to the follow point's vertical velocity
    // Calculate the vector from the mouse to the follow point
    // let dx = followPoint.x - mouse.x ;
    // let dy = followPoint.y - mouse.y ;
    let dx = mouse.x - followPoint.x;
    let dy = mouse.y - followPoint.y;

    // Calculate the current distance between the follow point and the mouse
    let distance = Math.sqrt(dx * dx + dy * dy);

    // Set the follow point's position to be exactly on the circumference of the string length
    // const force = (distance - stringLength) * 0.01; // Tweak this factor as needed

    // If the distance exceeds the string length, we need to constrain the follow point
    if (distance > stringLength) {

        // Normalize the direction vector
        dx /= distance;
        dy /= distance;

        if(dotDamping!==false) {
            // Adjust the velocity so that it reflects the string tension
            let dotProduct = (followPoint.vx * dx + followPoint.vy * dy) * dotDamping;
            followPoint.vx -= dotProduct * dx;
            followPoint.vy -= dotProduct * dy;
        }

        if(forceMultiplier!==false){
            const force = forceValue? forceValue: (distance - stringLength) * forceMultiplier; // Tweak this factor as needed
            followPoint.vx += force * dx;
            followPoint.vy += force * dy;
        }

    }

    // Apply gravity
    if(gravity){
        followPoint.vy += gravity.y;
        followPoint.vx += gravity.x;
    }

    // Update the follow point's position based on its velocity
    followPoint.x += followPoint.vx;
    followPoint.y += followPoint.vy;

    if(damping) {
        // Apply damping continuously to smooth the motion
        followPoint.vx *= damping;
        followPoint.vy *= damping;
    }
};


const flutter = ()=>{
    stage.cable.visibleRopeGravity.y = -.05 + (random.float(-1, 1) * .1)
    setTimeout(flutter, random.float(2, 5))
};

setTimeout(flutter, random.float(0.5, 2))


class Cable {

    defaults = {


================================================================================
END: mass-pointer.js
================================================================================



================================================================================
FILE: mesh-links.js
================================================================================

/*
title: Mesh Links
files:
    ../point_src/math.js
    head
    ../point_src/point-content.js
    pointlist
    point
    mouse
    stage
    ../point_src/extras.js
    ../point_src/random.js
    stroke
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js


 */
const data = [
    ['a', 'b']
    , ['a', 'c']
    , ['c', 'd']
    , ['c', 'e']
]


const pointMap = new Map()

const getNamed = function(name) {
    if(pointMap.has(name)){
        return pointMap.get(name)
    }
    let leftPad = 20
    let point = new Point(
                    leftPad + random.int(300),
                    leftPad + random.int(600))
    pointMap.set(name, point)
    return point;
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.stroke = new Stroke({
            dash: [5,5]
            , color: 'grey'
            , width: 2
            , march: 1
        })

        let c = 1
        for (var i = 0; i < data.length; i++) {
            let [na, nb] = data[i];
            let pa = getNamed(na)
            let pb = getNamed(nb)
            c += c

            if(pa.iid == undefined) {
                pa.iid = i + c
            }

            if(pb.iid == undefined) {
                pb.iid = i + c + .5
            }
        }

        this.dragging.add(...pointMap.values())
    }

    draw(ctx){
        this.clear(ctx)

        pointMap.forEach((e,i,a)=>{
            e.pen.indicator(ctx, { color: 'green', width: 1})
        })

        // this.drawConnections(ctx)
        this.drawEvery(ctx)
        let mousePoint = Point.mouse.position
        mousePoint.pen.indicator(ctx, { color: 'green', width: 3})

        this.stroke.step(.1)
    }

    drawConnections(ctx) {

        let s = this.stroke
        s.set(ctx)

        for (var i = 0; i < data.length; i++) {
            let [na, nb] = data[i];
            let pa = getNamed(na)
            let pb = getNamed(nb)
            pa.pen.line(ctx, pb)
        }



================================================================================
END: mesh-links.js
================================================================================



================================================================================
FILE: midi-dial-example.js
================================================================================

/*
title: MIDI Actions.
categories: midi
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
    ../theatre/midi-tools.js
    ../theatre/midi-tracks.js
    ../point_src/screenwrap.js
---


*/

var waitMidi;
var stage;

window.addEventListener('midiAccess', (e)=>{
    if(stage){
        stage.setMidiAccess(e.detail);
    } else {
        waitMidi = e.detail
    }
});


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.hasMidi = undefined
        this.setupDevice()

        this.dials = PointList.generate.grid(16, 8)
    }

    requestAccess(f){
        console.log('Requesting for access')

        navigator.requestMIDIAccess().then(f, (m)=>{
                console.error(`Failed to get MIDI access - ${m}`);
            }
        );
    }

    setupDevice(){
        this.midiAccess = waitMidi
        if(waitMidi) {
            this.setMidiAccess(waitMidi)
        } else {
            this.requestAccess(e=>{
                stage.setMidiAccess(e);
            })
        }

        window.addEventListener('dialpressdown', (e) => {
            console.log(e.detail, e)
        })

        window.addEventListener('dialpressup', (e) => {
            console.log(e.detail, e)
        })

        window.addEventListener('dialvaluechange', (e) => {
            console.log(e.detail)
            let d = e.detail
            let dial =this.dials[d.index-1]

            if(dial){
                dial.rotation = (d.valuePercent * .01) * 360
            }
        })

        // window.addEventListener('keyboardnotedown', (e) => {
        //     console.log(e.detail.direction, e.detail)
        //     this.renderKey(e.detail)
        // })


        // window.addEventListener('keyboardnoteup', (e) => {
        //     // console.log(e.detail.direction, e.detail)
        //     this.unRenderKey(e.detail)
        // })

    }

    setMidiAccess(midiAccess) {
        console.log('midi set')
        this.midiAccess = midiAccess
        listInputsAndOutputs(midiAccess)
        startLoggingMIDIInput(midiAccess)
    }

    isPlaying(i) {


================================================================================
END: midi-dial-example.js
================================================================================



================================================================================
FILE: midi-example.js
================================================================================

/*
title: MIDI Actions.
categories: midi
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
    ../theatre/midi-tools.js
    ../theatre/midi-tracks.js
    ../point_src/screenwrap.js
---

Integration with a digital piano. Or fundamentally any MIDI device with key notes.

---

In this example we spawn 88 points as key mapped to their relative note.
Playing the key on the piano will highlight an point.

For fun, the KeyNote can also be played on the device. Checkout
`bumblebeeNotes()`
*/

var waitMidi;
var stage;

window.addEventListener('midiAccess', (e)=>{
    if(stage){
        stage.setMidiAccess(e.detail);
    } else {
        waitMidi = e.detail
    }
});


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.hasMidi = undefined
        this.points = this.generatePianoPoints()
        this.walkers = new PointList
        this.setupDevice()
    }

    generatePianoPoints(size=88) {
        /* To make this easier we generate many smaller duplicate groups.
        from C to C is a matching set of about 8 groups.

        So we generate a single scale _group_ of 14 possible positions
        and _skip_ the missing  black keys, 5 or 13

        This produces 1 correct group. Then we iterate until we have enough
        keys.

        The first group is a partial (starting from A0). But also is 1 black
        key, _then_ the duplicate iterations.

        Therefore we start the first index _offset_ by the count of keys we
        don't want - which is 10 keys. The remaing 4 possible keys are plotted,
        missing the unwanted 13th note.

        Heh. I just realised why the term "13th note" is a thing...

        ---

        This allows a keyboard of any size and note grouping combination
            (missed keys).


        */
        let osize = 88
            /* Between each point.*/
            , padding = 10
            /* How many possible positions within a group */
            , groupKeyCount = 14
            /* Which keys to skip within a group.*/
            , exludes = {5:true, 13: true}
            /* How many groups are required */
            , groupCount = Math.ceil(size / (groupKeyCount - 2 - 1 - 1) )
            // , groupCount = 9

            /* The result points. */
            , ps = []
            /* The starting offset.*/
            , j = 10

            /* global position (from top) offset.  */
            , yOffset = 100
            /* The width of one scale. */
            , oneGroupWidth = (groupKeyCount  * .5) * (padding + 10)
            ;

        for (var i = 0; i < groupCount; i++) {
            for (j; j < groupKeyCount; j++) {


================================================================================
END: midi-example.js
================================================================================



================================================================================
FILE: midi-tools.js
================================================================================

/*
title: MIDI Tools
https://www.recordingblogs.com/wiki/status-byte-of-a-midi-message
*/


function onMIDIMessage(event) {
    /*
    http://midi.teragonaudio.com/tech/midispec/sense.htm


    https://ccrma.stanford.edu/~craig/articles/linuxmidi/misc/essenmidi.html

        command meaning # param
        0xF0    start of system exclusive message   variable
        0xF1    MIDI Time Code Quarter Frame (Sys Common)
        0xF2    Song Position Pointer (Sys Common)
        0xF3    Song Select (Sys Common)
        0xF4    ???
        0xF5    ???
        0xF6    Tune Request (Sys Common)
        0xF7    end of system exclusive message 0
        0xF8    Timing Clock (Sys Realtime)
        0xFA    Start (Sys Realtime)
        0xFB    Continue (Sys Realtime)
        0xFC    Stop (Sys Realtime)
        0xFD    ???
        0xFE    Active Sensing (Sys Realtime)
        0xFF    System Reset (Sys Realtime)
    */
    let continueProcessing = true
    for (const character of event.data) {
        let v = character.toString(16).toUpperCase()
        let command = `0x${v}`
        let f = messageMap[command]
        if(f == undefined) {
            f = defaultAction
        }

        continueProcessing = f(character, event)

        if(!continueProcessing) {
            console.log('---')
            return
        }
    }
    console.log('---')

}

const defaultAction = function(character, e) {
    let str = `_ [${event.data.length}b]: `;
    let v = character.toString(16).toUpperCase()
    let command = `0x${v}`
    str += `com=${command} (char=${character}): ${event.data}`;
    console.log(str);
    return true
}

const realtimeSense = function(character, e) {
    /* Calculate since last */
    // let v = character.toString(16).toUpperCase()
    // let str = `MIDI sense ${v}`;
    // console.log(str);
    return true
}

const midiNoteNames = [
  'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'
];

function getNoteName(noteNumber) {
    const octave = Math.floor(noteNumber / 12) - 1;
    const note = midiNoteNames[noteNumber % 12];
    return `${note}${octave}`;
}


const NOTE_DOWN = "down"
const NOTE_UP = "up"


class EventBase {

    constructor(event) {

        if(event instanceof Event) {
            this.setup.apply(this, event.data)
        } else {
            if(typeof(event) == 'object') {
                this.device = event.device
                if(event.key) {
                    this.setup.apply(this, event.key)
                } else {
                    // assume dict unpack.
                    this.setup.apply(this, [event.type, event.note, event.velocity, event.duration])
                }
            } else {
                // assume array
                this.setup.apply(this, arguments)


================================================================================
END: midi-tools.js
================================================================================



================================================================================
FILE: midi-tracks.js
================================================================================

/*
title: MIDI Tracks
*/

const riverFlowsIntro = [
    64, 69, 71, 68, 69, 71, 76, 73, 71, 69
];

const playRiverFlowsIntro = (output) => {
    let delay = 0;
    const noteLength = 300;  // ms
    const noteGap = 50;      // ms between notes

    riverFlowsIntro.forEach((note, i) => {
        setTimeout(() => {
            output.send([0x90, note, 50]); // Note ON
            setTimeout(() => {
                output.send([0x80, note, 64]); // Note OFF
            }, noteLength);
        }, delay);
        delay += noteLength + noteGap;
    });
};

const riverFlowsHook = [
  69, 68, 69, 64, 69, 68, 69
];

const playRiverFlowsHook = (output) => {
    let delay = 0;
    const noteLength = 300;  // ms per note
    const noteGap = 30;      // ms between notes

    riverFlowsHook.forEach((note, i) => {
        setTimeout(() => {
            output.send([0x90, note, 50]); // Note ON
            setTimeout(() => {
                output.send([0x80, note, 64]); // Note OFF
            }, noteLength);
        }, delay);
        delay += noteLength + noteGap;
    });
};

const bumblebeeNotes = [
    // Let's run up and down chromatically around C5 for 2 octaves
    72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84,
    83, 82, 81, 80, 79, 78, 77, 76, 75, 74, 73, 72,
    71, 70, 69, 68, 67, 66, 65, 64
];


const playBumblebee = (output) => {
    let delay = 0;
    const noteLength = 70;  // ms, really quick
    const noteGap = 50;      // ms between notes

    bumblebeeNotes.forEach((note, i) => {
        let vel = 40 + (Math.random() * 30)
        let duration = delay + (Math.random() * 50)
        setTimeout(() => {
            let k = new KeyboardNote(0x90, note, vel, noteLength, output)
            k.playNoteWithEvents()

        }, duration);
        delay += noteLength + noteGap;
    });
};



const playExample = function(output){
    // Note ON (plays middle C for example)
    output.send([0x90, 60, 100]); // 0x90 = Note On, channel 1, 60 = Middle C, 100 = velocity

    // Wait, then Note OFF
    setTimeout(() => {
      output.send([0x80, 60, 64]); // 0x80 = Note Off, channel 1, 60 = Middle C, 64 = release velocity
    }, 500); // Play for 500ms
}


const playScale = (output) => {
    const notes = [60, 62, 64, 65, 67, 69, 71, 72]; // C D E F G A B C
    notes.forEach((note, i) => {
        setTimeout(() => {
            let vel = 30 + (Math.random() * 20)
            let k = new KeyboardNote(0x90, note, vel, 300, output)
            k.playNoteWithEvents()

            // output.send([0x90, note, vel]);
            // setTimeout(() => {
            //     output.send([0x80, note, 64]);
            // }, 250);
        }, i * 300);
    });
};

const playScaleRaw = (output) => {
    const notes = [60, 62, 64, 65, 67, 69, 71, 72]; // C D E F G A B C


================================================================================
END: midi-tracks.js
================================================================================



================================================================================
FILE: mini-space-2.js
================================================================================

/*
src_dir: ../point_src/
title: Mini Space 2
categories: gravity
    raw
files:
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/rel.js
    dragging
    ../point_src/constrain-distance.js

 */
// window.requestAnimFrame =
// window.requestAnimationFrame       ||
// window.webkitRequestAnimationFrame ||
// window.mozRequestAnimationFrame    ||
// window.oRequestAnimationFrame      ||
// window.msRequestAnimationFrame     ||
// function(callback) {
//     window.setTimeout(callback, 1000 / 60);
// };
var n_tmp;

var Utils = {
    dist : function (pl, dps) {
        return Math.sqrt(
                Math.pow(pl.x - dps.x, 2) + Math.pow(pl.y - dps.y, 2)
            )
    }
}


let asteroidToAsteroidBounciness = .04
let asteroidToPlanetBounciness = 1


class World {

    constructor() {
        this.entities = [];
        this.debug = false;
        this.pause = false;
        this.fpsMax = 60;
        this.g = .1;
        this.canvas = "";
        this.context = "";
        this.mousedown = false;
    }

    init(canvas) {

        var _this;

        _this = this
        n_tmp = undefined

        this.canvas = canvas// document.getElementById("playspace");
        // this.canvas.width = 800;
        // this.canvas.height = 600;
        this.context = this.canvas.getContext("2d");

        // this.generatePlanets()
        this.generateAsteroids(150, 10)
        // this.generateInversePlanets()

        this.loop();
    }

    plotRand(v){
        return Math.floor(Math.random() * v) % (v - 200) + 100
    }

    generatePlanets(){
        // Generating planets
        for (var i = 0; i < 3; i++) {
            var tmp = new Planet(
                this.plotRand(this.canvas.width)
              , this.plotRand(this.canvas.height)
              , Math.floor(Math.random() * 100) + 20
              , "#9922EE"
            );
            this.entities.push(tmp);
        }
    }

    generateInversePlanets(){

        for (var i = 0; i < 3; i++) {
            var tmp = new Planet(


================================================================================
END: mini-space-2.js
================================================================================



================================================================================
FILE: mini-space-3.js
================================================================================

/*
src_dir: ../point_src/
title: Mini Space 3
categories: gravity
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/rel.js
    dragging
    ../point_src/constrain-distance.js

 */
// window.requestAnimFrame =
// window.requestAnimationFrame       ||
// window.webkitRequestAnimationFrame ||
// window.mozRequestAnimationFrame    ||
// window.oRequestAnimationFrame      ||
// window.msRequestAnimationFrame     ||
// function(callback) {
//     window.setTimeout(callback, 1000 / 60);
// };
var n_tmp;

var Utils = {
    dist : function (pl, dps) {
        return Math.sqrt(
                Math.pow(pl.x - dps.x, 2) + Math.pow(pl.y - dps.y, 2)
            )
    }
}


let asteroidToAsteroidBounciness = .4
let asteroidToPlanetBounciness = 1


class World {

    constructor() {
        this.entities = [];
        this.debug = false;
        this.pause = false;
        this.fpsMax = 60;
        this.g = .1;
        this.canvas = "";
        this.context = "";
        this.mousedown = false;
    }

    init(canvas) {

        var _this;

        _this = this
        n_tmp = undefined

        this.canvas = canvas// document.getElementById("playspace");
        // this.canvas.width = 800;
        // this.canvas.height = 600;
        this.context = this.canvas.getContext("2d");

        // this.generatePlanets()
        this.generateAsteroids(50, 10)
        // this.generateInversePlanets()

        this.loop();
    }

    plotRand(v){
        return Math.floor(Math.random() * v) % (v - 200) + 100
    }

    generatePlanets(){
        // Generating planets
        for (var i = 0; i < 3; i++) {
            var tmp = new Planet(
                this.plotRand(this.canvas.width)
              , this.plotRand(this.canvas.height)
              , Math.floor(Math.random() * 100) + 20
              , "#9922EE"
            );
            this.entities.push(tmp);
        }
    }

    generateInversePlanets(){

        for (var i = 0; i < 3; i++) {
            var tmp = new Planet(


================================================================================
END: mini-space-3.js
================================================================================



================================================================================
FILE: mini-space-4.js
================================================================================

/*
src_dir: ../point_src/
title: Mini Space 4
categories: gravity
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/rel.js
    dragging
    ../point_src/constrain-distance.js
    ../point_src/screenwrap.js

 */
// window.requestAnimFrame =
// window.requestAnimationFrame       ||
// window.webkitRequestAnimationFrame ||
// window.mozRequestAnimationFrame    ||
// window.oRequestAnimationFrame      ||
// window.msRequestAnimationFrame     ||
// function(callback) {
//     window.setTimeout(callback, 1000 / 60);
// };
var n_tmp;

var Utils = {
    dist : function (pl, dps) {
        return Math.sqrt(
                Math.pow(pl.x - dps.x, 2) + Math.pow(pl.y - dps.y, 2)
            )
    }
}


// let asteroidToAsteroidBounciness = 1
let asteroidToAsteroidBounciness = .4
let asteroidToPlanetBounciness = 1

let clampMin = -10
    , clampMax = 10
    /* how much each particle tends towards the others.
    above 1.5, particles tend towards massing.
    below 1.5, particles act more like air */
    , discoveryEagerness = 1
    // , discoveryEagerness = 60
    // , discoveryEagerness = 1

    /* less for gasses, more for gravity boids*/
    , grabStrength = 1
    // , grabStrength = 6
    // , grabStrength = -2
    , asteroidCount = 200
    ;


class World {

    constructor() {
        this.entities = [];
        this.debug = false;
        this.pause = false;
        this.fpsMax = 60;
        this.g = .1;
        this.canvas = "";
        this.context = "";
        this.mousedown = false;
    }

    init(canvas) {

        var _this;

        _this = this
        n_tmp = undefined

        this.canvas = canvas// document.getElementById("playspace");
        // this.canvas.width = 800;
        // this.canvas.height = 600;
        this.context = this.canvas.getContext("2d");

        // this.generatePlanets()
        this.generateAsteroids(asteroidCount, 10)
        // this.generateInversePlanets()

        this.loop();
    }

    plotRand(v){
        return Math.floor(Math.random() * v) % (v - 200) + 100
    }


================================================================================
END: mini-space-4.js
================================================================================



================================================================================
FILE: mini-space.js
================================================================================

/*
title: Mini Space
categories: gravity
    raw
---
 */
window.requestAnimFrame =
window.requestAnimationFrame       ||
window.webkitRequestAnimationFrame ||
window.mozRequestAnimationFrame    ||
window.oRequestAnimationFrame      ||
window.msRequestAnimationFrame     ||
function(callback) {
    window.setTimeout(callback, 1000 / 60);
};

var Utils = {
  dist : function (pl, dps) {
    return (Math.sqrt(Math.pow(pl.x - dps.x, 2) + Math.pow(pl.y - dps.y, 2)))
  }
}

var World = function()
{
  this.entities = [ ];
  this.debug = false;
  this.pause = false;
  this.fpsMax = 60;
  this.g = 1;
  this.canvas = "";
  this.context = "";
  this.mousedown = false;
}

var n_tmp;

World.prototype.init = function() {

  var _this;

  _this = this
  n_tmp = undefined

  this.canvas = document.getElementById("playspace");
  this.canvas.width = 800;
  this.canvas.height = 600;
  this.context = this.canvas.getContext("2d");

  // Events handlers

  // disable touchmove default behavior for scrolling
  document.body.addEventListener('touchmove', function(event) {
    event.preventDefault();
  }, false);

  var mouseUp = function(e) {
    var tmp = new Asteroid(
        n_tmp.x
      , n_tmp.y
      , 15
      , "#0f0"
      )
    var tmp_x = (n_tmp.x - n_tmp.xp) || 0
    var tmp_y = (n_tmp.y - n_tmp.yp) || 0
    var dist = Math.min(Math.sqrt(tmp_x * tmp_x + tmp_y * tmp_y), 50) || 1;
    if (dist != 0)
    {
      tmp.vx = tmp_x / dist * (dist / 10)
      tmp.vy = tmp_y / dist * (dist / 10)
    }
    _this.entities.push(tmp);
    _this.mousedown = false
    n_tmp = undefined
 };
  var mouseDown = function(e) {
    _this.mousedown = true;
    n_tmp = {
      x : e.clientX || 0,
      y : e.clientY || 0,
      xp : undefined,
      yp : undefined
    }
  };
  var mouseMove = function(e) {
    if (_this.mousedown && n_tmp)
    {
      n_tmp.xp = e.clientX
      n_tmp.yp = e.clientY
    }
  }
  var touchMove = function(e) {
    if (_this.mousedown && n_tmp)
    {
      n_tmp.xp = e.touches[0].pageX
      n_tmp.yp = e.touches[0].pageY
    }
  }

  // Generating planets
  for (var i = 0; i < 3; i++)


================================================================================
END: mini-space.js
================================================================================



================================================================================
FILE: minimal-add-example.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    stage
    mouse
    dragging
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/
class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.pointA = new Point(10,10)
        this.pointB = new Point(10,10)
        this.dragging.add(this.pointA, this.pointB)
    }

    draw(ctx){
        this.clear(ctx)
        this.pointA.pen.indicator(ctx)
        this.pointB.pen.indicator(ctx)
        this.pointA.add(this.pointB).pen.indicator(ctx)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: minimal-add-example.js
================================================================================



================================================================================
FILE: minimal-example.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    stage
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/
class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.point = this.center.copy()
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.indicator(ctx)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: minimal-example.js
================================================================================



================================================================================
FILE: mirror-class-example.js
================================================================================

/*
title: Mirror Class Example
categories: reflections
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/mirror.js
    ../point_src/stage.js

 */
class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        this.createPoints()

        this.dis = new Dragging
        this.dis.initDragging(this)
        this.dis.addPoints(...this.points, this.origin, this.other)

        this.mirror = new Mirror(this.points)
        this.mirror.add(this.origin)
    }

    createPoints(){
        let _a = new Point({x:406, y:76, radius: 20})
        let _b = new Point({x:350, y:300, radius: 20})
        let _c = new Point({x:245, y:500, radius: 20})
        // let _d = new Point({x:270, y:550, radius: 20})
        this.points = new PointList(_a,_b, _c)
        this.origin = new Point({x: 156, y: 135, radius: 20})
        this.other = new Point({x: 150, y:150, radius: 20})
    }

    draw(ctx){
        this.clear(ctx)

        this.drawMirror(ctx)
        this.drawCircles(ctx)
        this.drawIris(ctx)
    }

    drawMirror(ctx) {
        /* Must be called at some point to update the mirror points. */
        this.mirror.step();
        /* Draw the optional contents of the mirror */
        this.mirror.draw(ctx);

        /* We can also use the reflect method for an immediate point: */
        // this.mirror.reflect(this.other).pen.indicator(ctx, {color: '#AAA'})
        this.mirror.reflect(this.other).pen.indicators(ctx, {color: '#AAA'})
    }

    drawCircles(ctx) {
        this.origin.pen.indicator(ctx, {color:'green'})
        this.other.pen.indicator(ctx, {color:'#555'})
    }

    drawIris(ctx) {
        /* The dynamic highlighter. */
        let p = this.dis.getPoint();
        if(p) {
            p.pen.circle(ctx)
        }
    }
}


;stage = MainStage.go();

================================================================================
END: mirror-class-example.js
================================================================================



================================================================================
FILE: mirror-example.js
================================================================================

/*
title: Mirror Example
categories: reflections
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/bisector.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../others/curve_src/curve.js
    ../point_src/curve-extras.js
    ../point_src/stage.js



 */
function reflectPoint(origin, line) {
    const [p1, p2] = line;
    const x1 = p1.x, y1 = p1.y;
    const x2 = p2.x, y2 = p2.y;
    const x0 = origin.x, y0 = origin.y;

    // Calculate slope (m) and y-intercept (c) of the mirror line
    const m = (y2 - y1) / (x2 - x1);
    const c = y1 - m * x1;

    // Perpendicular slope (negative reciprocal)
    const m_p = -1 / m;

    // Equation of the perpendicular line through the origin point
    const c_p = y0 - m_p * x0;

    // Solve the intersection of the mirror line and the perpendicular line
    const x_intersect = (c_p - c) / (m - m_p);
    const y_intersect = m * x_intersect + c;

    // Reflect the origin point
    const x_prime = 2 * x_intersect - x0;
    const y_prime = 2 * y_intersect - y0;

    // Calculate the reflected angle
    const reflectedRadians = Math.atan2(y2 - y1, x2 - x1) * 2 - origin.radians;

    return { x: x_prime
            , y: y_prime
            , radians: reflectedRadians
            , radius: origin.radius
        };
}


function intersectionPoint(origin, line) {
    const [p1, p2] = line;
    const x1 = p1.x, y1 = p1.y;
    const x2 = p2.x, y2 = p2.y;
    const x0 = origin.x, y0 = origin.y;

    // Calculate slope (m) and y-intercept (c) of the mirror line
    const m = (y2 - y1) / (x2 - x1);
    const c = y1 - m * x1;

    // Perpendicular slope (negative reciprocal)
    const m_p = -1 / m;

    // Equation of the perpendicular line through the origin point
    const c_p = y0 - m_p * x0;

    // Solve the intersection of the mirror line and the perpendicular line
    const x_intersect = (c_p - c) / (m - m_p);
    const y_intersect = m * x_intersect + c;

    // Reflect the origin point but keep it on the same side
    const x_prime = x0 + (x_intersect - x0);
    const y_prime = y0 + (y_intersect - y0);

    // Calculate the reflected angle, ensuring it stays on the same side
    const incidentAngle = Math.atan2(y0 - y_intersect, x0 - x_intersect);
    const mirrorAngle = Math.atan2(y2 - y1, x2 - x1);
    const reflectedRadians = 2 * mirrorAngle - incidentAngle;

    return {
        x: x_prime,
        y: y_prime,
        radians: reflectedRadians,
        radius: origin.radius
    };
}





================================================================================
END: mirror-example.js
================================================================================



================================================================================
FILE: mirror-one-point.js
================================================================================

/*
title: Mirror One Point
categories: reflections
files:
    head
    stroke
    pointlist
    point
    mouse
    dragging
    ../point_src/functions/clamp.js
    ../point_src/mirror.js
    stage
*/
class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = new PointList(
                new Point({x:406, y:76, radius: 20})
                , new Point({x:145, y:397, radius: 20})
            )

        this.dragging.addPoints(...this.points, this.center)

        /* Apply the start and end points of the mirror. */
        this.mirror = new Mirror(this.points)
        /* Add things to reflect in the mirror */
        this.mirror.add(this.center)
    }

    draw(ctx){
        this.clear(ctx)

        /* Must be called at some point to update the mirror points. */
        this.mirror.step();
        /* Draw the optional contents of the mirror */
        this.mirror.draw(ctx);

        this.center.pen.indicator(ctx, {color:'green'})

        this.dragging.drawIris(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: mirror-one-point.js
================================================================================



================================================================================
FILE: mirror-with-catenary-example.js
================================================================================

/*
Title: Mirror with Catenary
title: Mirror With Catenary Example
categories: reflections
    catenary
files:
    ../point_src/core/head.js
    stroke
    point
    pointlist
    mouse
    dragging
    ../point_src/bisector.js
    ../point_src/functions/clamp.js
    ../point_src/stage-clock.js
    ../point_src/catenary-curve.js
    ../point_src/curve-extras.js
    ../point_src/stage.js

---

Mirror a point, then draw a catenary curve between the two.

Any green point is draggable.

 */
function reflectPoint(origin, line) {
    const [p1, p2] = line;
    const x1 = p1.x, y1 = p1.y;
    const x2 = p2.x, y2 = p2.y;
    const x0 = origin.x, y0 = origin.y;

    // Calculate slope (m) and y-intercept (c) of the mirror line
    const m = (y2 - y1) / (x2 - x1);
    const c = y1 - m * x1;

    // Perpendicular slope (negative reciprocal)
    const m_p = -1 / m;

    // Equation of the perpendicular line through the origin point
    const c_p = y0 - m_p * x0;

    // Solve the intersection of the mirror line and the perpendicular line
    const x_intersect = (c_p - c) / (m - m_p);
    const y_intersect = m * x_intersect + c;

    // Reflect the origin point
    const x_prime = 2 * x_intersect - x0;
    const y_prime = 2 * y_intersect - y0;

    // Calculate the reflected angle
    const reflectedRadians = Math.atan2(y2 - y1, x2 - x1) * 2 - origin.radians;

    return { x: x_prime
            , y: y_prime
            , radians: reflectedRadians
            , radius: origin.radius
        };
}


class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        this.generatePlanetList()
        this.dis = new Dragging
        this.dis.initDragging(this)
        this.dis.addPoints(...this.points, this.origin, this.other)
        // this.dis.onDragEnd = this.onDragEnd.bind(this)
        this.dis.onDragMove = this.onDragMove.bind(this)
    }

    onDragMove(e,i) {
    // onDragEnd(e,i) {
        this.updateReflect()
    }

    generatePlanetList(){
        // origin = {x: 156, y: 135}
        // line = [{x:406, y:76}, {x:145, y:397}]
        let _a = new Point({x:406, y:76, radius: 20})
        let _b = new Point({x:145, y:397, radius: 20})
        this.origin = new Point({x: 156, y: 135, radius: 20})
        this.other = new Point({x: 150, y:150, radius: 20})
        this.points = new PointList(_a,_b)
        this.updateReflect()
        this.catenary = new CantenaryCurve(this.origin, this.reflect, 500)
        this.catenary.restLength = 430
    }

    updateReflect() {
        this.reflect = new Point(reflectPoint(this.origin, this.points))
        this.catenary && (this.catenary.b = this.reflect)
    }

    draw(ctx){



================================================================================
END: mirror-with-catenary-example.js
================================================================================



================================================================================
FILE: mitre-line.js
================================================================================

/*
title: Mitre Line
categories: lines
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/text/beta.js
    mouse
    ../point_src/random.js
    dragging
    stage
    stroke
    ../point_src/split.js
    ../point_src/bisector.js
    ../point_src/angle.js
*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        // this.point = this.center.copy().update({radius: 100})
        this.points = new PointList(
                [233, 325, 20]
                , [189, 169, 30]
                // , [442, 113, 30]
                // , [626, 215, 70]
                // , [525, 419, 20]
            ).cast()

        this.dragging.add(...this.points)
    }

    draw(ctx){
        this.clear(ctx)
        ctx.strokeStyle = '#444'
        this.points.pen.circle(ctx)
        ctx.strokeStyle = '#880000'
        let a = this.points[0]
        let b = this.points[1]

        let deg = radiansToDegrees(a.directionTo(b))
        a.rotation = quantizeAngle(deg, 4)

        deg = radiansToDegrees(b.directionTo(a))
        b.rotation = quantizeAngle(deg, 4)

        // a.rotation = 0
        // b.rotation = -180

        /* Draw a line from center, to the projected tip (radius)*/
        let aTip = a.project()
        a.pen.line(ctx, aTip)

        /* Draw a line from center, to the projected tip (radius)
        Other Line.*/
        let bTip = b.project()
        bTip.pen.line(ctx, b)

        /* Draw the line between the two target points.*/
        aTip.pen.line(ctx, bTip)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: mitre-line.js
================================================================================



================================================================================
FILE: moon-example.js
================================================================================

/*
---
title: Arc Angle
categories:
    arc
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    stage
    ../point_src/angle.js
    ../point_src/text/label.js
    ../point_src/arc.js
    ../point_src/protractor.js
 */

// aa = new Angle(20, 'tau')
// ab = new Angle(20).tau


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.centerPoint = new Point({x:200, y:200, radius: 100, color: '#666'})
        this.fromPoint = new Point({x:100, y:300})
        this.toPoint = new Point({x:350, y:150})
        this.dragging.addPoints(this.centerPoint
                                , this.fromPoint
                                , this.toPoint)

    }

    draw(ctx){
        this.clear(ctx)
        // a.rotation += .3
        // b.rotation += .5
        ctx.fillStyle = '#555'
        ctx.strokeStyle = 'orange'

        let primaryColor = '#CCC'
        let secondaryColor = '#444'
        let size = 30

        /* Draw an arc from rotation of `a` to rotation `b` */
        // centerPoint.pen.arc(ctx, b, primaryColor, size, 2, 0)
        // let a = this.a;
        // let b = this.b;
        // a.pen.arc(ctx, b, secondaryColor, size-10, 2, 1)
        // b.pen.arc(ctx, a, secondaryColor, size, 2, 0)


        this.centerPoint.pen.indicator(ctx)
        // this.centerPoint.pen.line(ctx, undefined, 'red')
        this.fromPoint.pen.indicator(ctx, {color: 'red'})
        this.toPoint.pen.indicator(ctx)

        // this.drawA(ctx)
        // this.drawB(ctx)
        // this.drawC(ctx)
        // this.drawD(ctx)
        this.drawE(ctx)
        // this.drawF(ctx)
    }

    drawA(ctx){

        let arcPlot = arcFromTo(this.centerPoint, this.fromPoint, this.toPoint)

        penArcPlot(arcPlot, ctx, 'orange')
        /* Get the arc angle drawn */
        let rads = getArcPlotAngle(arcPlot)
        /* Write the degrees at the center. */
        arcPlot.point.text.string(ctx, ~~rads)

    }

    drawB(ctx){

        let arcPlot = arcSweep(this.centerPoint, Math.PI * .5)

        penArcPlot(arcPlot, ctx, 'red')
        /* Get the arc angle drawn */
        let rads = getArcPlotAngle(arcPlot)
        /* Write the degrees at the center. */
        arcPlot.point.text.string(ctx, ~~rads)

    }

    drawC(ctx){

        // let arcPlot = arcFromTo(this.centerPoint, this.fromPoint, this.toPoint)
        /* Get the arc angle drawn */


================================================================================
END: moon-example.js
================================================================================



================================================================================
FILE: motion-line-example.js
================================================================================

/*
title: Example
categories: basic
    dragging
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    ../point_src/random.js
---

*/

class MotionLerp {

    constructor(point){
        this.point = point
        this._last = this.point.copy().subtract(20)
        this.tick = 0
    }

    step(){
        this.tick++;
        let p = this.point
        // this.point.draw.quadCurve(ctx, this._last)
        // ctx.stroke()
        // this.point.pen.quadCurve(ctx, this._last, p.color)
        this._last = this._last.lerp(p, .19)
        // this._last = p.copy()
    }

    drawLine(ctx) {
        let p = this.point
        p.pen.line(ctx, this._last, p.color, p.radius)
    }
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 ,
                radius: 5, rotation: 45,
                color: 'green'
            });
        this._last = this.point.copy().subtract(20)
        this.tick = 0

        this.dragging.add(this.point)
        this.ml = new MotionLerp(this.point)
    }

    firstDraw(ctx) {
        // ctx.lineCap = 'round'
        ctx.strokeStyle = 'red'
    }

    draw(ctx){
        // this.ml.tick++;
        this.clear(ctx)
        let p = this.point
        // this.point.draw.quadCurve(ctx, this._last)
        // ctx.stroke()
        // this.point.pen.quadCurve(ctx, this._last, p.color)
        // this.point.pen.line(ctx, this._last, p.color, p.radius)
        this.ml.step()
        // this.ml._last = this.ml._last.lerp(p, .5)
        // this._last = p.copy()
        this.point.pen.circle(ctx, p.radius, p.color);
        ctx.lineCap = 'butt'

        if(this.ml.tick % random.int(10,65) == 0) {
            ctx.lineCap = 'round'
            this.point.x = random.int(100, 500)
            this.point.y = random.int(100, 500)
        }
        this.ml.drawLine(ctx)
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: motion-line-example.js
================================================================================



================================================================================
FILE: motion-two-line.js
================================================================================

/*
title: Example
categories: basic
    dragging
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    ../point_src/random.js
    ../point_src/arc.js
---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 ,
                radius: 5, rotation: 45,
                color: 'green'
            });
        this.dragging.add(this.point)
        this.tick = 0
        this._last1 = this.point.copy()
        this._last0 = this.point.copy().subtract(20)
    }

    firstDraw(ctx) {
        // ctx.lineCap = 'round'
        ctx.strokeStyle = 'red'
    }

    draw(ctx){
        this.tick++;
        this.clear(ctx)
        let p = this.point
        this.point.pen.circle(ctx, p.radius, p.color)
        ctx.lineCap = 'butt'

        if(this.tick % 20 == 0) {
            this._last1 = this._last0
            this._last0 = this.point.copy()

            ctx.lineCap = 'round'
            this.point.x = random.int(100, 500)
            this.point.y = random.int(100, 500)

        }


        // let cap = this._last0.arc.to(this.point, this._last1)

        // if(cap) {
        //     ctx.beginPath();
        //     ctx.strokeStyle = 'green'
        //     ctx.arc(cap.cx, cap.cy, cap.radius, cap.startRadians, cap.toRadians, 1);
        //     ctx.stroke();
        // }

        // this._last0.pen.fill(ctx, 'red')
        this.point.pen.line(ctx, this._last0, '#DD0000', p.width)
        // this._last1.pen.fill(ctx, 'red')
        this._last1.pen.line(ctx, this._last0, '#550000', p.width)

    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: motion-two-line.js
================================================================================



================================================================================
FILE: mouse-indicator.js
================================================================================

/*
---
title: Widget: Mouse Indicator
tags: widget
files:
    head
    point
    mouse
    stage
    fps
    ../point_src/smooth-number.js
---

A "widget" presents the values in a small `div` indicator, connected to the
widget through a standard (Vue) reactive integration:

Add a widget:

    addWidget('example', {
        fields: {
            x: { value: 0 }
            , y: { value: 0 }
        }
    })

Update the widget with values:

    updateWidgetValues('diff', {
        x: 10
        , y: -20
    })


Raw example of updating the values within the widget:

    appShared.widgetsApp.widgets.example.fields.x = 100

Therefore to create a basic mouse widget:

    let widgetFields = appShared.widgetsApp.widgets.example.fields

    let pos = this.mouse.position
    widgetFields.x.value = ~~pos.x
    widgetFields.y.value = ~~pos.y

This is identical to the `updateWidgetValues` call

 */
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        console.log('in')

        addWidget('mouse', {
            showTitle: true
            , fields: {
                x: { value: 0/*, postfix: 'px' */}
                , y: { value: 0/*, postfix: 'px' */}
                , speed: { value: 0/*, postfix: 'px' */}
            }
        })

        this.mouse.zIndex = 'bound'
        this.speedNumber = new SmoothNumber()
        this.speedNumber.modulusRate = 5
        setTimeout(this.resize.bind(this), 20)
    }

    step() {
        let mouse = this.mouse
        let pos = mouse.position
        this.speedNumber.push(mouse.speed())
        updateWidgetValues('mouse',{
                'x': ~~pos.x
                , 'y': ~~pos.y

                , 'speed': Math.sqrt(this.speedNumber).toFixed(0)
                // , 'speed': Math.sqrt(mouse.modulatedSpeed()).toFixed(0)
                // , 'speed': mouse.speed()
            })
    }

    stepRaw() {
        let widget = getWidget('mouse')
        // let widget = appShared.widgetsApp?.widgets?.mouse.fields
        if(!widget){ return }
        let widgetFields = widget.fields
        let pos = this.mouse.position
        widgetFields.x.value = ~~pos.x
        widgetFields.y.value = ~~pos.y
    }

    step2() {
        let pos = this.mouse.position
        updateWidgetValue('mouse', 'x', ~~pos.x)
        updateWidgetValue('mouse', 'y', ~~pos.y)
    }




================================================================================
END: mouse-indicator.js
================================================================================



================================================================================
FILE: multi-scale-simple.js
================================================================================

/*
title: Multi-scale
categories: scaling
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/bisector.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
---

Multiscale - 2 points.

    alpha: 10
    , beta: 1
*/

const ratios = {
    alpha: 10
    , beta: 1
}


class RatioMachine {
    constructor(points) {

        this.expected = {}
        this.points = points
    }

    update(points=this.points) {
        let ms = new Set()
        for(let p of points) {
            let expected = this.getExpected(p)
            if(p.radius != expected) {
                console.log('mismatch on', p.uuid)
                ms.add(p)
            }
        }

        if(ms.size > 1) {
            console.warn('size mismatch')
        }
        this.updateRatio(...ms)
    }

    updateRatio(...ms) {
        // Update the ratio given the
        // value of init P.
        let p = ms[0]
        if(p == undefined) {return}
        let ratio = p._ratioName
        let expected = ratios[ratio]
        let newBase = p.radius * .2
        let mul = newBase / expected
        console.log(ratio, newBase, expected, mul)

        let i = 0
        for(let name in ratios) {
            let value = ratios[name];
            let p  = this.points[i]
            this.expected[p.uuid] = p.radius = (value * mul) * 5
            p._ratioName = name
            i++
        }
    }

    getExpected(p) {
        return this.expected[p.uuid]
    }

    setRatios(ratios){
        let i = 0
        for(let name in ratios) {
            let value = ratios[name];
            let p  = this.points[i]
            this.expected[p.uuid] = p.radius = value * 5
            p._ratioName = name
            i++
        }
    }
}


class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true


================================================================================
END: multi-scale-simple.js
================================================================================



================================================================================
FILE: multi-scale.js
================================================================================

/*
title: Multi-scale
categories: scaling
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/bisector.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
---

Multiscale assigns a map of relative sizes. Upon `update` the points are tested
for their expected size. If the current size does not match the expected, a rescale
of all points is performed.

    alpha: 1
    , beta: 2
    , charlie: 3
    , delta: 8
    , echo: 1.2
*/

const ratios = {
    alpha: 1
    , beta: 2
    , charlie: 3
    , delta: 8
    , echo: 1.2
}


class RatioMachine {
    constructor(points) {

        this.expected = {}
        this.points = points
    }

    update(points=this.points) {
        let ms = new Set()
        for(let p of points) {
            let expected = this.getExpected(p)
            if(p.radius != expected) {
                console.log('mismatch on', p.uuid)
                ms.add(p)
            }
        }

        if(ms.size > 1) {
            console.warn('size mismatch')
        }
        this.updateRatio(...ms)
    }

    updateRatio(...ms) {
        // Update the ratio given the
        // value of init P.
        let p = ms[0]
        if(p == undefined) {return}
        let ratio = p._ratioName
        let expected = ratios[ratio]
        let newBase = p.radius * .2
        let mul = newBase / expected
        console.log(ratio, newBase, expected, mul)

        let i = 0
        for(let name in ratios) {
            let value = ratios[name];
            let p  = this.points[i]
            this.expected[p.uuid] = p.radius = (value * mul) * 5
            p._ratioName = name
            i++
        }
    }

    getExpected(p) {
        return this.expected[p.uuid]
    }

    setRatios(ratios){
        let i = 0
        for(let name in ratios) {
            let value = ratios[name];
            let p  = this.points[i]
            this.expected[p.uuid] = p.radius = value * 5
            p._ratioName = name
            i++
        }
    }


================================================================================
END: multi-scale.js
================================================================================



================================================================================
FILE: multi-scene.js
================================================================================

/*
title: Multi Scene
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
---

This example has two running stages extending a single `BaseStage`.
Both scenes run concurrently on the canvas.

Only one `draw` method has a `clear` function, else we'd have two clear routines
per draw.
*/

class BaseStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })

    }

    updatePoints(points, target) {
        const distance = 20;
        points.forEach((point, index) => {
            const dx = target.x - point.x;
            const dy = target.y - point.y;
            const angle = Math.atan2(dy, dx);

            point.x = target.x - Math.cos(angle) * distance;
            point.y = target.y - Math.sin(angle) * distance;

            target = point;
        });
    }
}


class StageOne extends BaseStage {
    canvas='playspace'

    draw(ctx){
        this.clear(ctx)
        this.updatePoints(this.points, this.mouse.point)
        this.points.pen.line(ctx, { color: 'red'})
    }
}


class StageTwo extends BaseStage {
    canvas='playspace'

    draw(ctx){
        // this.clear(ctx)
        this.updatePoints(this.points, this.mouse.point)
        this.points.pen.circle(ctx, {color: 'green'})
    }
}


;stage1 = StageOne.go();
;stage2 = StageTwo.go();

setTimeout(()=>{
    console.log('Stages started:');
    events.emit('scene:go', { stage: stage1 });
    events.emit('scene:go', { stage: stage2, name: 'StageTwo' });
}, 100);

================================================================================
END: multi-scene.js
================================================================================



================================================================================
FILE: multi-tethered-point.js
================================================================================

/*
title: Tethered Controller Point
categories: binding
files:
    head
    point
    pointlist
    mouse
    stroke
    stage
    dragging
    ../point_src/random.js
    ../point_src/distances.js
    # ../point_src/tethers-xy.js
    ../point_src/tethers-vec.js
    ../point_src/stage-clock.js
    ../point_src/protractor.js
---

*/
addButton('Add Point',{
    onclick(){
        stage.addNewPoint()
    }
})

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        // this.createPoints()
        // this.dragging.add(...this.points, ...this.controlPoints)
        const p = this.point = new Point(200, 200, 100)
        this.dragging.add(p)
        const c = this.addNewPoint()
        // this.addNewPoint()
        // this.point.rotationSet = function(){
        //     // let v = p.getTheta(c, -p.radians) % Math.PI2
        //     let v = calculateAngle180(p, c);
        //     // v = calculateInverseAngle180(p, c);
        //     // v = calculateAngle360(p, c)
        //     console.log(v)
        // }

    }

    addNewPoint() {
        let pos = random.within(this.point, 1)
        let cp = this.point.tethers.add(pos)
        this.dragging.add(cp)
        return cp
    }

    draw(ctx){
        this.clear(ctx)
        let p = this.point
        if(this.clock.tick % 1 == 0) {
            p.tethers.step()
        }

        p.pen.indicator(ctx, {color: '#336600'})

        p.tethers.points.forEach((tp)=>{
            p.pen.line(ctx, tp, '#880000', 2)
        });

        p.tethers.points.pen.fill(ctx, '#33DDAA')
        // p.tethers.points.pen.line(ctx,{color: '#33DDAA'})
        // p.tethers.points.pen.(ctx,{color: '#33DDAA'})
    }
}



;stage = MainStage.go();

================================================================================
END: multi-tethered-point.js
================================================================================



================================================================================
FILE: multisheet-component-v1.js
================================================================================

/*
title: Multisheet Component V1
*/
console.log('multisheet-component')

const plog = function(){
    let s = Array.from(arguments).join(' ')
    console.log(`%c ${s}`, 'background: #111; color: #bada55');
}


class PolypointCanvas extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.buildView(this.createStyles());
        this.setupListeners();
    }

    scriptType = 'javascript'

    static get observedAttributes() {
        return ['width', 'height'];
    }

    createStyles(){
        const dce = document.createElement.bind(document);
        const style = dce('style');
        style.textContent = `
            :host { display: block; }
            canvas { display: block; border: 1px solid #ccc; }
            div { font-family: sans-serif; }
            .code-content { white-space: pre-line; font-family: monospace; }
          `;
        this._style = style;
        return style;
    }

    setupListeners(){
        this.configSlot.addEventListener('slotchange', () => {
            this.parseSlotConfig();
            this.setupCanvas();
        });
        this.textSlot.addEventListener('slotchange', () => {
            this.parseTextSlot();
        });
    }

    buildView(style){
        const dce = document.createElement.bind(document);
        const wrapper = dce('div');
        this.canvas = dce('canvas');
        this.textDiv = dce('div');
        this.textDiv.classList.add('text-content');
        this.codeDiv = dce('div');
        this.codeDiv.classList.add('code-content');
        this.configSlot = dce('slot');
        this.configSlot.name = 'config';
        this.codeSlot = dce('slot');
        this.codeSlot.name = 'code';
        this.textSlot = dce('slot');
        this.textSlot.name = 'text';

        wrapper.append(this.canvas, this.textDiv, this.codeDiv, this.configSlot, this.codeSlot, this.textSlot);
        this.shadowRoot.append(style, wrapper);
    }

    connectedCallback() {
        requestAnimationFrame(() => {
            this.parseSlotConfig();
            const isFallback = this.parseTextAsFallbackCode();
            this.parseCodeSlot();
            this.parseTextSlot(isFallback);
            this.setupCanvas();
        });
    }

    attributeChangedCallback() {
        this.setupCanvas();
    }

    parseSlotConfig() {
        let configNode = null;
        const nodes = this.configSlot.assignedNodes({ flatten: true });
        configNode = nodes.find(n => n.nodeType === Node.TEXT_NODE || n.nodeType === Node.ELEMENT_NODE);

        if (!configNode) {
            const script = this.querySelector('script[type="application/json"]');
            if (script) {
                configNode = script;
            } else {
                return;
            }
        }

        let json = configNode.textContent.trim();
        try {
            const config = JSON.parse(json);
            for (const [k, v] of Object.entries(config)) {
                this.setAttribute(k, v);


================================================================================
END: multisheet-component-v1.js
================================================================================



================================================================================
FILE: multisheet-component-v2.js
================================================================================

/*
title: Multisheet Component V2
*/
console.log('multisheet-component')

const plog = function(){
    let s = Array.from(arguments).join(' ')
    console.log(`%c ${s}`, 'background: #111; color: #bada55');
}


class PolypointCanvas extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.buildView(this.createStyles());
        this.setupListeners();
    }

    scriptType = 'javascript'

    static get observedAttributes() {
        return ['width', 'height'];
    }

    createStyles(){
        const dce = document.createElement.bind(document);
        const style = dce('style');
        style.textContent = `
            :host { display: block; }
            canvas { display: block; border: 1px solid #ccc; }
            div { font-family: sans-serif; }
            .code-content { white-space: pre-line; font-family: monospace; }
          `;
        this._style = style;
        return style;
    }

    setupListeners(){
        this.configSlot.addEventListener('slotchange', () => {
            this.parseSlotConfig();
            this.setupCanvas();
        });

        this.textSlot.addEventListener('slotchange', () => {
            this.parseTextSlot();
        });
    }

    buildView(style){
        const dce = document.createElement.bind(document);
        const wrapper = dce('div');
        this.canvas = dce('canvas');
        this.textDiv = dce('div');
        this.textDiv.classList.add('text-content');
        this.codeDiv = dce('div');
        this.codeDiv.classList.add('code-content');
        this.configSlot = dce('slot');
        this.configSlot.name = 'config';
        this.codeSlot = dce('slot');
        this.codeSlot.name = 'code';
        this.textSlot = dce('slot');
        this.textSlot.name = 'text';

        wrapper.append(this.canvas, this.textDiv, this.codeDiv, this.configSlot, this.codeSlot, this.textSlot);
        this.shadowRoot.append(style, wrapper);
    }

    connectedCallback() {
        requestAnimationFrame(() => {
            this.parseSlotConfig();
            const isFallback = this.parseTextAsFallbackCode();
            this.parseCodeSlot();
            this.parseTextSlot(isFallback);
            this.setupCanvas();
        });
    }

    attributeChangedCallback() {
        this.setupCanvas();
    }

    parseSlotConfig() {
        let configNode = null;
        const nodes = this.configSlot.assignedNodes({ flatten: true });
        configNode = nodes.find(n => n.nodeType === Node.TEXT_NODE || n.nodeType === Node.ELEMENT_NODE);

        if (!configNode) {
            const script = this.querySelector('script[type="application/json"]');
            if (script) {
                configNode = script;
            } else {
                return;
            }
        }

        let json = configNode.textContent.trim();
        try {
            const config = JSON.parse(json);
            for (const [k, v] of Object.entries(config)) {


================================================================================
END: multisheet-component-v2.js
================================================================================



================================================================================
FILE: multisheet.js
================================================================================

/*
title: 3D Sphere
categories: pseudo3D
files:
    head
    point
    pointlist
    mouse
    stage
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js
    ../theatre/multisheet-component.js
---


*/
function generateSpherePoints(count = 100, radius = 1) {
  const points = [];
  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399...

  for (let i = 0; i < count; i++) {
    const y = 1 - (i / (count - 1)) * 2; // y from 1 to -1
    const r = Math.sqrt(1 - y * y);      // radius at y
    const theta = goldenAngle * i;      // angle around y-axis

    const x = Math.cos(theta) * r;
    const z = Math.sin(theta) * r;

    points.push({ x: x * radius, y: y * radius, z: z * radius});
  }

  return points;
}


function generateSpherePoints1(count = 100, radius = 1) {
  const points = [];
  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399...

  for (let i = 0; i < count; i++) {
    const y = 1 - ((i + 0.9) / count) * 2;  // avoid exact poles
    const r = Math.sqrt(1 - y * y);        // radius at this y
    const theta = goldenAngle * i;

    const x = Math.cos(theta) * r;
    const z = Math.sin(theta) * r;

    points.push({ x: x * radius, y: y * radius, z: z * radius });
  }

  return points;
}



function generateSpherePointsFib(count = 100, radius = 1) {
  const points = [];
  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399

  for (let i = 0; i < count; i++) {
    // let y = 1 - (i + 0.5) * (2 / count);
    const y = 1 - ((i + 0.5) / count) * 2;        // y in (-1, 1)
    const r = Math.sqrt(1 - y * y);               // radius at y
    const theta = goldenAngle * i;

    const x = Math.cos(theta) * r;
    const z = Math.sin(theta) * r;

    points.push({
      x: x * radius,
      y: y * radius,
      z: z * radius
    });
  }

  return points;
}


window.onmessage = function(e) {
    // console.log(e)
    stage.perspectiveCenter.set(e.data)
};


class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        let depth = this.depth = 500
        let count = 500
        let size = 290
        /* Generate 100 points, within a 500px box, at origin 0,0 */
        this.points = PointList.from(generateSpherePointsFib(count, size)).cast()
        // this.points = PointList.from(generateSpherePointsFib(count, size)).cast()
        this.points.each.radius = 2
        // this.projectionPoint = this.points.center.copy()


================================================================================
END: multisheet.js
================================================================================



================================================================================
FILE: near-point-example.js
================================================================================

/*
title: Near Point Example
categories: distances
*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.center.radius = 50

        let radius = 7
        let rowCount = 5 /* How many items per row within the grid */
        let count = 200
        const pointList = PointList.generate.list(count, 0)

        /* To set the position of the grid generator, we can just edit the
        first point. */
        pointList[0].set(50, 50)
        /* Then reshape internally */
        // let pointSpread = 150 /* Distance between points */
        // pointList.shape.grid(pointSpread, rowCount)
        pointList.shape.random(600, rowCount)
        pointList.setMany(radius, 'radius')
        this.points = pointList
        this.dis = new Distances
        this.dis.addPoints(...pointList)
    }

    draw(ctx){
        this.clear(ctx)

        let mousePoint = Point.mouse.position
        this.points.lookAt(mousePoint)
        /* Draw each point; wrapping the _draw_ call_ with our own functionality.*/
        this.points.pen.indicators(ctx, { color: 'gray', width: 1})

        // let v = this.dis.closest(mousePoint)
        let v = this.dis.near(mousePoint, 200)

        for(const p of v){
            p.pen.indicator(ctx, { color: 'green', width: 3})
        }
        // console.log(v.length)
    }
}

stage = MainStage.go()


================================================================================
END: near-point-example.js
================================================================================



================================================================================
FILE: neural-net-rendering.js
================================================================================

/*
title: Neural Net Example
categories: arrange
files:
    head
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    stage
    point
    pointlist
    ../point_src/distances.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/dragging.js
    stroke
    ../point_src/split.js
    ../point_src/relative.js
    ../point_src/automouse.js
    ../point_src/collisionbox.js
---

A quick example for generating a standard neural net.
*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted() {
        this.toEdges = true
        this.stack = [
                3, 5, 3
            ]

        this.createNet()
    }

    createNet(stack=this.stack){
        let spreadY = 50
            , spreadX = 150
        let top = 100
            , left = 100

        let points = []
            , maxVal = Math.max.apply(Math, stack)
            ;

        for(let stackItem of stack) {
            let i = points.length
            let offset = ((maxVal * spreadY) - (spreadY * stackItem)) * .5

            let ps = PointList.generate.list(stackItem
                    , spreadY // distance between nodes in one column.
                    , [left + (spreadX * i), top + offset]
                );
            ps.each.radius = 19
            points.push(ps)
            this.dragging.add(...ps)
        }

        this.points = points;
    }

    draw(ctx) {
        this.clear(ctx);

        // ctx.fillStyle = '#DDD'
        ctx.font = '600 10px sans-serif'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        this.renderGraph(ctx)
    }

    renderGraph(ctx){
        // Iter each column
        let toEdges = this.toEdges
        this.points.forEach((ps, i, a)=>{
            // If the next column exists.
            // For each item in the column
            let lineColor = '#111154';
            ps.forEach((p,j)=>{

                if(a[i+1]) {
                    // Each item in the _next_ column_.
                    ctx.fillStyle = '#fff'
                    a[i+1].forEach((op, k)=>{
                        if(toEdges) {
                            let [front, back] = p.split(2)
                            let [tofront, toback] = op.split(2)
                            front.pen.line(ctx, toback, lineColor, 2)
                        } else {
                            p.pen.line(ctx, op, lineColor, 2)
                        }

                        let midPoint = p.lerp(op, .5)
                        let mpv = String(Math.random()).slice(0, 5);
                        midPoint.text.label(ctx, mpv)
                    })
                }
                // stage.points[2][2].text.string('12')


================================================================================
END: neural-net-rendering.js
================================================================================



================================================================================
FILE: ngon-example.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    stage
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/
class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.point = this.center.copy()
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.ngon(ctx, 6, 100, 1, '#880000', 2, Math.PI )
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: ngon-example.js
================================================================================



================================================================================
FILE: noding-arrows-styled.js
================================================================================

/*
title: Titles on "Nodes"
files:
    head
    point
    pointlist
    stage
    ../point_src/text/beta.js
    ../point_src/random.js
    dragging
    stroke
    mouse
---

Automatically apply a alpha label, given the position within a list of points.
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.stroke = new Stroke({
            color: '#4466AA'
            , width: 5
        })

        let pts = PointList.generate.random(5, [600, 600], {x:100, y:100})
        pts.each.radius = 15
        pts.each.rotation = 0

        this.points = pts
        this.dragging.add(...pts)
    }

    firstDraw(ctx) {
        ctx.font = '400 22px sans-serif'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        this.stroke.set(ctx)
    }

    draw(ctx){
        this.clear(ctx)
        let lineColor = this.stroke.settings.color
        let lineWidth = this.stroke.settings.width
        let padding = 10
        let st = this.stroke
        let pts = this.points

        pts.pen.fill(ctx, '#000000AA')
        pts.pen.stroke(ctx)

        pts.forEach((p, i, a)=>{
            let t = String.fromCharCode(97 + i)

            let next = a[i+1]

            ctx.fillStyle = lineColor
            ctx.strokeWidth = 3
            if(next) {
                next.lookAt(p)
                p.lookAt(next)
                let pfrom = p.project(p.radius)
                let pto = next.project(next.radius + padding + 15)
                pfrom.pen.line(ctx, pto, lineColor, lineWidth)

                let rot = pto.directionTo(next)
                pto.pen.ngon(ctx, 3, 5, true, lineColor, 2, rot)

                ctx.fill()
            }

            // ctx.fillStyle = '#DDD'
            // p.text.fill(ctx, t.toUpperCase())
        })

    }
}

stage = MainStage.go()


================================================================================
END: noding-arrows-styled.js
================================================================================



================================================================================
FILE: noding-arrows.js
================================================================================

/*
title: Titles on "Nodes"
files:
    head
    point
    pointlist
    stage
    ../point_src/text/beta.js
    ../point_src/random.js
    dragging
    stroke
    mouse
---

Automatically apply a alpha label, given the position within a list of points.
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.stroke = new Stroke({
            color: '#33aaFF'
            , width: 3
            , dash: [5, 5]
            , march: .1
        })

        let pts = PointList.generate.random(5, [600, 400], {x:100, y:100})
        pts.each.radius = 40
        pts.each.rotation = 0

        this.points = pts
        this.dragging.add(...pts)
    }

    draw(ctx){
        this.clear(ctx)
        let lineColor = '#990000'
        let padding = 15
        // let lineColor = 'purple'
        let st = this.stroke
        let pts = this.points

        st.step()
        st.wrap(ctx, ()=>{
            pts.pen.stroke(ctx)
            pts.pen.fill(ctx, '#000000AA')
        })

        ctx.fillStyle = '#DDD'
        ctx.font = '400 22px sans-serif'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        pts.forEach(function(p, i, a){
            let t = String.fromCharCode(97 + i)
            ctx.fillStyle = '#DDD'
            p.text.fill(ctx, t.toUpperCase())
            let next = a[i+1]
            if(next) {
                next.lookAt(p)
                p.lookAt(next)
                let pfrom = p.project(p.radius + padding)
                let pto = next.project(next.radius + padding + 10)
                pfrom.pen.line(ctx, pto, lineColor, 2)

                // pto.pen.fill(ctx, lineColor, 10)
                let rot = pto.directionTo(next)
                pto.pen.ngon(ctx, 3, 5, true, lineColor, 2, rot)
                ctx.fillStyle = '#880000'
                ctx.fill()
            }
        })

    }
}

stage = MainStage.go()


================================================================================
END: noding-arrows.js
================================================================================



================================================================================
FILE: noding.js
================================================================================

/*
title: Titles on "Nodes"
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/stage-clock.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/text/beta.js
    ../point_src/curve-extras.js
    ../point_src/random.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/functions/within.js
    ../point_src/automouse.js
---

Automatically apply a alpha label, given the position within a list of points.
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.stroke = new Stroke({
            color: '#33aaFF'
            , width: 3
            , dash: [5, 5]
            , march: .1
        })

        let pts = PointList.generate.random(5, [600, 400], {x:100, y:100})
        pts.each.radius = 40
        pts.each.rotation = 0

        this.points = pts
        this.dragging.add(...pts)
    }

    draw(ctx){
        this.clear(ctx)

        let st = this.stroke
        let pts = this.points

        st.step()
        st.wrap(ctx, ()=>{
            pts.pen.stroke(ctx)
            pts.pen.fill(ctx, '#000000AA')
        })

        ctx.fillStyle = '#DDD'
        ctx.font = '400 22px sans-serif'
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'

        pts.forEach(function(p, i, a){
            let t = String.fromCharCode(97 + i)
            p.text.fill(ctx, t.toUpperCase())
        })

    }
}

stage = MainStage.go()


================================================================================
END: noding.js
================================================================================



================================================================================
FILE: objects/balloon.js
================================================================================

/*
title: Balloon
*/

class Balloon {

    defaults = {
            gravity: -.31
            , ropePointLength: 20
            , segmentLength: 10
            , invMass: .2
            , color: '#990000'
            , knotColor: '#550000'
            , ropeColor: '#AAA'
            , radius: 60
            // , position: [1,1]
        }

    constructor(settings={}){

        Object.assign(this, this.defaults, settings)

        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })
        if(this.position) {
            this.mounted()
        }
    }

    mounted(initPos=this.position) {
        // this.ropePointLength = 20;
        // this.segmentLength = 10;
        // this.gravity = -.31;
        // this.gravity2D = gravity2D

        // let initPos = this.center.copy()
        this.points = this.ropePoints(initPos, this.ropePointLength * .5)
        this.points2 = this.ropePoints(initPos, this.ropePointLength)
        let penUlt = this.points[this.points.length - 3]
        // penUlt.invMass = 200
        let lastPoint = this.points.last()
        lastPoint.invMass = this.invMass
        lastPoint.radius = this.radius

        this.ropeReactor = new RopeReactor()
        this.visibleRopeReactor = new RopeReactor()

        this.points[0].copy(initPos.add(10,100))
        this.points2[0].copy(initPos.add(10,100))


        this.visibleRopeReactor.pin(0)
        this.ropeReactor.pin(0)
        this.visibleRopeReactor.pin(this.points2.length-1, this.points[this.points.length - 3])
        // this.visibleRopeReactor.pin(5)
    }

    ropePoints(initPos, ropePointLength){
        let points = Array.from({ length: ropePointLength }, () => ({
            x: initPos.x,
            y: initPos.y,
            oldX: initPos.x,
            oldY: initPos.y,
        }));
        // points[9].invMass = .01
        return new PointList(...points).cast()
    }

    get head() {
        return this.points.last()
    }

    get handle() {
        return this.points[0]
    }

    step(){
        /* A viscous fluid, applied through 2d invMass*/
        // this.applyPhysics2(this.points, this.gravity2D, [1, this.points.length-1]);
        let ropeReactor = this.ropeReactor
        let visibleRopeReactor = this.visibleRopeReactor
        /* Rope like mass physics.*/
        ropeReactor.applyPhysics(this.points, this.gravity);
        visibleRopeReactor.applyPhysics(this.points2, Math.abs(this.gravity)); // Gravity of rop is positive (pushing down)

        // ropeReactor.applyPhysics2(this.points, this.gravity2D)

        /* Different solving methods */
        // this.solveConstraints1(this.points, this.segmentLength);
        // this.solveConstraints2(this.points, this.segmentLength);
        ropeReactor.solveConstraints3(this.points, this.segmentLength * 3);
        visibleRopeReactor.solveConstraints3(this.points2, this.segmentLength);
    }

    draw(ctx) {
        // this.clear(ctx);
        this.points2[0].xy = this.points[0].xy



================================================================================
END: objects/balloon.js
================================================================================



================================================================================
FILE: objects/sphere.js
================================================================================

/*
title: Sphere
*/

function generateSpherePoints(count = 100, radius = 1) {
  const points = [];
  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399...

  for (let i = 0; i < count; i++) {
    const y = 1 - (i / (count - 1)) * 2; // y from 1 to -1
    const r = Math.sqrt(1 - y * y);      // radius at y
    const theta = goldenAngle * i;      // angle around y-axis

    const x = Math.cos(theta) * r;
    const z = Math.sin(theta) * r;

    points.push({ x: x * radius, y: y * radius, z: z * radius});
  }

  return points;
}


function generateSpherePoints1(count = 100, radius = 1) {
  const points = [];
  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399...

  for (let i = 0; i < count; i++) {
    const y = 1 - ((i + 0.9) / count) * 2;  // avoid exact poles
    const r = Math.sqrt(1 - y * y);        // radius at this y
    const theta = goldenAngle * i;

    const x = Math.cos(theta) * r;
    const z = Math.sin(theta) * r;

    points.push({ x: x * radius, y: y * radius, z: z * radius });
  }

  return points;
}



function generateSpherePointsFib(count = 100, radius = 1) {
  const points = [];
  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399

  for (let i = 0; i < count; i++) {
    // let y = 1 - (i + 0.5) * (2 / count);
    const y = 1 - ((i + 0.5) / count) * 2;        // y in (-1, 1)
    const r = Math.sqrt(1 - y * y);               // radius at y
    const theta = goldenAngle * i;

    const x = Math.cos(theta) * r;
    const z = Math.sin(theta) * r;

    points.push({
      x: x * radius,
      y: y * radius,
      z: z * radius
    });
  }

  return points;
}


function generateSpherePointsLatLong(latCount = 10, lonCount = 20, radius = 1) {
  const points = [];

  // Latitude from 0 (north pole) to PI (south pole)
  for (let lat = 0; lat <= latCount; lat++) {
    const theta = (lat * Math.PI) / latCount; // polar angle
    const y = Math.cos(theta);                // y = cos(theta)
    const r = Math.sin(theta);                // horizontal radius at this latitude

    // Longitude from 0 to 2*PI
    for (let lon = 0; lon < lonCount; lon++) {
      const phi = (lon * 2 * Math.PI) / lonCount; // azimuthal angle

      const x = Math.cos(phi) * r;
      const z = Math.sin(phi) * r;

      points.push({
        x: x * radius,
        y: y * radius,
        z: z * radius
      });
    }
  }

  return points;
}


function generateSphereTriangles(latCount = 10, lonCount = 20) {
  const indices = [];

  for (let lat = 0; lat < latCount; lat++) {
    for (let lon = 0; lon < lonCount; lon++) {


================================================================================
END: objects/sphere.js
================================================================================



================================================================================
FILE: objects/spinplotter.js
================================================================================

/*
title: Spinplotter
*/

class SpinPlotter extends Point {

    created() {
        this.plotList = new PointList()

        let o = {
            slideSpeed: [2]
            , spinSpeed: 2
            , maxPlotCount: 200
            , plotModulo: 20
            , plotColor: '#ccc'
            , lineWidth: 1
            , sliceCount: 2
            , direction: 'sin'
            , periodOffset: 0
        }

        for(let k in o) {
            if(this[k] === undefined) {
                this[k] = o[k]
            }
        }

        this._ticker = 0
    }

    getNormValue() {
        /* return -1 0 1 for centroid scale of the spin. */
        let brushTipSin = this.getBrush()
        /* Define the axis to normalise. Math.PI*.5 is `sin` or y,
        because it's 1/4 PI, with the 0 degree on the horizontal line. */
        let axis = Math.PI * .5
        if(this.direction == 'cos') {
            // Check the horizontal.
            axis = 0
        }

        const sLR = signedNorm(brushTipSin, this, this.radius, axis, this.periodOffset);
        return sLR
    }


    getBrush() {

        if(this.brush !== undefined) {
            return this.brush
        }

        let tip = this.project()

        return {
            'sin': ()=> new Point(this.x, tip.y)
            , 'cos': ()=> new Point(tip.x, this.y)
            , 'both': ()=> tip
        }[this.direction]()

        // let brushTipSin = new Point(this.x, tip.y)
        // let brushTipCos = new Point(tip.x, this.y)
        // return brushTipSin
    }
    checkSlice() {
        let plotList = this.plotList
        if(plotList.length > this.maxPlotCount) {
            plotList = plotList.slice(this.sliceCount)
        }
        return plotList
    }

    render(ctx) {
        this.rotation += this.spinSpeed
        this._ticker++;

        // let plotList = this.plotList;
        let brushTipSin = this.getBrush()
        let plotList = this.updatePlot(this.plotList, brushTipSin)
        this.drawPrimaryPoint(ctx)
        this.drawPlotList(ctx, plotList)
        this.drawBrush(ctx, brushTipSin)

    }

    updatePlot(plotList=this.plotList, brushPoint=this.getBrush()) {
        if(this._ticker % this.plotModulo == 0) {
            plotList.push(brushPoint.copy())
        }

        this.plotList = plotList = this.checkSlice()

        // Fill plots
        plotList.forEach((p)=>{
            p.xy = p.add(this.slideSpeed)
        })

        return plotList
    }



================================================================================
END: objects/spinplotter.js
================================================================================



================================================================================
FILE: objects/tetra.js
================================================================================

/*
title: Tetra
*/


function generateRadialTetrahedronMesh(targetCount = 500, radius = 1) {
  const sqrt3 = Math.sqrt(3);

  const vertices = [
    [1, 1, 1],
    [-1, -1, 1],
    [-1, 1, -1],
    [1, -1, -1],
  ];

  const faces = [
    [0, 1, 2],
    [0, 3, 1],
    [0, 2, 3],
    [1, 3, 2],
  ];

  const normalize = ([x, y, z]) => {
    const len = Math.sqrt(x * x + y * y + z * z);
    return [x / len * radius, y / len * radius, z / len * radius];
  };

  const allPoints = [];
  const allTriangles = [];
  let indexOffset = 0;

  const pointsPerFace = Math.floor(targetCount / 4);

  function sampleFace(v0, v1, v2, count, indexOffset) {
    const pts = [];
    const tris = [];

    const n = Math.ceil(Math.sqrt(count));
    for (let i = 0; i <= n; i++) {
      for (let j = 0; j <= n - i; j++) {
        const a = i / n;
        const b = j / n;
        const c = 1 - a - b;
        const x = a * v0[0] + b * v1[0] + c * v2[0];
        const y = a * v0[1] + b * v1[1] + c * v2[1];
        const z = a * v0[2] + b * v1[2] + c * v2[2];
        pts.push(normalize([x, y, z]));
      }
    }

    // approximate triangle connection for now  could be refined
    let pointIndex = 0;
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n - i; j++) {
        const a = pointIndex;
        const b = pointIndex + 1;
        const c = pointIndex + (n - i + 1);
        const d = c + 1;

        if (j < n - i - 1) {
          tris.push([indexOffset + a, indexOffset + b, indexOffset + c]);
          tris.push([indexOffset + b, indexOffset + d, indexOffset + c]);
        } else {
          tris.push([indexOffset + a, indexOffset + b, indexOffset + c]);
        }

        pointIndex++;
      }
      pointIndex++;
    }

    return { pts, tris };
  }

  for (const face of faces) {
    const [v0, v1, v2] = face.map(i => vertices[i]);
    const { pts, tris } = sampleFace(v0, v1, v2, pointsPerFace, indexOffset);
    allPoints.push(...pts);
    allTriangles.push(...tris);
    indexOffset += pts.length;
  }

  const pointList = allPoints.map(([x, y, z]) => ({ x, y, z }));

  return {
    points: pointList,
    triangles: allTriangles,
  };
}



function generateFlatTetrahedronMesh(targetCount = 500, size = 1) {
  // Regular tetrahedron, centered at origin
  const sqrt3 = Math.sqrt(3);
  const sqrt6 = Math.sqrt(6);
  const vertices = [
    [0, 0, size * Math.sqrt(6) / 4],  // Top vertex
    [0, size / Math.sqrt(3), -size / 4], // Base vertex 1
    [-size / 2, -size / (2 * Math.sqrt(3)), -size / 4], // Base vertex 2


================================================================================
END: objects/tetra.js
================================================================================



================================================================================
FILE: objects/vectorpoint.js
================================================================================

/*
title: Vectorpoint
files:
    ../point_src/random.js
    ../point_src/tethers.js

Apply _vector Arrows_ as from the point center, to the _tip_.

    vp = new VectorPoint(100,200)
    vp.addNewPoint()
    vp.render(ctx)
 */
class VectorPoint extends Point {

    addNewPoint(pos=random.within(this, 1)) {
        // let pos = random.within(this, 1)
        let cp = this.tethers.add(pos)
        return cp
    }

    render(ctx, style={color:'#880000', width: 2}){
        let p = this

        // if(this.clock.tick % 1 == 0) {
            this.tethers.step()
        // }

        this.pen.indicator(ctx, {color: '#336600'})
        this.tethers.points.forEach((tp)=>{
            this.pen.line(ctx, tp, style.color, style.width)
        });

        this.renderTip(ctx, style)
        this.renderText(ctx)
    }

    renderTip(ctx, style){
        let cp = this.getTip()
        // let cp = this.tethers.points[0]
        let angle = this.directionTo(cp)
        // p.tethers.points[0].radians
        cp.pen.ngon(ctx, 3, cp.radius, true, style.color, style.width, angle)

        ctx.fillStyle = style.color
        ctx.fill()

    }

    getTip() {
        return this.tethers.points[0]
    }

    getComputed() {
        let cp = this.getTip()
        let t2d = this.distance2D(cp)
        // t2d = [t2d.x/10, t2d.y/10]
        return t2d;
    }

    setComputed(pos, relative=true) {
        let cp = this.getTip()
        let t2d
        if(relative) {
            t2d = (new Point(pos))
        } else {
            t2d = (new Point(pos)).multiply(10)
        }
        // console.log(t2d.xy)
        // t2d = [t2d.x * 10, t2d.y * 10]
        cp.controlPointsDistance = t2d
        return t2d;
    }

    renderText(ctx) {
        ctx.fillStyle = '#DDD'
        let t2d = this.getComputed()
        let t2ds = `x=${t2d.x} y=${t2d.y}`
        this.text.label(ctx, t2ds, new Point([0, -10]))
    }
}


================================================================================
END: objects/vectorpoint.js
================================================================================



================================================================================
FILE: objects/vectors/controller.js
================================================================================

/*
title: Controller
*/

// Gamepad integration
/**
 * Controller mapping profiles for different gamepad types
 */
const CONTROLLER_PROFILES = {
    // Standard Xbox-style controller
    XBOX: {
        name: 'Xbox Controller',
        axes: {
            leftStickX: 0,
            leftStickY: 1,
            rightStickX: 2,
            rightStickY: 3
        },
        buttons: {
            leftTrigger: 7,
            rightTrigger: 6,
            buttonA: 0,
            buttonB: 1,
            buttonBack: 8
        },
        triggerAsButton: true  // Triggers are buttons (0-1 value)
    },

    // Radiomaster TS16S RC Transmitter
    // Typical RC transmitter stick layout:
    // - Right stick: Throttle (vertical), Rudder (horizontal)
    // - Left stick: Elevator (vertical), Aileron (horizontal)
    RADIOMASTER_TS16S: {
        name: 'Radiomaster TS16S',
        axes: {
            // Physical right stick controls leftStick state
            leftStickY: 2,       // Throttle - axis 1 (physical right stick vertical)
            leftStickX: 3,       // axis 2 (physical right stick horizontal)

            // Physical left stick controls rightStick state
            rightStickY: 1,      // axis 0 (physical left stick vertical)
            rightStickX: 0       // axis 3 (physical left stick horizontal)
        },
        buttons: {
            // RC transmitters typically map switches to buttons
            buttonA: 0,          // Switch A
            buttonB: 1,          // Switch B
            buttonBack: 3        // Menu/Back button
        },
        triggerAsAxis: true,     // Use axes for throttle control
        throttleAxis: 2,         // Throttle on axis 1
        throttleRange: [-1, 1]   // Full range from -1 to 1
    }
}

/**
 * 1. Capture first gamepad
 * 2. Support multiple controller profiles (Xbox, RC Transmitters)
 * 3. Map controller inputs to unified state
 */
class GamepadController {
    constructor(profile = 'XBOX') {
        this.connected = false
        this.gamepad = null
        this.deadzone = 0.015  // Ignore small stick movements

        // Set controller profile
        this.setProfile(profile)

        // Gamepad state dictionary (unified interface)
        this.state = {
            leftStickX: 0,      // Left stick horizontal (-1 to 1)
            leftStickY: 0,      // Left stick vertical (-1 to 1)
            rightStickX: 0,     // Right stick horizontal (-1 to 1)
            rightStickY: 0,     // Right stick vertical (-1 to 1)
            leftTrigger: 0,     // Left trigger (0 to 1)
            rightTrigger: 0,    // Right trigger (0 to 1)
            buttonA: false,
            buttonB: false,
            buttonBack: false,   // Back/Select button (button 8)
            buttonBackPressed: false  // Track button press for edge detection
        }

        this.setupGamepadListeners()
    }

    /**
     * Set the controller profile for input mapping
     * @param {string} profileName - Name of the profile ('XBOX', 'RADIOMASTER_TS16S')
     */
    setProfile(profileName) {
        if (CONTROLLER_PROFILES[profileName]) {
            this.profile = CONTROLLER_PROFILES[profileName]
            console.log(`Controller profile set to: ${this.profile.name}`)
        } else {``
            console.warn(`Unknown profile: ${profileName}, using XBOX`)
            this.profile = CONTROLLER_PROFILES.XBOX
        }
    }



================================================================================
END: objects/vectors/controller.js
================================================================================



================================================================================
FILE: objects/vectors/physics.js
================================================================================

/*
title: Physics
*/

// ============================================================================
// MOMENT OF INERTIA CALCULATION
// ============================================================================

/**
 * Calculate the moment of inertia for a rigid body system around its center of mass.
 *
 * SIMPLIFIED API:
 * All bodies (ship, engines, cargo, fuel tanks) are treated uniformly as mass points.
 * The difference between "engines" and "cargo" is only that engines apply force -
 * both contribute equally to moment of inertia based on their mass and position.
 *
 * @param {Object} centerOfMass - The pivot point {x, y}
 * @param {Object} mainBody - The main rigid body with {x, y, mass, radians}
 * @param {Array} bodies - Array of ALL mass-bearing objects:
 *                         - World-space bodies: {x, y, mass} (engines, asteroids, etc.)
 *                         - Local-space bodies: {x, y, mass, isLocal: true} (cargo, fuel)
 *                         Local-space bodies will be rotated by mainBody.radians
 * @returns {number} The moment of inertia (I) in mass  distance units
 *
 * @example
 * const com = {x: 100, y: 100}
 * const ship = {x: 100, y: 100, mass: 10, radians: 0}
 * const bodies = [
 *     {x: 90, y: 100, mass: 1},              // Engine (world space)
 *     {x: 110, y: 100, mass: 1},             // Engine (world space)
 *     {x: 50, y: 0, mass: 20, isLocal: true} // Heavy cargo (local space)
 * ]
 *
 * const I = calculateMomentOfInertia(com, ship, bodies)
 * // Result: High I because cargo is far from center
 * // This ship will be slow to rotate
 */
function calculateMomentOfInertia(centerOfMass, mainBody, bodies = []) {
    let I = 0
    const com = centerOfMass

    // 1. Add contribution from the main body
    const dx = mainBody.x - com.x
    const dy = mainBody.y - com.y
    const distanceSquared = dx * dx + dy * dy
    I += mainBody.mass * distanceSquared

    // 2. Add contributions from all bodies (engines, cargo, fuel tanks, etc.)
    const cos = Math.cos(mainBody.radians || 0)
    const sin = Math.sin(mainBody.radians || 0)

    for (let body of bodies) {
        let worldX, worldY

        // Check if this is a local-space body (needs rotation)
        if (body.isLocal) {
            // Rotate from local to world coordinates
            const rotatedX = body.x * cos - body.y * sin
            const rotatedY = body.x * sin + body.y * cos
            worldX = mainBody.x + rotatedX
            worldY = mainBody.y + rotatedY
        } else {
            // Already in world space
            worldX = body.x
            worldY = body.y
        }

        // Calculate distance from center of mass
        const dx = worldX - com.x
        const dy = worldY - com.y
        const distanceSquared = dx * dx + dy * dy
        I += body.mass * distanceSquared
    }

    return I
}

/**
 * Calculate the total mass of a rigid body system.
 *
 * This is a simple summation of all mass in the system, used for:
 * - Linear motion calculations (F = ma)
 * - Center of mass calculations
 * - Understanding the system's overall mass distribution
 *
 * @param {Object} mainBody - The main rigid body with {mass}
 * @param {Array} bodies - Array of ALL mass-bearing objects with {mass} property
 *                         Both world-space and local-space bodies can be included
 * @returns {number} The total mass of the system
 *
 * @example
 * const ship = {mass: 10}
 * const bodies = [
 *     {mass: 1},  // Engine
 *     {mass: 1},  // Engine
 *     {mass: 20}  // Cargo
 * ]
 *
 * const totalMass = calculateTotalMass(ship, bodies)
 * // Result: 32 (10 + 1 + 1 + 20)


================================================================================
END: objects/vectors/physics.js
================================================================================



================================================================================
FILE: objects/vectors/ship.js
================================================================================

/*
title: Ship
*/

// ============================================================================
// SHIP CLASS
// ============================================================================

/**
 * Ship class representing a rigid body with coupled engines.
 *
 * This extends Point to create a physics-enabled ship that:
 * - Has mass and rotational inertia
 * - Rotates around its center of mass
 * - Responds to engine forces and gravity
 * - Manages attached engines
 */
class Ship extends Point {
    constructor(config = {}) {
        super(config)

        // Physics properties
        this.vx = config.vx || 0
        this.vy = config.vy || 0
        this.radians = config.radians || -Math.PI/2  // Default: pointing up
        this.rotationSpeed = config.rotationSpeed || 0
        this.mass = config.mass || 10
        this.radius = config.radius || 5

        // Set rotation in degrees for Point compatibility
        this.rotation = this.radians * 180 / Math.PI

        // Engine management
        this.engines = []
        this.engineOffsets = []
    }

    /**
     * Add an engine to the ship using relative (local-space) position.
     *
     * The engine Point's x, y, and rotation are treated as RELATIVE to the ship:
     * - x, y: Offset from ship's center in local coordinates
     * - rotation: Rotation relative to ship's forward direction (in degrees)
     *
     * The engine will be positioned in world space and moved with the ship.
     *
     * @param {Point} enginePoint - The Point object with relative position (x, y, rotation)
     * @param {number} [mass=1] - Engine mass (default: 1)
     * @returns {Ship} Returns this for method chaining
     *
     * @example
     * const ship = new Ship({ x: 200, y: 225, radians: -Math.PI/2 })
     * const engineA = new Point({ x: 0, y: -25, rotation: 0, radius: 10 })
     *
     * ship.addEngine(engineA, 1)  // Engine at top, pointing same direction as ship
     */
    addEngine(enginePoint, mass = 1) {
        // Ensure engine has required physics properties
        enginePoint.mass = mass
        enginePoint.force = enginePoint.force || 0

        // Convert rotation from degrees to radians if needed
        const engineRadians = enginePoint.radians || (enginePoint.rotation * Math.PI / 180)

        // Store the RELATIVE position (already in local space)
        const engineOffset = {
            x: enginePoint.x,
            y: enginePoint.y,
            radians: engineRadians,
            initialRadians: engineRadians,  // Store initial rotation for reset
            rotationSpeed: 0
        }

        // Transform engine to world space initially
        const cos = Math.cos(this.radians)
        const sin = Math.sin(this.radians)
        const rotatedX = enginePoint.x * cos - enginePoint.y * sin
        const rotatedY = enginePoint.x * sin + enginePoint.y * cos

        enginePoint.x = this.x + rotatedX
        enginePoint.y = this.y + rotatedY
        enginePoint.radians = this.radians + engineRadians
        enginePoint.rotation = enginePoint.radians * 180 / Math.PI

        this.engines.push(enginePoint)
        this.engineOffsets.push(engineOffset)

        return this  // Allow chaining
    }

    /**
     * Update engine positions based on ship's current position and rotation.
     *
     * This transforms each engine from local space (relative to ship) to world space
     * by applying rotation and translation. Should be called whenever the ship moves
     * or rotates.
     */
    updateEnginePositions() {
        const cos = Math.cos(this.radians)
        const sin = Math.sin(this.radians)


================================================================================
END: objects/vectors/ship.js
================================================================================



================================================================================
FILE: offscreen-context.js
================================================================================

/*
title: Offscreen rendering.
category: offscreen
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/offscreen.js
    mouse
    dragging
    stroke
---

In this example generate an offscreen canvas and replace the stage `ctx`.
Draw routines are done on the offscreen canvas, then copied to the onscreen
canvas

    offScreenCanvas = stage.offscreen.create()
    context = offScreenCanvas.getContext("2d");
    copyToOnScreen(offScreenCanvas, stage.canvas)

 */


class MainStageOffScreenContext extends Stage {
    /* In this format we Install an "offscreen canvas" as the primary
    rendering unit.

    the `copyToOnScreen` copies the offScreen canvas into the
    visible onscreen canvas.

    The offscreen canvas is the same size as the original, therefore no
    scaling occurs.
    */
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'
    // canvas = new OffscreenCanvas(500, 400)

    mounted(){
        // this.canvas = new OffscreenCanvas(500, 400)
        // this.canvas = this.canvas.transferControlToOffscreen()

        /* Alternatively:

            this.offScreenCanvas = new OffscreenCanvas(500, 400)
         */
        this.offScreenCanvas = this.offscreen.create()
        this._ctx = this.offScreenCanvas.getContext('2d')
        // this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
        this.point = new Point(10, 10)
    }

    // resolveCanvas() {}

    // stickCanvasSize(canvas){
    //     const onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
    //     onScreenCanvas.width = 300
    //     onScreenCanvas.height = 200
    //     return
    // }

    draw(ctx){
        var context = this.offScreenCanvas.getContext("2d");

        // this.clear(ctx)

        context.fillStyle = '#444'; //set fill color
        context.fillRect(10, 10, 40, 40);

        this.point.rotation += 1
        this.point.pen.indicator(ctx)

        copyToOnScreen(this.offScreenCanvas, this.canvas)
    }

}



stage = MainStageOffScreenContext.go()//{ loop: false })


================================================================================
END: offscreen-context.js
================================================================================



================================================================================
FILE: offscreen-direct.js
================================================================================

/*
title: Offscreen Direct
category: offscreen
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/offscreen.js
    mouse
    dragging
    stroke
---

In this example we _replace the stage canvas with an OffscreenCanvas.
Then we copy the content to the on-screen canvas

    anyCanvas = #playspace
    stage.canvas = new OffscreenCanvas(500, 400)
    // ... draw routines to stage.ctx
    copyToOnScreen(stage.canvas, anyCanvas)


 */


class MainStageOffScreenDirect extends Stage {
    /* In this format we Install an "offscreen canvas" as the primary rendering unit.

    the `copyToOnScreen` copies the offScreen canvas into the visible onscreen canvas.
    */
    // canvas = document.getElementById('playspace');
    // canvas = 'playspace'
    canvas = new OffscreenCanvas(500, 400)

    mounted(){
        this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
        this.point = new Point(10, 10)
    }

    draw(ctx){
        // this.clear(ctx)

        ctx.fillStyle = '#444'; //set fill color
        ctx.fillRect(10, 10, 40, 40);

        this.point.rotation += 1
        this.point.pen.indicator(ctx)

        copyToOnScreen(this.canvas, this.onScreenCanvas)
    }

}



// stage = MainStageOffScreenContext.go()//{ loop: false })
// stage = MainStageOffScreenNoPrimary.go()//{ loop: false })
stage = MainStageOffScreenDirect.go()//{ loop: false })


================================================================================
END: offscreen-direct.js
================================================================================



================================================================================
FILE: offscreen-example-a.js
================================================================================

/*
title: Offscreen rendering.
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/offscreen.js
    mouse
    dragging
    stroke
---

Use the `copyToOnScreen` function to copy an offscreen canvas to the onscreen
canvas.

However we see when applied, offscreen canvas image is distorted due to
a dimensions mismatch
 */

class MainStageOffScreenContext extends Stage {
    /* In this format we Install an "offscreen canvas" as the primary rendering unit.

    the `copyToOnScreen` copies the offScreen canvas into the visible onscreen canvas.
    */
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'
    // canvas = new OffscreenCanvas(500, 400)

    mounted(){
        // this.canvas = new OffscreenCanvas(500, 400)
        // this.canvas = this.canvas.transferControlToOffscreen()
        this.offScreenCanvas = new OffscreenCanvas(500, 400)
        this._ctx = this.offScreenCanvas.getContext('2d')
        // this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
        this.point = new Point(10, 10)
    }

    // resolveCanvas() {}

    // stickCanvasSize(canvas){
    //     const onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
    //     onScreenCanvas.width = 300
    //     onScreenCanvas.height = 200
    //     return
    // }

    draw(ctx){
        var context = this.offScreenCanvas.getContext("2d");

        // this.clear(ctx)

        context.fillStyle = '#444'; //set fill color
        context.fillRect(10, 10, 40, 40);
        (new Point(20,20,20)).pen.indicator(context)

        this.point.rotation += 1
        this.point.pen.indicator(ctx)

        copyToOnScreen(this.offScreenCanvas, this.canvas)
    }

}


stage = MainStageOffScreenContext.go()

================================================================================
END: offscreen-example-a.js
================================================================================



================================================================================
FILE: offscreen-example-as-image.js
================================================================================

/*
title: Offscreen as image.
category: offscreen
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    pointlist
    point
    stage
    ../point_src/image.js
    ../point_src/offscreen.js
    mouse
    dragging
    stroke
---

*/

class MainStageOffScreenContext extends Stage {
    /* In this format we Install an "offscreen canvas" as the primary
    rendering unit.

    the `copyToOnScreen` copies the offScreen canvas into the visible onscreen
    canvas.
    */

    canvas = 'playspace'

    mounted(){
        // this.canvas = new OffscreenCanvas(500, 400)
        // this.canvas = this.canvas.transferControlToOffscreen()

        this.offScreenCanvas = this.offscreen.create({width:100, height:100})
        this.image = new ImageLoader;

        let oCtx = this.offScreenCanvas.getContext('2d')
        oCtx.fillStyle = '#444'; //set fill color
        oCtx.fillRect(10, 10, 40, 40);

        this.point = new Point(10,20)
        this.point.rotation += 10
        this.point.pen.indicator(oCtx)

        this.updateImage()

        this.image.position.radius = 50
        this.dragging.add(this.image.position)
        // this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
    }

    updateImage(data=this.offScreenCanvas.transferToImageBitmap()){
        // if(data == undefined){
        //     data = this.offScreenCanvas.transferToImageBitmap()
        // }
        this.image.setImageData(data)
    }

    redrawOffscreen() {
        let oCtx = this.offScreenCanvas.getContext('2d')
        oCtx.fillStyle = '#444'; //set fill color
        oCtx.fillRect(10, 10, 40, 40);

        this.point.pen.indicator(oCtx)
        this.updateImage()

    }

    draw(ctx){
        this.clear(ctx)
        // this.mouse.point.pen.indicator(ctx)
        this.point.rotation += 2
        // this.point.pen.indicator(ctx)
        this.redrawOffscreen()
        // let data = this.offScreenCanvas.transferToImageBitmap()
        // this.updateImage(data)
        this.image.position.pen.circle(ctx, {color:'#3356FF'})
        this.image.draw(ctx)
    }

}



stage = MainStageOffScreenContext.go()//{ loop: false })

================================================================================
END: offscreen-example-as-image.js
================================================================================



================================================================================
FILE: offscreen-example-b.js
================================================================================

/*
title: Offscreen rendering.
category: offscreen
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/offscreen.js
    mouse
    dragging
    stroke
---

In this example, the `Stage.canvas` reference is a new OffscreenCanvas instance.

This means all drawing occurs on the offscreen canvas, and we push it to an
_onscreen_ canvas when required:

`copyToOnScreen(offscreenCanvas, onScreenCanvas)`

Essentially it's exactly the same as standard drawing, with one-extra function call at the end.
*/


class MainStageOffScreenDirect extends Stage {
    /* In this format we Install an "offscreen canvas" as the primary rendering unit.

    the `copyToOnScreen` copies the offScreen canvas into the visible onscreen canvas.
    */
    // canvas = document.getElementById('playspace');
    // canvas = 'playspace'
    canvas = new OffscreenCanvas(500, 400)

    mounted(){
        this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
        this.point = new Point(10, 10)
    }

    draw(ctx){
        // this.clear(ctx)

        ctx.fillStyle = '#444'; //set fill color
        ctx.fillRect(10, 10, 40, 40);

        this.point.rotation += 1
        this.point.pen.indicator(ctx)

        copyToOnScreen(this.canvas, this.onScreenCanvas)
    }

}


// stage = MainStageOffScreenNoPrimary.go()//{ loop: false })
stage = MainStageOffScreenDirect.go()//{ loop: false })


================================================================================
END: offscreen-example-b.js
================================================================================



================================================================================
FILE: offscreen-example-c.js
================================================================================

/*
title: Offscreen rendering.
category: offscreen
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/offscreen.js
    mouse
    dragging
    stroke
---

In this example, there is no `Stage.canvas` applied (initially).

Instead an `OffscreenCanvas`  canvas is created on `mount()` stage, replacing the
inner `stage.ctx` with the offscreen alternative.

The `draw(ctx)` context entity is the _offscreen_ canvas layer. Once everything is complete,
we call `copyToOnScreen(offscreenCanvas, onScreenCanvas)` to push the content into
something visible.

Fundamentally the stage works in the same manner, as with a standard canvas,
The only change is the final `copyToOnScreen` call.
 */


class MainStageOffScreenNoPrimary extends Stage {
    /* In this this example, we completely ignore the _setup_ canvas,
    opting to create an offScreen canvas after the setup.

    The offscreen is rendered to the onscreen using the `copyToOnScreen`
    */
    // canvas = document.getElementById('playspace');
    // canvas = 'playspace'
    // canvas = new OffscreenCanvas(500, 400)

    mounted(){
        this.canvas = new OffscreenCanvas(500, 400)
        // this.offScreenCanvas = this.canvas.transferControlToOffscreen()
        this._ctx = this.canvas.getContext('2d')
        this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
        this.onScreenCanvas.width = 500
        this.onScreenCanvas.height = 400
        this.point = new Point(10, 10)
    }

    // resolveCanvas() {}

    // stickCanvasSize(canvas){
    //     const onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
    //     onScreenCanvas.width = 300
    //     onScreenCanvas.height = 200
    //     return
    // }

    draw(ctx){
        var context = ctx // this.offScreenCanvas.getContext("2d");

        // this.clear(ctx)

        ctx.fillStyle = '#444'; //set fill color
        ctx.fillRect(10, 10, 40, 40);

        this.point.rotation += 1
        this.point.pen.indicator(ctx)

        copyToOnScreen(this.canvas, this.onScreenCanvas)
    }

}

stage = MainStageOffScreenNoPrimary.go()//{ loop: false })
// stage = MainStageOffScreenDirect.go()//{ loop: false })


================================================================================
END: offscreen-example-c.js
================================================================================



================================================================================
FILE: offscreen-example-transferControlToOffscreen.js
================================================================================

/*
title: Offscreen transferControlToOffscreen
category: offscreen
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/offscreen.js
    mouse
    dragging
    stroke
---


In this example we call `canvas.transferControlToOffscreen()` on mount and
set the stage context to the returned offscreen canvas.
This copies the stage dimensions is similar to `stage.offscreen.create()`.
 */

class MainStageOffScreenContext extends Stage {
    /* In this format we Install an "offscreen canvas" as the primary rendering unit.

    the `copyToOnScreen` copies the offScreen canvas into the visible onscreen canvas.
    */
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'
    // canvas = new OffscreenCanvas(500, 400)

    mounted(){
        // this.canvas = new OffscreenCanvas(500, 400)
        // this.canvas = this.canvas.transferControlToOffscreen()

        // this.offScreenCanvas = this.offscreen.create()
        this.offScreenCanvas = this.canvas.transferControlToOffscreen()
        this._ctx = this.offScreenCanvas.getContext('2d')
        // this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
        this.point = new Point(40, 40)
    }

    draw(ctx){
        // this.clear(ctx)
        ctx.fillStyle = '#444'; //set fill color
        ctx.fillRect(10, 10, 40, 40);
        this.mouse.point.pen.indicator(ctx)
        this.point.rotation += 1
        this.point.pen.indicator(ctx)
    }

}



stage = MainStageOffScreenContext.go()//{ loop: false })
// stage = MainStageOffScreenNoPrimary.go()//{ loop: false })
// stage = MainStage.go()//{ loop: false })


================================================================================
END: offscreen-example-transferControlToOffscreen.js
================================================================================



================================================================================
FILE: offscreen-example.js
================================================================================

/*
title: Offscreen rendering.
category: offscreen
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/offscreen.js
    mouse
    dragging
    stroke
---

 */


class MainStageOffScreenDirect extends Stage {
    /* In this format we Install an "offscreen canvas" as the primary rendering unit.

    the `copyToOnScreen` copies the offScreen canvas into the visible onscreen canvas.
    */
    // canvas = document.getElementById('playspace');
    // canvas = 'playspace'
    canvas = new OffscreenCanvas(500, 400)

    mounted(){
        this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
        this.point = new Point(10, 10)
    }

    draw(ctx){
        // this.clear(ctx)

        ctx.fillStyle = '#444'; //set fill color
        ctx.fillRect(10, 10, 40, 40);

        this.point.rotation += 1
        this.point.pen.indicator(ctx)

        copyToOnScreen(this.canvas, this.onScreenCanvas)
    }

}


class MainStageOffScreenNoPrimary extends Stage {
    /* In this this example, we completely ignore the _setup_ canvas,
    opting to create an offScreen canvas after the setup.

    The offscreen is rendered to the onscreen using the `copyToOnScreen`
    */
    // canvas = document.getElementById('playspace');
    // canvas = 'playspace'
    // canvas = new OffscreenCanvas(500, 400)

    mounted(){
        this.canvas = new OffscreenCanvas(500, 400)
        // this.offScreenCanvas = this.canvas.transferControlToOffscreen()
        this._ctx = this.canvas.getContext('2d')
        this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
        this.point = new Point(10, 10)
    }

    // resolveCanvas() {}

    // stickCanvasSize(canvas){
    //     const onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
    //     onScreenCanvas.width = 300
    //     onScreenCanvas.height = 200
    //     return
    // }

    draw(ctx){
        var context = ctx // this.offScreenCanvas.getContext("2d");

        // this.clear(ctx)

        ctx.fillStyle = '#444'; //set fill color
        ctx.fillRect(10, 10, 40, 40);

        this.point.rotation += 1
        this.point.pen.indicator(ctx)

        copyToOnScreen(this.canvas, this.onScreenCanvas)
    }

}

class MainStageOffScreenContext extends Stage {
    /* In this format we Install an "offscreen canvas" as the primary
    rendering unit.

    the `copyToOnScreen` copies the offScreen canvas into the


================================================================================
END: offscreen-example.js
================================================================================



================================================================================
FILE: offscreen-no-primary.js
================================================================================

/*
title: Offscreen rendering.
category: offscreen
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/offscreen.js
    mouse
    dragging
    stroke
---

 */



class MainStageOffScreenNoPrimary extends Stage {
    /* In this this example, we completely ignore the _setup_ canvas,
    opting to create an offScreen canvas after the setup.

    The offscreen is rendered to the onscreen using the `copyToOnScreen`
    */
    // canvas = document.getElementById('playspace');
    // canvas = 'playspace'
    // canvas = new OffscreenCanvas(500, 400)

    mounted(){
        this.canvas = new OffscreenCanvas(500, 400)
        // this.offScreenCanvas = this.canvas.transferControlToOffscreen()
        this._ctx = this.canvas.getContext('2d')
        this.onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
        this.point = new Point(10, 10)
    }

    // resolveCanvas() {}

    // stickCanvasSize(canvas){
    //     const onScreenCanvas = document.getElementById("playspace")//.getContext("2d");
    //     onScreenCanvas.width = 300
    //     onScreenCanvas.height = 200
    //     return
    // }

    draw(ctx){
        var context = ctx // this.offScreenCanvas.getContext("2d");

        // this.clear(ctx)

        ctx.fillStyle = '#444'; //set fill color
        ctx.fillRect(10, 10, 40, 40);

        this.point.rotation += 1
        this.point.pen.indicator(ctx)

        copyToOnScreen(this.canvas, this.onScreenCanvas)
    }

}



stage = MainStageOffScreenContext.go()//{ loop: false })


================================================================================
END: offscreen-no-primary.js
================================================================================



================================================================================
FILE: offscreen-to-image-bitmap.js
================================================================================

/*
title: Offscreen to Image Bitmap
category: offscreen
    bitmap
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/offscreen.js
    ../point_src/image.js
    mouse
    dragging
    stroke
---

convert the offscreen canvas through `transferToImageBitmap`
and perform `drawImage(bitmap, ...)`
*/

class MainStageOffScreenNoPrimary extends Stage {
    /* */
    canvas = document.getElementById('playspace');

    mounted(){
        this.offscreenCanvas = new OffscreenCanvas(100, 100)
        this.point = new Point(50, 50, 10)
        this.image = new ImageLoader()

    }

    draw(ctx){
        var octx = this.offscreenCanvas.getContext("2d");

        // this.clear(ctx)
        // ImageBitmap { width: 256, height: 256 }
        // this.image.imageData = bitmap
        // this.image.position.xy = [20, 20]
        // ctx.drawImage(this.image.imageData, 1, 1)
        // ctx.fillStyle = '#444'; //set fill color

        /* Draw onto the offscreen canvas. */
        octx.fillRect(0, 0, 100, 100);
        this.point.rotation += 1
        this.point.pen.indicator(octx)

        // Create bitmap from offscreen canvas
        let bitmap = this.offscreenCanvas.transferToImageBitmap()

        // Draw bitmap onto the main canvas with scaling
        /* Draw Image (bitmap),
        gathering a 2d top left, bottom right slice from the bitmap
        then drawing the 2d 2 points on the context.

        The dimensions of the _write_ should match the expected shape.
        This allows scaling when applying the image.
        */
        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 10, 10, 110, 110);

    }

}

stage = MainStageOffScreenNoPrimary.go()//{ loop: false })
// stage = MainStageOffScreenDirect.go()//{ loop: false })


================================================================================
END: offscreen-to-image-bitmap.js
================================================================================



================================================================================
FILE: onclick-example.js
================================================================================

/*
title: Onclick Example
files:
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/compass.js
    ../point_src/point.js
    stage
    mouse
---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()
    }

    onClick(ev) {
        this.point.copy(Point.from(ev))
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.fill(ctx, '#880000')
    }
}

stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: onclick-example.js
================================================================================



================================================================================
FILE: origin-shift-wide.js
================================================================================

/*
title: Origin Shift Wide
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    stroke
    pointlist
    ../point_src/point.js
    ../point_src/keyboard.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/origin-shift/origin-shift.js
    ../point_src/origin-shift/origin-shift-configs.js
    ../point_src/origin-shift/origin-shift-drawpath.js
    ../point_src/grid-get-siblings.js
    ../point_src/origin-shift/origin-walker.js
    ../point_src/origin-shift/origin-shift-main-wide.js
*/


================================================================================
END: origin-shift-wide.js
================================================================================



================================================================================
FILE: origin-shift.js
================================================================================

/*
title: Origin Shift
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/origin-shift/origin-shift-main.js


*/


================================================================================
END: origin-shift.js
================================================================================



================================================================================
FILE: originRotate-example.js
================================================================================

/*
title: Tethered Controller Point
categories: binding
files:
    head
    point
    pointlist
    mouse
    stage
    dragging
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/tethers.js
    ../point_src/stage-clock.js
    stroke
---

*/
addButton('Add Point',{
    onclick(){
        stage.addNewPoint()
    }
})


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        // this.createPoints()
        // this.dragging.add(...this.points, ...this.controlPoints)
        this.point = new Point(200, 200, 100)
        this.lastDiff = this.point.radians
        this.point.rotationSet = (v) => {
            let p = this.points[0]
            let diff = radiansDiff2(this.point.radians, this.lastDiff)
            p.xy = originRotate(p, this.point, radiansToDegrees(diff))
            this.lastDiff = this.point.radians
        }
        this.points = new PointList
        this.dragging.add(this.point)
        this.addNewPoint()
        this.addNewPoint()
    }

    addNewPoint() {
        let pos = random.within(this.point, 1)
        let cp = new Point(pos)
        this.points.push(cp)
        this.dragging.add(cp)
    }

    draw(ctx){
        this.clear(ctx)
        let p = this.point
        p.pen.indicator(ctx, {color: '#336600'})
        this.points.pen.indicator(ctx, {color: '#336600'})
    }
}



;stage = MainStage.go();

================================================================================
END: originRotate-example.js
================================================================================



================================================================================
FILE: originRotate-pointlist.js
================================================================================

/*
title: Tethered Controller Point
categories: binding
files:
    head
    point
    pointlist
    mouse
    stage
    dragging
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/tethers.js
    ../point_src/stage-clock.js
    stroke
---

*/
addButton('Add Point',{
    onclick(){
        stage.addNewPoint()
    }
})


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = new PointList
        this.point = new Point(200, 200, 100)

        // this.point.rotationSet = (v) => {
        //     this.points.handleRotate(this.point)
        // }

        this.dragging.add(this.point)
        this.addNewPoint()
        this.addNewPoint()
    }

    addNewPoint() {
        let pos = random.within(this.point, 1)
        let cp = new Point(pos)
        this.points.push(cp)
        this.dragging.add(cp)
        return cp
    }

    draw(ctx){
        this.clear(ctx)

        this.points.handleRotate(this.point)

        this.point.pen.indicator(ctx, {color: '#336600'})
        this.points.pen.indicator(ctx, {color: '#336600'})
    }
}



;stage = MainStage.go();

================================================================================
END: originRotate-pointlist.js
================================================================================



================================================================================
FILE: overlap-example.js
================================================================================

/*
title: Overlap Example
categories: overlap
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/random.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/functions/clamp.js
    ../point_src/velocity.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js


*/
class Reactor {

    velocityReductionFactor = .99
    constructor(points=[]){
        this.points = points
    }

    step(speed=1) {

        for(let point of this.points) {
            this.addMotion(point, speed)
        }
    }

    addMotion(point, speed=1) {
        /* Because we're in a zero-gravity space, the velocity is simply _added_
        to the current XY, pushing the point in the direction of forced. */
        point.x += point.vx *= this.velocityReductionFactor
        point.y += point.vy *= this.velocityReductionFactor
    }

}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.center.radius = 50

        let radius = 7
        let rowCount = 5 /* How many items per row within the grid */
        let count = 50
        const pointList = PointList.generate.random(count, 500, {x: 50, y:50})

        this.point = new Point({x:200, y:200, radius: 30})

        this.dragging.add(this.point)
        pointList.forEach((p)=> p.radius = 10 + random.int(20))
        this.points = pointList

        this.dis = new Distances
        this.dis.addPoints(...pointList)

        this.reactor = new Reactor([this.point])
    }

    draw(ctx){
        this.clear(ctx)

        this.reactor.step()

        let mousePoint = Point.mouse.position
        let p = this.point
        this.points.lookAt(p)
        /* Draw each point; wrapping the _draw_ call_ with our own functionality.*/
        this.points.pen.indicators(ctx, { color: 'gray', width: 1})


        p.pen.indicator(ctx, { color: '#3399DD', width: 2})

        // let v = this.dis.closest(mousePoint)
        let v = this.dis.near(p, this.point.radius)
        for(const p of v){
            p.pen.indicator(ctx, { color: 'green', width: 3})
        }
        // console.log(v.length)
    }
}

stage = MainStage.go()


================================================================================
END: overlap-example.js
================================================================================



================================================================================
FILE: pairs-and-siblings.js
================================================================================

/*
title: Pairs And Siblings
files:
    head
    stage
    pointlist
    point
    mouse
    dragging
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
    ../point_src/protractor.js
    ../point_src/relative.js
    ../point_src/automouse.js
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.pointA = this.center.copy().update({ radius: 100})
        this.pointB = this.center.copy().update({radius: 100})
        this.pointA.x -= 150
        this.pointB.x += 150

        this.pointsA = this.pointA.split(20).pairs(0)
        this.pointsB = this.pointB.split(10).siblings(0)
        // this.points = this.point.split(4).pairs()

        this.dragging.add(this.pointA, this.pointB, this.pointsA, this.pointsB)
        this.pointsA.forEach( pl => this.dragging.add(...pl))
        this.pointsB.forEach( pl => this.dragging.add(...pl))
    }

    draw(ctx){
        this.clear(ctx)
        this.pointA.pen.indicator(ctx)
        this.pointB.pen.indicator(ctx)

        this.pointsA.forEach(pl=>{
            pl.pen.indicators(ctx)
            pl.pen.line(ctx)
        });

        this.pointsB.forEach(pl=>{
            pl.pen.indicators(ctx)
            pl.pen.line(ctx)
        })
        // this.points.pen.indicators(ctx)

    }
}



stage = MainStage.go()


================================================================================
END: pairs-and-siblings.js
================================================================================



================================================================================
FILE: pattern-example.js
================================================================================

/*
title: Using createPattern()
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    mouse
    dragging
    stroke
---

Presenting the raw feature `ctx.createPattern()`, we can generate a "pattern"
using an `OffscreenCanvas` and apply it as a fill.

*/


class MainStage extends Stage {
    canvas = 'playspace'
    mounted(){
        this.offScreen = new OffscreenCanvas(50, 50)
        let oCtx = this.offScreen.getContext('2d')
        oCtx.fillStyle = '#010101'; //set fill color
        oCtx.fillRect(10, 10, 40, 40);
        Point.from(30,30, 10, 77).pen.indicator(oCtx, { width: 2})

        this.pattern = this.ctx.createPattern(this.offScreen, 'repeat')
        this.point = new Point(10, 10)
    }

    draw(ctx){
        this.clear(ctx)
        ctx.fillStyle = this.pattern;
        ctx.fillRect(0, 0, 300, 300);

        this.point.rotation += 1
        this.point.pen.indicator(ctx)
    }

}


stage = MainStage.go()//{ loop: false })

================================================================================
END: pattern-example.js
================================================================================



================================================================================
FILE: pendulum-point-example.js
================================================================================

/*
title: Pendulum Point Example
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/extras.js
    ../point_src/setunset.js
    ../point_src/stroke.js


 */
const canvas = document.getElementById('playspace');
const ctx = canvas.getContext('2d');
Point.mouse.listen(canvas)


const pendulum_main = function(){

    let rect = canvas.getBoundingClientRect()
    ctx.canvas.width  = rect.width;
    ctx.canvas.height = rect.height;

    let line = setupPendulum()
    start(line)
    solve()

    draw()
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    update()
    requestAnimationFrame(draw);
}


var _solve = false;
var UC = 0
let solve = ()=> _solve = true;
const update = function() {
    UC++;
    if(randomLine) drawMyLine()
    // if(UC % 3 != 0){ return;}
    if (_solve) solveLine(randomLine)
    // if(randomLine) drawMyLine('white')
}

var DIV = 10000

var leftOffset;

var randomLine;
var length = 100;
// var DIV = 10000
// var gravity = 0.6 / DIV;
// var friction = 0.009 / DIV;
var DIV = 20
var gravity = .6 / DIV;
var friction = .009 / DIV;
var members = 4; // Model.members;

const setupPendulum = function (){
    leftOffset = canvas.width * .5;

    randomLine = PointList.generate.list(members, length)
    randomLine.setY(200)

    randomLine.setX((e,i,a)=>{
        e.x = leftOffset + (i*length)
    })

    randomLine.forEach((p)=>{
        p.vTheta = 0
        p.theta = -45 * Math.PI / 180;
    })

    // randomLine[0].isDrag = true
    // randomLine[1].x -= 50;
    // randomLine[1].y -= 50;

    // randomLine[3].x -= 50;
    // randomLine[3].y -= 50;
    return randomLine;
}



function start(pointList) {

    var i = 0;
    var n = 0;
    //


================================================================================
END: pendulum-point-example.js
================================================================================



================================================================================
FILE: phat-leg-example.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    pointlist
    stage
    stroke
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        // this.point = new Point(30, 40, 100)
        this.points = PointList.generate.list(100, point(5,5), [200, 100])
        this.tick = 0

        /* stage.phase = Math.PI2  == 0 */
        /* stage.phase = Math.PI / (stage.points.length * .5 )
        */
        this.phase = Math.PI /10
        this.speed = .01
        this.size = 50
        this.centerShift = 60

        // this.phase = Math.PI /109
        // this.speed = .01
    }

    draw(ctx){
        this.clear(ctx)
        this.tick += 1
        // this.point.pen.line(ctx, undefined, 'red')
        this.points.each.radius = (p, i)=> (Math.cos((i * this.phase)+ (this.tick * this.speed) ) * this.size) + this.centerShift

        this.points.forEach((p)=>{
            p.pen.line(ctx, undefined, 'red')
        })
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: phat-leg-example.js
================================================================================



================================================================================
FILE: pin-rope-example.js
================================================================================

/*
title: Pinnable Rope
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
---

A very pinnable verlet constraint chain for a rope-like catenary solution.

*/

// const distance = 5;
const gravity2D = {x:0, y:1};
const gravity = 0.35;
const friction = 0.9;

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })

    }

    /*  GPT 4.5 absolutely knocked it out the park.*/
    mounted() {
        this.numPoints = 24;
        this.segmentLength = 40;
        this.gravity = .31;
        this.gravity2D = gravity2D
        this.points = Array.from({ length: this.numPoints }, () => ({
            x: this.mouse.point.x,
            y: this.mouse.point.y,
            oldX: this.mouse.point.x,
            oldY: this.mouse.point.y,
        }));
        this.points[9].invMass = .01
        this.points = new PointList(...this.points).cast()
        this.endPin = new Point(100, 200)
        this.midPin =  new Point(250, 200)
        this.midPin.color = 'red'
        this.dragging.add(this.midPin, this.endPin)

    }

    applyPhysics(points, gravity) {
        points.forEach((p, index) => {
            if (index === 0) {
                // first point follows mouse
                p.x = this.mouse.point.x;
                p.y = this.mouse.point.y;
            } else {
                const vx = (p.x - p.oldX) * 0.98;
                const vy = (p.y - p.oldY) * 0.98;

                p.oldX = p.x;
                p.oldY = p.y;

                p.x += vx;
                p.y += vy + gravity;
            }
        });
    }

    applyPhysics2(points, gravity2D, pinnedIndices){
        points.forEach((p, index) => {
            if (!pinnedIndices.includes(index) && (p.invMass ?? 1) !== 0) {
                p.x += gravity2D.x * (p.invMass ?? 1) * this.gravity;
                p.y += gravity2D.y * (p.invMass ?? 1) * this.gravity;
            }
        });
    }

    solveConstraints1(points, segmentLength, iterations = 5) {
        for (let j = 0; j < iterations; j++) {
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];

                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const difference = segmentLength - distance;
                const percent = difference / distance / 2;

                const offsetX = dx * percent;
                const offsetY = dy * percent;



================================================================================
END: pin-rope-example.js
================================================================================



================================================================================
FILE: pin-rope-small-raw.js
================================================================================

/*
title: Pinnable Rope
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
---

A very pinnable verlet constraint chain for a rope-like catenary solution.

*/

// const distance = 5;
const gravity2D = {x:0, y:1};
const gravity = 0.35;
const friction = 0.9;



class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })

    }

    /*  GPT 4.5 absolutely knocked it out the park.*/
    mounted() {
        this.numPoints = 10;
        this.segmentLength = 20;
        this.gravity = .31;
        this.gravity2D = gravity2D
        this.points = Array.from({ length: this.numPoints }, () => ({
            x: this.mouse.point.x,
            y: this.mouse.point.y,
            oldX: this.mouse.point.x,
            oldY: this.mouse.point.y,
        }));
        // this.points[9].invMass = .01
        this.points = new PointList(...this.points).cast()
        this.endPin = new Point(100, 200)
        this.midPin =  new Point(250, 200)
        this.points.last().invMass = 2
        this.midPin.color = 'red'
        this.dragging.add(this.midPin, this.endPin)

    }

    applyPhysics(points, gravity) {
        points.forEach((p, index) => {
            if (index === 0) {
                // first point follows mouse
                p.x = this.mouse.point.x;
                p.y = this.mouse.point.y;
            } else {
                const vx = (p.x - p.oldX) * 0.98;
                const vy = (p.y - p.oldY) * 0.98;

                p.oldX = p.x;
                p.oldY = p.y;

                p.x += vx;
                p.y += vy + gravity;
            }
        });
    }

    applyPhysics2(points, gravity2D, pinnedIndices){
        points.forEach((p, index) => {
            if (!pinnedIndices.includes(index) && (p.invMass ?? 1) !== 0) {
                p.x += gravity2D.x * (p.invMass ?? 1) * this.gravity;
                p.y += gravity2D.y * (p.invMass ?? 1) * this.gravity;
            }
        });
    }

    solveConstraints1(points, segmentLength, iterations = 5) {
        for (let j = 0; j < iterations; j++) {
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];

                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const difference = segmentLength - distance;
                const percent = difference / distance / 2;



================================================================================
END: pin-rope-small-raw.js
================================================================================



================================================================================
FILE: pin-rope-small.js
================================================================================

/*
title: Pinnable Rope
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
    ../point_src/rope.js
---

A very pinnable verlet constraint chain for a rope-like catenary solution.

*/

// const distance = 5;
const gravity2D = {x:0, y:-8.9};
const gravity = 0.35;
const friction = 0.9;



class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })
    }

    /*  GPT 4.5 absolutely knocked it out the park.*/
    mounted() {
        this.numPoints = 10;
        this.segmentLength = 20;
        this.gravity = .31;
        this.gravity2D = gravity2D

        let initPos = this.center.copy()
        this.points = Array.from({ length: this.numPoints }, () => ({
            x: initPos.x,
            y: initPos.y,
            oldX: initPos.x,
            oldY: initPos.y,
        }));

        // this.points[9].invMass = .01
        this.points = new PointList(...this.points).cast()
        this.points.last().invMass = .2
        this.dragging.add(this.points[0])

        this.ropeReactor = new RopeReactor()
        this.ropeReactor.mouse = this.mouse
        this.points[0].copy(initPos.subtract(120,120))
        this.ropeReactor.pin(0)
    }

    draw(ctx) {
        this.clear(ctx);

        /* A viscous fluid, applied through 2d invMass*/
        // this.applyPhysics2(this.points, this.gravity2D, [1, this.points.length-1]);
        let ropeReactor = this.ropeReactor
        /* Rope like mass physics.*/
        ropeReactor.applyPhysics(this.points, this.gravity);
        // ropeReactor.applyPhysics2(this.points, this.gravity2D)

        /* Different solving methods */
        // this.solveConstraints1(this.points, this.segmentLength);
        // this.solveConstraints2(this.points, this.segmentLength);
        ropeReactor.solveConstraints3(this.points, this.segmentLength);
        ctx.fillStyle = '#999'
        ctx.font = 'normal 30px lexend deca'
        ctx.textAlign = 'center'
        // this.points.pen.indicator(ctx);
        this.points.pen.quadCurve(ctx);
        let penUlt = this.points[this.points.length - 5]
        let last = this.points.last()
        this.points[0].pen.indicator(ctx)
        last.lookAt(penUlt, Math.PI *.5)
        // last.pen.indicator(ctx)
        penUlt.pen.indicator(ctx)
        last.text.label(ctx, 'Polypoint')
    }

}


;stage = MainStage.go();

================================================================================
END: pin-rope-small.js
================================================================================



================================================================================
FILE: pin-rope-stiff.js
================================================================================

/*
title: Pinnable Rope
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
---

A very pinnable verlet constraint chain for a rope-like catenary solution.

*/

// const distance = 5;
const friction = 0.9;

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })

    }

    /*  GPT 4.5 absolutely knocked it out the park.*/
    mounted() {
        this.numPoints = 20;
        this.segmentLength = 10;
        this.gravity = -.001;

        this.points = Array.from({ length: this.numPoints }, () => ({
            x: this.mouse.point.x,
            y: this.mouse.point.y,
            oldX: this.mouse.point.x,
            oldY: this.mouse.point.y,
        }));
        this.points = new PointList(...this.points).cast()
        this.endPin = new Point(100, 200)
        this.dragging.add(this.endPin)

    }

    applyPhysics(points, gravity) {
        points.forEach((p, index) => {
            if (index === 0) {
                // first point follows mouse
                p.x = this.mouse.point.x;
                p.y = this.mouse.point.y;
            } else {
                const vx = (p.x - p.oldX) * 0.98;
                const vy = (p.y - p.oldY) * 0.98;

                p.oldX = p.x;
                p.oldY = p.y;

                p.x += vx;
                p.y += vy + gravity;
            }
        });
    }

    solveConstraints1(points, segmentLength, iterations = 5) {
        for (let j = 0; j < iterations; j++) {
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];

                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const difference = segmentLength - distance;
                const percent = difference / distance / 2;

                const offsetX = dx * percent;
                const offsetY = dy * percent;

                if (i !== 0) {
                    p1.x -= offsetX;
                    p1.y -= offsetY;
                }
                p2.x += offsetX;
                p2.y += offsetY;
            }
        }
    }

    draw(ctx) {
        this.clear(ctx);
        this.applyPhysics(this.points, this.gravity);
        // this.solveConstraints1(this.points, this.segmentLength);


================================================================================
END: pin-rope-stiff.js
================================================================================



================================================================================
FILE: pixel-fix.js
================================================================================

/*
title: Pixel Fix
*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        this.events.wake()
    }

    onClick(ev) {
        this.point.copy(Point.from(ev))
        console.log(this.point.x, this.point.y)
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.fill(ctx, '#880000')
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: pixel-fix.js
================================================================================



================================================================================
FILE: planets.js
================================================================================

/*
title: Planets
files:
    ../point_src/core/head.js
    ../point_src/pointlistpen.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/bisector.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/rotate.js
    ../point_src/stage.js
    ../point_src/gradient.js
    ../point_src/json.js
    ../point_src/text/alpha.js
    ../point_src/text/label.js
 */

const arcLine = function(ctx, points) {
    ctx.beginPath();
    // midPoint.pen.indicator(ctx)

    let startPoint = points[0]

    ctx.moveTo(startPoint.x, startPoint.y);

    let previousPoint = startPoint;
    let pl = points.length;

    // debugger;
    for (var i = 0; i < pl; i++) {
        let p = points[i]
        // if(previousPoint) {
            // if(i == pl-1) {
                // end point
                // ctx.lineTo(p.x, p.y);
            // } else {
                let toPoint = p;
                let r = previousPoint.radius
                ctx.arcTo(previousPoint.x, previousPoint.y, toPoint.x, toPoint.y, r);
            // }
        // }
        previousPoint = p
        // this.drawArc(ctx, midPoint, pointC, pointD)
    }
    let last = points[pl-1]
    ctx.lineTo(last.x, last.y);

    // ctx.stroke();
}

/*
Mercury #1a1a1a Yes it is really that dark

Venus #e6e6e6 or perhaps a bit darker

Earth tricky as it is a mix of colors, and changes over the yea
r seems to average out as about #2f6a69

Mars #993d00

Jupiter #b07f35

Saturn #b08f36

Uranus #5580aa

Neptune #366896
const planetColors = [
    { planet: "Mercury", color: "#918E85" },
    { planet: "Venus", color: "#EEDDAA" },
    { planet: "Earth", color: "#7EC8E3" },
    { planet: "Mars", color: "#D14A28" },
    { planet: "Jupiter", color: "#C6906E" },
    { planet: "Saturn", color: "#D9C48B" },
    { planet: "Uranus", color: "#7FD1B9" },
    { planet: "Neptune", color: "#2C4D97" },
    { planet: "Pluto", color: "#B2A393" }
];
 */

const settings = {
    zoom: .0006
    // Pixel distance per planet
    // if sun AU is not a factor
    // , distanceMultiplier: 150

    // if au is a factor
    , distanceMultiplier: .16

}



================================================================================
END: planets.js
================================================================================



================================================================================
FILE: plotter-cos-sin.js
================================================================================

/*

title: Plotter
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
    stroke
---

Plotting captures the XY RAD ROT of a point upon request, and stashes it in a
pointlist. This is useful for timestep captures such as spline walks.

*/

class TimedPlotter {

    maxDistance = 50
    projectionSpread = .3
    minSpeed = 20
    drawingLine = false

    constructor(){
        this.points = new PointList;
    }

    start(point) {
        let delta = Infinity
        if(this.mouseUpTime) {
            delta = +(new Date) - this.mouseUpTime
        }

        if(delta < 100) {
            /* mouse click buffer */
            console.warn('fast click')
        }

        // console.log('start draw', delta)
        clearInterval(this.walkTicker)

        this.walkTicker = undefined

        this.drawingLine = true
        this.startLine(point)
    }

    stop(point) {
        // console.log('stop draw')
        this.drawingLine = false
        this.stopLine(point)
        this.mouseUpTime = +(new Date)
    }

    startLine(point) {
        /* Start a line at a position*/
        this.line = new PointList(point)
        this.step(point)
        this.walkTicker = setInterval(this.tickFunc.bind(this), 50)
    }

    stopLine(point) {
        this.line.push(point)
        clearInterval(this.walkTicker)
        this.walkTicker = undefined
    }

    tickFunc(mp=undefined) {
        /* Tick event,
        if the distance is greater than the existing, add point.*/
        mp = mp || this.mouse.point
        let l = this.points
        let last = l.last()
        let perform = true;

        if(last) {
            last.lookAt(mp)
            if(mp.distanceTo(last) < this.maxDistance) {
                perform = false;
            }
        }

        if(perform){
            l.push(mp.copy())
        }
    }

    step(mp) {
        if(this.drawingLine) {
            this.tickFunc(mp)
        }
    }

}

var slideSpeed = 1
    , spinSpeed = .5
    , maxPlotCount = 40


================================================================================
END: plotter-cos-sin.js
================================================================================



================================================================================
FILE: plotter-raw.js
================================================================================

/*

title: Plotter
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
    stroke
---

Plotting captures the XY RAD ROT of a point upon request, and stashes it in a
pointlist. This is useful for timestep captures such as spline walks.

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        // this.dragging.add(...this.points)
        // this.events.wake()
        this.points = new PointList;
    }

    maxDistance = 50
    projectionSpread = .3
    minSpeed = 20

    onMousedown(ev) {
        let delta = Infinity
        if(this.mouseUpTime) {
            delta = +(new Date) - this.mouseUpTime
        }

        if(delta < 100) {
            /* mouse click buffer */
            console.warn('fast click')
        }

        // console.log('start draw', delta)
        clearInterval(this.walkTicker)

        this.walkTicker = undefined

        this.drawingLine = true
        this.startLine(Point.from(ev))
    }

    onMouseup(ev) {
        // console.log('stop draw')
        this.drawingLine = false
        this.stopLine(Point.from(ev))
        this.mouseUpTime = +(new Date)
    }

    onMousemove(ev) {
        if(this.drawingLine) {
            this.tickFunc()
        }
    }

    startLine(point) {
        /* Start a line at a position*/
        this.line = new PointList(point)
        this.walkTicker = setInterval(this.tickFunc.bind(this), 50)
    }

    stopLine(point) {
        this.line.push(point)
        clearInterval(this.walkTicker)
        this.walkTicker = undefined
    }

    tickFunc() {
        /* Tick event,
        if the distance is greater than the existing, add point.*/
        let mp = this.mouse.point
        let l = this.points
        let last = l.last()
        let perform = true;

        if(last) {
            last.lookAt(mp)
            if(mp.distanceTo(last) < this.maxDistance) {
                perform = false;
            }
        }

        if(perform){
            l.push(mp.copy())
        }
    }

    draw(ctx){
        this.clear(ctx)


================================================================================
END: plotter-raw.js
================================================================================



================================================================================
FILE: point-example-raw.js
================================================================================

/*
title: Point Example Raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/automouse.js

---

This example doesn't use a `Stage`, in favour of a more _raw_ drawing method.
 */
const canvas = document.getElementById('playspace');
const ctx = canvas.getContext('2d');
Point.mouse.listen(canvas)


class Line {
    constructor(p1, p2, length=100, color='red', width=1){
        // new Line([90, 130], [200, 300], 420)
        this.a = point(p1)
        this.b = point(p2)
        this.length = length
        this.color = color
        this.width = width
    }
}


const drawPoints = function(pointsArray, position) {
    addMotion(pointsArray)
    drawPointLine(pointsArray, position)
}

const drawLine = function(line) {
    // Ensure the path restarts, ensuring the colors don't _bleed_ (from
    // last to first).
    ctx.beginPath();
    ctx.moveTo(line.a.x, line.a.y)
    ctx.lineTo(line.b.x, line.b.y)
}


const drawPointLine = function(pointsArray, position) {
    // To 'close' the old drawing.
    ctx.beginPath();

    let {x, y} = position
    for(let i=0; i < pointsArray.length-1; i++) {
        let segment = pointsArray[i]
        ctx.lineTo(segment.x + x, segment.y + y);
    }

    ctx.strokeStyle = 'white'
    ctx.stroke()
}


const toy = new Point(100, 100)
const b = point(100,100);

const polygonPoint = point(100, 100)
polygonPoint.radius = 30

const line = new Line(point(10, 10), toy)

const pl = PointList.generate.list(10, 20)
pl.setX(140)

const plRandom = PointList.generate.random(20, 500)
// wiggler.points = Point.pointArray(wiggler.segments, wiggler.length)


const UNSET = {}

const quickStroke = function(color='green', lineWidth=UNSET) {
    ctx.strokeStyle = color
    if(lineWidth != UNSET) {
        ctx.lineWidth = lineWidth
    }
    ctx.stroke()
}


var toyDistance = 60
var toyRotation = UP_DEG

const update = function() {

    ctx.beginPath()

    toy.project(toyDistance, toyRotation).draw.arc(ctx, 3);
    quickStroke('white', 1)



================================================================================
END: point-example-raw.js
================================================================================



================================================================================
FILE: point-line.js
================================================================================

/*
title: Point Line
*/

class Line {
    constructor(p1, p2, color='red', width=1){
        // new Line([90, 130], [200, 300], 420)
        this.a = point(p1)
        this.b = point(p2)
        this.color = color
        this.width = width
    }

    draw(ctx) {
        ctx.beginPath();

        let a = this.a;
        let b = this.b;
        ctx.moveTo(a[0], a[1])
        ctx.strokeStyle = this.color
        ctx.lineWidth = this.width == undefined? 1: this.width
        ctx.lineTo(b[0], b[1])

        ctx.stroke()
    }
}



const randomPoints = PointList.generate.random(4, 200)


const UNSET = {}


const quickStroke = function(ctx, color='green', lineWidth=UNSET) {
    ctx.strokeStyle = color
    if(lineWidth != UNSET) {
        ctx.lineWidth = lineWidth
    }
    ctx.stroke()
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        let cumX = 0
            , cumOffset = 120
            , globalY = 100
            , offset = ()=> cumX+=cumOffset
            , c = this.compass
            ;

        this.points = new PointList(
            new Point({
                name: "up"
                , rotation: c.up // UP_DEG
                , x: offset(), y: globalY
            })
            , new Point({
                name: "right"
                , rotation: c.right // RIGHT_DEG
                , x: offset(), y: globalY
            })
            , new Point({
                name: "down"
                , rotation: c.down // DOWN_DEG
                , x: offset(), y: globalY
            })
            , new Point({
                name: "left"
                , rotation: c.left // LEFT_DEG
                , x: offset(), y: globalY
            })
            , new Point({
                name: "spinner"
                , x: offset(), y: globalY
            })
        )

        this.points.setMany(20, 'radius');

        this.line = new Line([100, 200], [200, 200], 'green', 2)

    }


    draw(ctx){
        this.clear(ctx)

        this.line.draw(ctx)
        this.drawPoints(ctx)
        this.drawRandomLine(ctx)
    }

    drawPoints(ctx) {
        this.points.last().rotation += 2


================================================================================
END: point-line.js
================================================================================



================================================================================
FILE: point-mousedown-click.js
================================================================================

/*
title: Point Click
category: mouse
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/text/beta.js

---

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        let p = this.point = new Point(100, 100, 20)

        p.onMousedown = (e)=>{
            p.color = random.color(360, [30, 100], [60,100])
        }

        this.dragging.add(p)
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.fill(ctx, this.point.color ?? '#88000')
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: point-mousedown-click.js
================================================================================



================================================================================
FILE: point-pump-emitter.js
================================================================================

/*
title: Point Pump Emitter
categories: emitter
files:
    head
    ../point_src/math.js
    ../point_src/point-content.js
    pointlist
    point
    mouse
    ../point_src/random.js
    dragging
    stage
    stroke
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        let e2 = new Emitter(400,400, 60)
        e2.direction = {x:-1, y:0} //inward.
        e2.fromEdge = true
        e2.tickModulo = 10
        e2.wake()
        this.e2 = e2

        this.dragging.add(e2)
    }

    draw(ctx){
        this.clear(ctx)
        let es = this.e2
        ctx.fillStyle = '#880000'

        es.step()
        // es.rotation += 1
        // es.lookAt(this.mouse.point)
        es.pen.indicator(ctx)
        es.points.pen.fill(ctx)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: point-pump-emitter.js
================================================================================



================================================================================
FILE: pointer-lock.js
================================================================================

/*
title: Pointer Lock
*/

/*
https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API
 */

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        this.events.wake()
    }

    async onMousedown(ev) {
        /* assign lock.*/
        if(document.pointerLockElement) {
            return
        }

        try {
            await this.canvas.requestPointerLock({
                    unadjustedMovement: true,
            });
        } catch (error) {
            if (error.name === "NotSupportedError") {
                // Some platforms may not support unadjusted movement.
                await this.canvas.requestPointerLock();
            } else {
                throw error;
            }
        }

    }

    async onMousemove(ev) {
        if(!document.pointerLockElement){
            return
        }
            this.point.copy(this.point.add({x:ev.movementX, y:ev.movementY}))
    }

    async onMouseup(ev) {
        if(!document.pointerLockElement){
            return
        }

        // unlock
        document.exitPointerLock();
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.fill(ctx, '#880000')
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: pointer-lock.js
================================================================================



================================================================================
FILE: polygon-bunkbed.js
================================================================================

/*
title: Polgon hit-test
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/curve-extras.js
    ../point_src/random.js
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/rotate.js
    ../point_src/functions/within.js
    ../point_src/automouse.js

---

Click to draw connected lines (filling a `PointList`)
Then check the mouse is within the drawn _polygon_ using the `withinPolygon` function
 */

addButton('Toggle Line', {
    onclick() {
        stage.drawLine = !stage.drawLine
    }
})


addButton('Toggle Fill', {
    onclick() {
        stage.fillPolygon = !stage.fillPolygon
    }
})


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.drawn = []
        // this.events.wake()

        this.stroke = new Stroke({
            color: '#b32bb6'
            , width: 2
            , dash: [7, 4]
        })

        this.fillPolygon = true
        this.drawLine = false
        this.line = new PointList
        this.dragging.wake()

        this.projectionPoint = this.center.copy()
        this.projectionLength = 500
        this.perspectiveCenter = this.center.copy()
        this.perspectiveCenter.y += 200

        let PI = Math.PI;
        this.spin = {
            x: 90
            , y:  0
            , z: -0
        }
    }

    onEmptyDown(ev) {
    // onClick(ev, point) {
        // if(point == undefined) {
        console.log('Down')
        let np = Point.from(ev)
        this.line.push(np)
        this.dragging.add(np)
        // }
    }

    draw(ctx){
        this.clear(ctx)

        this.stroke.set(ctx)

        let l = this.line;
        if(l) {
            let f = l.first()
            f && f.pen.circle(ctx)
            l.draw.line(ctx)
        }



================================================================================
END: polygon-bunkbed.js
================================================================================



================================================================================
FILE: potter-dual-lines.js
================================================================================

/*

title: Plotter
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
    ../point_src/smooth-number.js
    ../point_src/split.js
    stroke
---

Plotting captures the XY RAD ROT of a point upon request, and stashes it in a
pointlist. This is useful for timestep captures such as spline walks.

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'
    tickerInterval = 50

    mounted(){
        // this.dragging.add(...this.points)
        // this.events.wake()
        this.points = new PointList;
        this.points2 = new PointList;
        this.lastPoint = undefined;
        this.speedNumber = new SmoothNumber(10, 10, 20)
    }

    maxDistance = 30
    projectionSpread = 3
    minSpeed = 2

    onMousedown(ev) {
        let delta = Infinity
        if(this.mouseUpTime) {
            delta = +(new Date) - this.mouseUpTime
        }

        if(delta < 100) {
            /* mouse click buffer */
            console.warn('fast click')
        }

        console.log('start draw', delta)
        clearInterval(this.walkTicker)

        this.walkTicker = undefined
        this.lastMouseSpeed = 20
        this.moveCount = 1
        this.drawingLine = true
        this.startLine(Point.from(ev))
    }

    onMouseup(ev) {
        // console.log('stop draw')
        this.drawingLine = false
        this.stopLine(Point.from(ev))
        this.mouseUpTime = +(new Date)
        this.lastPoint = undefined
    }

    onMousemove(ev) {

        if(this.drawingLine) {
            this.tickFunc()
        }
        this.moveCount += Number(this.moveCount<40)
        let sp = Math.sqrt(this.lastMouseSpeed)
        let speed = sp * (this.moveCount * .07)
        let v = this.speedNumber.pushGet(speed)
        this.mouse.point.radius = clamp(v, 2, 40)
        this.lastMouseSpeed = this.mouse.speed()
    }

    startLine(point) {
        /* Start a line at a position*/
        this.line = new PointList(point)
        this.walkTicker = setInterval(this.tickFunc.bind(this), this.tickerInterval)
    }

    stopLine(point) {
        this.line.push(point)
        clearInterval(this.walkTicker)
        this.walkTicker = undefined
    }

    tickFunc() {
        /* Tick event,
        if the distance is greater than the existing, add point.*/
        let mp = this.mouse.point
        let l = this.points
        let l2 = this.points2
        let last = this.lastPoint || l.last()
        let perform = true;



================================================================================
END: potter-dual-lines.js
================================================================================



================================================================================
FILE: protractor-point.editor.js
================================================================================

/*
title: Protractor Point.editor
*/

/* Perform this:
https://www.youtube.com/watch?v=SUI_AWpgmzU

draw two rays from the two points (o1, o2) (of any angle)
o1 has r1, o2 has r2
set the protractor to r3
then (along the ray), plot r2+r3
same on the other point, plot r1+r3 -> obtains a new radius for o1
setting the compass on o1, we draw the radius r1+r3
setting the compass on o2, we draw the radius r2+r3

Where the two new circles intersect, these become o3 and o4, being the
origin points of our new tangent arc

join points o1 to o3, o3 to o2, o2 to o4, o4 to o1
this produces 4 lines (a diamond shape).
The intersection of those lines with the original r1 and r2 are the four tangent points.

now draw an arc from o2 with a radius of r2,
draw from t1 through to t2
*/

Polypoint.head.load(
        // "../point_src/core/head.js"
        'point'
            // , "../point_src/point.js"
            // , "../point_src/point-content.js"
            // , "../point_src/pointpen.js"
            // , "../point_src/pointdraw.js"
        , 'stage'
            // , "../point_src/stage.js"
        , 'pointlist'
            // , "../point_src/pointlist.js"
        , 'mouse'
            // , "../point_src/events.js"
            // , "../point_src/automouse.js"
        , 'dragging'
            // , "../point_src/distances.js"
            // , "../point_src/dragging.js"
        , 'bisector'
        , 'stroke'
            // , "../point_src/setunset.js"
            // , "../point_src/stroke.js"
        , "../point_src/functions/clamp.js"
        , "../point_src/curve-extras.js"
        , "../point_src/intersections.js"
        // , "../theatre/protractor-point.js"
        , ()=>{
                console.log('Running stage')
                setTimeout(()=>onRun(), 1)
        }
)

const onRun = function(){

function quantizeNumber(value, quantize=1) {
  const quantizedValue = Math.round(value / quantize) * quantize;
  return quantizedValue;
}


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = new Point({x:200,y:300, radius:70})
        this.pointB = new Point({x:500,y:300, radius:100})
        this.dragging.addPoints(this.pointA, this.pointB)
        this.events.wake()

        this.lines = []
        this.rLength = 200
    }

    draw(ctx){
        this.clear(ctx)

        let a = this.pointA;
        let b = this.pointB;

        let r1 = a.radius
        let r2 = b.radius
        let r3 = this.rLength

        // Then build the new protractor points.
        let c = a.copy().update({
            radius: r1 + r3
        })

        let d = b.copy().update({
            radius: r2 + r3
        })


        c.pen.circle(ctx, undefined, '#777')
        d.pen.circle(ctx, undefined, '#777')


================================================================================
END: protractor-point.editor.js
================================================================================



================================================================================
FILE: protractor-point.js
================================================================================

/*
title: Protractor Point
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/curve-extras.js
    ../point_src/mirror.js
    ../point_src/stage.js
    ../point_src/text/label.js
    ../point_src/intersections.js


Perform this:
https://www.youtube.com/watch?v=SUI_AWpgmzU

draw two rays from the two points (o1, o2) (of any angle)
o1 has r1, o2 has r2
set the protractor to r3
then (along the ray), plot r2+r3
same on the other point, plot r1+r3 -> obtains a new radius for o1
setting the compass on o1, we draw the radius r1+r3
setting the compass on o2, we draw the radius r2+r3

Where the two new circles intersect, these become o3 and o4, being the
origin points of our new tangent arc

join points o1 to o3, o3 to o2, o2 to o4, o4 to o1
this produces 4 lines (a diamond shape).
The intersection of those lines with the original r1 and r2 are the four tangent points.

now draw an arc from o2 with a radius of r2,
draw from t1 through to t2
*/



function quantizeNumber(value, quantize=1) {
  const quantizedValue = Math.round(value / quantize) * quantize;
  return quantizedValue;
}


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = new Point({x:200,y:300, radius:70})
        this.pointB = new Point({x:500,y:300, radius:100})
        this.dragging.addPoints(this.pointA, this.pointB)
        this.events.wake()

        this.lines = []
        this.rLength = 200
    }

    draw(ctx){
        this.clear(ctx)

        let a = this.pointA;
        let b = this.pointB;

        let r1 = a.radius
        let r2 = b.radius
        let r3 = this.rLength

        // Then build the new protractor points.
        let c = a.copy().update({
            radius: r1 + r3
        })

        let d = b.copy().update({
            radius: r2 + r3
        })


        c.pen.circle(ctx, undefined, '#777')
        d.pen.circle(ctx, undefined, '#777')

        a.pen.indicator(ctx)
        b.pen.indicator(ctx, {color: this.pointB.color})

        this.lines.forEach(l=>l.render(ctx))

        let o34 = getCircleCircleIntersections(c, d)
        if(o34.length > 0) {
            // let [o3, o4] = o34
            let o3 = new Point(o34[1])
            let o4 = new Point(o34[0])
            let o1 = a


================================================================================
END: protractor-point.js
================================================================================



================================================================================
FILE: pseudo3D-cube-2.js
================================================================================

/*
---
title: 3D Sphere
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/shapes/cube.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js

---


*/


class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.depth = 400
        let count = 10
        /* Generate 100 points, within a 500px box, at origin 0,0 */
        // this.points = PointList.from(generateSpherePoints(count, 300)).cast()
        this.points = PointList.from(generateCubeShellPoints(count, 400)).cast()
        this.points.each.radius = 3
        this.projectionPoint = this.points.center.copy()
        this.projectionLength = 500
        this.perspectiveCenter = this.center.copy()

        this.rotSize = 0
        this.performSpin = true
        this.zFix = true
        let stage = this;
    }

    step(){
        let spin = this.spin = {
                x: this.rotSize
                , y:  this.rotSize
                , z: -this.rotSize
            }

        this.spunPoints = this.points.pseudo3d.perspective(
                  this.spin
                , this.projectionPoint
                , this.projectionLength
                , this.perspectiveCenter
            )
        let maxDepth = this.depth
        let deepColor = 200
        this.spunPoints.forEach((p, i)=>{
            let z = p.z
            let red = deepColor - ((z / maxDepth) * deepColor)
            // let colorBlue = "hsl(184 50% 40%)"
            // let colorRed = "hsl(0 66% 40%)"
            let color = `hsl(${red} 66% 35%)`
            p.color = color
        })
        this.zFix && this.spunPoints.sortByZ()
        // this.perspectiveCenter = this.spunPoints.copy().add(0, 0)


    }

    onMousedown(){
        this.performSpin = !this.performSpin
    }

    draw(ctx){
        this.clear(ctx)
        let sv = 0.02
        if(this.performSpin){
            sv = .2
        }
        this.rotSize += sv
        this.step()
        // let color = '#666'
        // this.points.pen.indicators(ctx, {color})
        // this.spunPoints.pen.indicators(ctx)
        let maxDepth = this.depth
        let deepColor = 200

        this.spunPoints.forEach((p, i)=>{
            let z = p.z
            let red = deepColor - ((z / maxDepth) * deepColor)
            // let colorBlue = "hsl(184 50% 40%)"


================================================================================
END: pseudo3D-cube-2.js
================================================================================



================================================================================
FILE: pseudo3D-cube-3.js
================================================================================

/*
---
title: 3D Sphere
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/shapes/cube.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js

---


*/


class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.depth = 400
        let count = 5
        /* Generate 100 points, within a 500px box, at origin 0,0 */
        // this.points = PointList.from(generateSpherePoints(count, 300)).cast()
        this.points = PointList.from(generateCubeShellPoints(count, 400)).cast()
        this.points.each.radius = 10
        this.projectionPoint = this.points.center.copy()
        this.projectionLength = 1000
        this.perspectiveCenter = this.center.copy()

        this.rotSize = 0
        this.performSpin = true
        this.zFix = true
        let stage = this;
    }

    step(){
        let spin = this.spin = {
                x: this.rotSize
                , y:  this.rotSize
                , z: -this.rotSize
            }

        this.spunPoints = this.points.pseudo3d.perspective(
                  this.spin
                , this.projectionPoint
                , this.projectionLength
                , this.perspectiveCenter
            )
        let maxDepth = this.depth
        let deepColor = 300
        this.spunPoints.forEach((p, i)=>{
            let z = p.z
            let red = deepColor - ((z / maxDepth) * deepColor)
            // let colorBlue = "hsl(184 50% 40%)"
            // let colorRed = "hsl(0 66% 40%)"
            let color = `hsl(${red} 66% 35%)`
            p.color = color
        })
        this.zFix && this.spunPoints.sortByZ()
        // this.perspectiveCenter = this.spunPoints.copy().add(0, 0)


    }

    onMousedown(){
        this.performSpin = !this.performSpin
    }

    draw(ctx){
        this.clear(ctx)
        let sv = 0.02
        if(this.performSpin){
            sv = .2
        }
        this.rotSize += sv
        this.step()
        // let color = '#666'
        // this.points.pen.indicators(ctx, {color})
        // this.spunPoints.pen.indicators(ctx)
        let maxDepth = this.depth
        let deepColor = 200

        this.spunPoints.forEach((p, i)=>{
            let z = p.z
            let red = deepColor - ((z / maxDepth) * deepColor)
            // let colorBlue = "hsl(184 50% 40%)"


================================================================================
END: pseudo3D-cube-3.js
================================================================================



================================================================================
FILE: pseudo3D-cube.js
================================================================================

/*
---
title: pseudo3D Cube
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/stage-clock.js
    ../point_src/text/alpha.js
    ../point_src/rotate.js
    ../point_src/text/fps.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js

Pseudo 3D Cube

 */
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){

        this.projectionLength = 300
        this.rotSize = 0

        this.setupCuboid()

        this.dragging.add(this.projectionPoint, this.perspectiveCenter)
        this.events.wake()
    }

    setupCuboid(padding=100, plane=9) {
        let row = Math.sqrt(plane)
        let offset = this.center.subtract(padding)

        const frontSet = PointList.generate.grid(plane, row, padding, offset)
        const backSet = PointList.generate.grid(plane, row, padding, offset)

        frontSet.each.z = padding * -.5
        backSet.each.z = padding * .5

        this.frontSet = frontSet
        this.backSet = backSet
        let cp = this.frontSet.center.copy()
        this.projectionPoint = cp
        this.perspectiveCenter = this.projectionPoint.copy().add(-200, 0)
    }

    step() {
        this.rotSize += .6
        let spin = this.spin = {
                x: -this.rotSize
                , y:  this.rotSize
                , z: 0
            }

        this.frontSpunPoints = this.frontSet.pseudo3d.perspective(
                  this.spin
                , this.projectionPoint
                , this.projectionLength
                , this.perspectiveCenter
            )

        this.backSpunPoints = this.backSet.pseudo3d.perspective(
                  this.spin
                , this.projectionPoint
                , this.projectionLength
                , this.perspectiveCenter
            )
    }

    draw(ctx){
        this.step()
        this.clear(ctx)

        this.drawCube(ctx)

        this.fps.drawFPS(ctx);
    }

    drawCube(ctx){
        this.frontSpunPoints.pen.indicators(ctx, { color: 'gray', width: 1})
        this.backSpunPoints.pen.indicators(ctx, { color: 'gray', width: 1})

        this.frontSet.center.pen.indicator(ctx)
        this.backSet.center.pen.indicator(ctx)


================================================================================
END: pseudo3D-cube.js
================================================================================



================================================================================
FILE: pseudo3D-plane-2.js
================================================================================

/*
---
title: pseudo3D Very Perspective
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/stage-clock.js
    ../point_src/text/alpha.js
    ../point_src/rotate.js
    ../point_src/text/fps.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js

Rotate a plane in 3D

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.rotSize = 0

        let padding = 40
        let center = this.center.copy()
        const pointList = PointList.generate.grid(100, 10, padding)
        this.offsetPoints(pointList, padding, center)

        this.points = pointList
        this.centerPoint = new Point(center)

        this.dragging.add(this.centerPoint, this.points)
        this.events.wake()
    }

    offsetPoints(pointList, padding, center) {
        let size = pointList.getSize()
        let p2 = (new Point({x:padding+size.width, y: padding+size.height})).multiply(.5)
        let oc = (new Point(center)).subtract(p2)
        pointList.offset(oc)
    }

    step() {
        this.rotSize += .6
        let spin = this.spin = {
                x: 0
                , y:this.rotSize
                , z: 0
            }

        // this.spunPoints = this.points.pseudo3d.orthogonal(this.spin)
        this.spunPoints = this.points.pseudo3d.perspective(this.spin)
    }

    draw(ctx){
        this.step()
        this.clear(ctx)

        this.spunPoints.pen.indicators(ctx, { color: 'gray', width: 1})
        this.centerPoint.pen.indicator(ctx, { color: 'red', width: 1})
        this.fps.drawFPS(ctx);
    }
}

stage = MainStage.go()


================================================================================
END: pseudo3D-plane-2.js
================================================================================



================================================================================
FILE: pseudo3D-plane.js
================================================================================

/*
---
title: 3D Pseudo Rotation Plane
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/stage-clock.js
    ../point_src/text/alpha.js
    ../point_src/text/fps.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/rotate.js

Rotate a plane in 3D

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.center.radius = 50

        this.rotSize = 0
        this.projection = 300
        this.perspective = true

        let radius = 7
        let rowCount = 5 /* How many items per row within the grid */
        let count = 50
        const pointList = PointList.generate.random(count, [300,300], {x: 200, y:200})

        pointList.forEach(p=>p.radius = 2 + random.int(15))
        this.points = pointList

        this.dragging.add(...pointList)
        this.events.wake()

    }

    step() {
        this.rotSize += .1
        let spin = {x:this.rotSize, y: this.rotSize, z: this.rotSize}

        // orthogonal
        let center = {x:350, y:350}
        let spunPoints
        if(this.perspective) {
            spunPoints = pseudo3DRotate(this.points, spin, center, false)
            spunPoints = pseudo3DRotatePerspective(spunPoints, center, this.projection)
        } else {
            spunPoints = pseudo3DRotate(this.points, spin, center, true)
        }
        this.spunPoints = spunPoints.map(p=>new Point(p))
    }

    draw(ctx){
        this.step()
        this.clear(ctx)

        this.spunPoints.pen.indicators(ctx, { color: 'gray', width: 1})
        // this.points.pen.indicators(ctx, { color: 'gray', width: 1})

        this.fps.drawFPS(ctx);
    }
}

stage = MainStage.go()


================================================================================
END: pseudo3D-plane.js
================================================================================



================================================================================
FILE: pseudo3D-sphere-raw.js
================================================================================

/*
---
title: 3D Sphere
categories: pseudo3D
files:
    head
    point
    pointlist
    mouse
    stage
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js

---


*/
function generateSpherePoints(count = 100, radius = 1) {
  const points = [];
  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399...

  for (let i = 0; i < count; i++) {
    const y = 1 - (i / (count - 1)) * 2; // y from 1 to -1
    const r = Math.sqrt(1 - y * y);      // radius at y
    const theta = goldenAngle * i;      // angle around y-axis

    const x = Math.cos(theta) * r;
    const z = Math.sin(theta) * r;

    points.push({ x: x * radius, y: y * radius, z: z * radius});
  }

  return points;
}


function generateSpherePoints1(count = 100, radius = 1) {
  const points = [];
  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399...

  for (let i = 0; i < count; i++) {
    const y = 1 - ((i + 0.9) / count) * 2;  // avoid exact poles
    const r = Math.sqrt(1 - y * y);        // radius at this y
    const theta = goldenAngle * i;

    const x = Math.cos(theta) * r;
    const z = Math.sin(theta) * r;

    points.push({ x: x * radius, y: y * radius, z: z * radius });
  }

  return points;
}



function generateSpherePointsFib(count = 100, radius = 1) {
  const points = [];
  const goldenAngle = Math.PI * (3 - Math.sqrt(5)); // ~2.399

  for (let i = 0; i < count; i++) {
    // let y = 1 - (i + 0.5) * (2 / count);
    const y = 1 - ((i + 0.5) / count) * 2;        // y in (-1, 1)
    const r = Math.sqrt(1 - y * y);               // radius at y
    const theta = goldenAngle * i;

    const x = Math.cos(theta) * r;
    const z = Math.sin(theta) * r;

    points.push({
      x: x * radius,
      y: y * radius,
      z: z * radius
    });
  }

  return points;
}


window.onmessage = function(e) {
    // console.log(e)
    stage.perspectiveCenter.set(e.data)
};


function generateSpherePointsLatLong(latCount = 10, lonCount = 20, radius = 1) {
  const points = [];

  // Latitude from 0 (north pole) to PI (south pole)
  for (let lat = 0; lat <= latCount; lat++) {
    const theta = (lat * Math.PI) / latCount; // polar angle
    const y = Math.cos(theta);                // y = cos(theta)
    const r = Math.sin(theta);                // horizontal radius at this latitude

    // Longitude from 0 to 2*PI
    for (let lon = 0; lon < lonCount; lon++) {
      const phi = (lon * 2 * Math.PI) / lonCount; // azimuthal angle


================================================================================
END: pseudo3D-sphere-raw.js
================================================================================



================================================================================
FILE: pseudo3D-sphere.js
================================================================================

/*
---
title: 3D Sphere
categories: pseudo3D
files:
    head
    point
    pointlist
    mouse
    stage
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js
    ../theatre/objects/sphere.js

---


*/

window.onmessage = function(e) {
    // console.log(e)
    stage.perspectiveCenter.set(e.data)
};



class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        let depth = this.depth = 500
        let count = 500
        let size = 290
        /* Generate 100 points, within a 500px box, at origin 0,0 */
        this.funcs = {
            SpherePointsFib: ()=> generateSpherePointsFib(count, size)
            , LesserGeodesicSphere: ()=> generateLesserGeodesicSphere(150) , LatLongEquatorialFocusSphere: ()=> generateLatLongEquatorialFocusSphere(100, 200).points
            , LatLongSphereMesh: ()=> generateLatLongSphereMesh(500, 200).points
            , GeodesicSphereMesh: ()=> generateGeodesicSphereMesh(200, 200).points
            , GeodesicSphereByPointCount: ()=> generateGeodesicSphereByPointCount(200, 200)
            , GeodesicSpherePoints: ()=> generateGeodesicSpherePoints(3,200).points
            , SpherePointsLatLong: ()=> generateSpherePointsLatLong(20, 20, 250)
            , SphereTrianglesAsPoints: ()=> generateSphereTrianglesAsPoints(20, 20, 250)
            , SpherePointsFib: ()=> generateSpherePointsFib(count, size)
            , SpherePointsFibMesh:()=> generateFibonacciSphereMesh(400, 200).points
        }

        this.funcName = 'SpherePointsLatLong'
        // this.points = PointList.from(generateSpherePointsFib(count, size)).cast()
        // this.points = PointList.from(generateLesserGeodesicSphere(50)).cast()
        let func = this.funcs[this.funcName]
        this.points = PointList.from(func()).cast()
        // this.points = PointList.from(generateLatLongEquatorialFocusSphere(30, 100).points).cast()
        // this.points = PointList.from(generateLatLongSphereMesh(500, 200).points).cast()
        // this.points = PointList.from(generateGeodesicSphereMesh(200, 200).points).cast()
        // this.points = PointList.from(generateGeodesicSphereByPointCount(200, 200)).cast()
        // this.points = PointList.from(generateGeodesicSpherePoints(3,200).points).cast()
        // this.points = PointList.from(generateSpherePointsLatLong(20, 20, 250)).cast()
        // this.points = PointList.from(generateSphereTrianglesAsPoints(20, 20, 250)).cast()
        // this.points = PointList.from(generateSpherePointsFib(count, size)).cast()
        this.points.each.radius = 2
        // this.projectionPoint = this.points.center.copy()
        this.projectionLength = 400
        this.perspectiveCenter = this.center.copy()

        this.rotSize = 0
        this.performSpin = false
        this.zFix = true
        let stage = this;

        addControl('type', {
            field: 'select'
            , onchange(ev) {
                let v = ev.currentTarget.value
                // console.log('set easeNameY to', v)
                stage.funcName = v
                let func = stage.funcs[v]
                stage.points = PointList.from(func()).cast()

            }
            , options: Object.keys(this.funcs)
        })
    }


    step(){
        let spin = this.spin = {
                x: this.rotSize - 100
                , y:  this.rotSize
                , z: -this.rotSize
            }

        this.spunPoints = this.points.pseudo3d.orthogonal(
        // this.spunPoints = this.points.pseudo3d.perspective(
                  this.spin
                , this.projectionPoint
                , this.projectionLength


================================================================================
END: pseudo3D-sphere.js
================================================================================



================================================================================
FILE: pseudo3D-tetra.js
================================================================================

/*
---
title: 3D Tetrahedron
categories: pseudo3D
files:
    head
    stage
    point
    pointlist
    mouse
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js
    ../theatre/objects/tetra.js

---


*/


window.onmessage = function(e) {
    // console.log(e)
    stage.perspectiveCenter.set(e.data)
};




class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        let depth = this.depth = 900
        let count = 500
        let size = 290
        // this.points = PointList.from(generateRadialTetrahedronMesh(500, 200).points).cast()
        this.points = PointList.from(generateFlatTetrahedronMesh(500, 400).points).cast()
        // this.points = PointList.from(generateSquarePyramidMesh(300, 500).points).cast()

        this.points.each.radius = 2
        // this.projectionPoint = this.points.center.copy()
        this.projectionLength = 800
        this.perspectiveCenter = this.center.copy()

        this.rotSize = 0
        this.performSpin = false
        this.zFix = true
        let stage = this;
    }


    step(){
        let spin = this.spin = {
                x: this.rotSize - 100
                , y:  this.rotSize
                , z: -this.rotSize
            }

        this.spunPoints = this.points.pseudo3d.perspective(
                  this.spin
                , this.projectionPoint
                , this.projectionLength
                , this.perspectiveCenter
            )
        let maxDepth = this.depth
        let deepColor = 600
        this.zFix && this.spunPoints.sortByZ()
        this.spunPoints.forEach((p, i)=>{
            let z = p.z
            let red = deepColor - ((z / maxDepth) * deepColor)
            // let colorBlue = "hsl(184 50% 40%)"
            // let colorRed = "hsl(0 66% 40%)"
            let color = `hsl(${red} 66% 35%)`
            p.color = color
        })
        // this.perspectiveCenter = this.spunPoints.copy().add(0, 0)


    }

    onMousedown(){
        this.performSpin = !this.performSpin
    }

    draw(ctx){
        this.clear(ctx)
        let sv = 0.02
        if(this.performSpin){
            sv = .2
        }
        this.rotSize += sv
        this.step()
        // let color = '#666'
        // this.points.pen.indicators(ctx, {color})
        // this.spunPoints.pen.indicators(ctx)
        let maxDepth = this.depth
        let deepColor = 900


================================================================================
END: pseudo3D-tetra.js
================================================================================



================================================================================
FILE: pseudo3D-waveplot.js
================================================================================

/*
---
title: 3D Pseudo Wave Plot
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/stage-clock.js
    ../point_src/text/alpha.js
    ../point_src/text/fps.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/rotate.js



 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.rotSize = 0
        this.projectionLength = 900
        let padding = 20
        let height = 10
        let center = this.center.copy()
        const pointList = PointList.generate.grid(100, 10, padding)
        const pc = pointList.center
        pointList.each.z = (p)=> {
                let d = p.distanceTo(pc)
                return (Math.cos(d * .1) ) * 10
            }

        this.offsetPoints(pointList, padding, center)

        this.points = pointList
        this.centerPoint = new Point(center)

        this.projectionCenter = new Point(center)
        this.dragging.add(this.centerPoint, this.points, this.projectionCenter)
        this.events.wake()
    }

    offsetPoints(pointList, padding, center) {
        let size = pointList.getSize()
        let p2 = (
                    new Point({
                        x: padding+size.width
                        , y: padding+size.height
                    })
                ).multiply(.5)
        let oc = (new Point(center)).subtract(p2)
        pointList.offset(oc)
    }

    step() {
        this.rotSize += .02
        let spin = this.spin = {
                x: 130
                , y: 0
                , z: this.rotSize
            }

        // this.spunPoints = this.points.pseudo3d.orthogonal(this.spin)
        this.spunPoints = this.points.pseudo3d.perspective(this.spin
                , undefined
                , this.projectionLength
                , this.projectionCenter
                )
    }

    draw(ctx){
        this.step()
        this.clear(ctx)

        this.spunPoints.pen.indicators(ctx, { color: 'gray', width: 1})
        this.centerPoint.pen.indicator(ctx, { color: 'red', width: 1})
        this.projectionCenter.pen.indicator(ctx, { color: 'green', width: 1})
        this.fps.drawFPS(ctx);
    }
}

stage = MainStage.go()


================================================================================
END: pseudo3D-waveplot.js
================================================================================



================================================================================
FILE: pseudo3D-wirefame-cube.js
================================================================================

/*
---
title: 3D Sphere
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/shapes/cube.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js

---


*/


class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.depth = 400
        let count = 2
        /* Generate 100 points, within a 500px box, at origin 0,0 */
        // this.points = PointList.from(generateSpherePoints(count, 300)).cast()
        this.points = PointList.from(generateCubeShellPoints(count, 200)).cast()
        this.points.each.radius = 5
        this.projectionPoint = this.points.center.copy()
        this.projectionLength = 1200
        this.perspectiveCenter = this.center.copy()

        this.rotSize = 0
        this.performSpin = true
        this.zFix = false

        this.strokes.create('a', {
            dash: [7,4]
            , march: .3
        })
    }

    step(){
        let spin = this.spin = {
                x: this.rotSize
                , y:  this.rotSize
                , z: -this.rotSize
            }

        this.spunPoints = this.points.pseudo3d.perspective(
                  this.spin
                , this.projectionPoint
                , this.projectionLength
                , this.perspectiveCenter
            )

        this.zFix && this.spunPoints.sortByZ()
    }

    onMousedown(){
        this.performSpin = !this.performSpin
    }

    draw(ctx){
        this.clear(ctx)
        let sv = 0.02
        if(this.performSpin){
            sv = .2
        }
        this.rotSize += sv
        this.step()
        // let color = '#666'
        // this.points.pen.indicators(ctx, {color})
        // this.spunPoints.pen.indicators(ctx)
        this.strokes.get('a').wrap(ctx, ()=>this.drawSpokes(ctx))
        this.drawShell(ctx)

        this.spunPoints.forEach((p, i)=>{
            p.pen.fill(ctx, 'purple')
            // ctx.fillStyle = 'red'
            // p.text.label(ctx, i)
        })
    }

    connect(ctx, ia, ib, color='#555', width=2) {
        return this.spunPoints[ia].pen.line(ctx, this.spunPoints[ib], color, width)
    }

    drawSpokes(ctx) {


================================================================================
END: pseudo3D-wirefame-cube.js
================================================================================



================================================================================
FILE: pseudo3D-z-depth.js
================================================================================

/*
---
title: Rotate 3D
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js

---

*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        let depth = this.depth = 1000
        let z = ()=> -(depth) + Math.random() * depth + (depth * .5)
        this.points = PointList.generate.random(100, 500, {x: 200, y: 200, z})
        this.projectionPoint = this.points.center.copy()
        this.projectionLength = 1000
        this.perspectiveCenter = this.projectionPoint.copy()
        this.rotSize = 0
        this.performSpin = false

    }

    step(){
        let spin = this.spin = {
                x: 0
                , y:  this.rotSize
                , z: 0
            }

        this.spunPoints = this.points.pseudo3d.perspective(
                  this.spin
                , this.projectionPoint
                , this.projectionLength
                , this.perspectiveCenter
            )
        this.spunPoints.sortByZ()
        // this.perspectiveCenter = this.spunPoints.copy().add(0, 0)

    }

    onMousedown(){
        this.performSpin = !this.performSpin
    }

    draw(ctx){
        this.clear(ctx)
        if(this.performSpin){
            this.rotSize += .2
        }
        this.step()
        // let color = '#666'
        // this.points.pen.indicators(ctx, {color})
        // this.spunPoints.pen.indicators(ctx)
        let maxDepth = this.depth
        let deepColor = 200
        this.spunPoints.forEach((p)=>{
            let z = p.z
            let red = deepColor - ((z / maxDepth) * deepColor)
            // let colorBlue = "hsl(184 50% 40%)"
            // let colorRed = "hsl(0 66% 40%)"
            let color = `hsl(${red} 66% 35%)`
            p.pen.fill(ctx, color)
        })
    }
}


;stage = MainStage.go();

================================================================================
END: pseudo3D-z-depth.js
================================================================================



================================================================================
FILE: pseudo3D-z-plane.js
================================================================================

/*
---
title: pseudo3D Z Plane
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/stage-clock.js
    ../point_src/text/alpha.js
    ../point_src/rotate.js
    ../point_src/text/fps.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js

Pseudo 3D a plane on the Z axis

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.rotSize = 0
        this.projectionLength = 400
        let padding = 40
        let height = 10
        let center = this.center.copy()
        const pointList = PointList.generate.grid(100, 10, padding)
        pointList.each.z = ()=> random.int(-height, height)

        this.offsetPoints(pointList, padding, center)

        this.points = pointList
        this.centerPoint = new Point(center)

        this.dragging.add(this.centerPoint, this.points)
        this.events.wake()
    }

    offsetPoints(pointList, padding, center) {
        let size = pointList.getSize()
        let p2 = (
                    new Point({
                        x: padding+size.width
                        , y: padding+size.height
                    })
                ).multiply(.5)
        let oc = (new Point(center)).subtract(p2)
        pointList.offset(oc)
    }

    step() {
        this.rotSize += .2
        let spin = this.spin = {
                x: 130
                , y: 0
                , z: this.rotSize
            }

        // this.spunPoints = this.points.pseudo3d.orthogonal(this.spin)
        this.spunPoints = this.points.pseudo3d.perspective(this.spin, undefined, this.projectionLength)
    }

    draw(ctx){
        this.step()
        this.clear(ctx)

        this.spunPoints.pen.indicators(ctx, { color: 'gray', width: 1})
        this.centerPoint.pen.indicator(ctx, { color: 'red', width: 1})
        this.fps.drawFPS(ctx);
    }
}

stage = MainStage.go()


================================================================================
END: pseudo3D-z-plane.js
================================================================================



================================================================================
FILE: pseudo3DRotate-projection-types.js
================================================================================

/*
---
title: pseudo3D Orthogonal vs Perspective
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/stage-clock.js
    ../point_src/text/alpha.js
    ../point_src/rotate.js
    ../point_src/text/fps.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js

Rotate a plane in 3D

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.center.radius = 50

        this.rotSize = 0
        this.projection = 300
        this.perspective = true

        let radius = 7
        let rowCount = 5 /* How many items per row within the grid */
        let count = 50
        let cy = this.center.y
        let center = {x:500, y:cy}
        const pointList = PointList.generate.grid(20, 5, 30, {x:400, y:cy-200})
        const pointList2 = PointList.generate.grid(20, 5, 30, {x:400, y:cy+100})
        this.centerPoint = new Point(center)
        // pointList.forEach(p=>p.radius = 2 + random.int(15))
        this.points = pointList
        this.points2 = pointList2

        this.dragging.add(this.centerPoint)
        this.events.wake()

    }

    step() {
        this.rotSize += 1
        let spin = {x:0, y: this.rotSize, z: 0}

        // orthogonal
        let spunPoints
        let center = this.centerPoint;
        if(this.perspective) {
            spunPoints = pseudo3DRotate(this.points, spin, center, false)
            spunPoints = pseudo3DRotatePerspective(spunPoints, center, this.projection)
        }

        this.spunPointsA = spunPoints.map(p=>new Point(p))
        this.spunPointsB = pseudo3DRotate(this.points2, spin, center, true).map(p=>new Point(p))
    }

    draw(ctx){
        this.step()
        this.clear(ctx)

        this.spunPointsA.pen.indicators(ctx, { color: 'gray', width: 1})
        this.spunPointsB.pen.indicators(ctx, { color: '#aaa', width: 1})
        this.centerPoint.pen.indicator(ctx, { color: 'red', width: 1})
        // this.points.pen.indicators(ctx, { color: 'gray', width: 1})

        this.fps.drawFPS(ctx);
    }
}

stage = MainStage.go()


================================================================================
END: pseudo3DRotate-projection-types.js
================================================================================



================================================================================
FILE: qt-quadtree.js
================================================================================

/*
title: QT Quadtree
*/

	class QuadTree {
		constructor(boundary, n) {
			this.boundary = boundary;
			this.capacity = n;
			this.points = [];
			this.divided = false;
		}

		clear() {
			this.points = []
			this.divided = false;
		}

		subdivide() {
			if(this.divided) {
				return;
			}

			let hw = this.boundary.w * .5
			let hh = this.boundary.h * .5
			let bx = this.boundary.x
			let by = this.boundary.y
			// nw
			let nw = new Rectangle(
				bx - hw,
				by - hh,
				hw,
				hh
			);
			this.northwest = new QuadTree(nw, this.capacity);

			// ne
			let ne = new Rectangle(
				bx + hw,
				by - hh,
				hw,
				hh
			);
			this.northeast = new QuadTree(ne, this.capacity);

			// sw
			let sw = new Rectangle(
				bx - hw,
				by + hh,
				hw,
				hh
			);
			this.southwest = new QuadTree(sw, this.capacity);

			// se
			let se = new Rectangle(
				bx + hw,
				by + hh,
				hw,
				hh
			);
			this.southeast = new QuadTree(se, this.capacity);

			// prevent further dividing
			this.divided = true;
		}

		insert(point) {
			if(!this.boundary.contains(point)) {
				return;
			}

			if(this.points.length < this.capacity) {
				this.points.push(point);
				return
			}

			this.subdivide();

			this.northwest.insert(point);
			this.northeast.insert(point);
			this.southwest.insert(point);
			this.southeast.insert(point);

		}

		query(range, found) {
			if(!found) {
				found = new PointList;
			}

			if(!this.boundary.insersects(range)) {
				return found;
			}

			for(let p of this.points) {
				if(range.contains(p)) {
					found.push(p);
				}
			}



================================================================================
END: qt-quadtree.js
================================================================================



================================================================================
FILE: qt-rectangle.js
================================================================================

/*
title: QT Rectangle
*/
	
	class Rectangle {
		constructor(x, y, w, h) {
			this.x = x;
			this.y = y;
			this.w = w;
			this.h = h;
		}
		
		contains(point) {
			return (
				   (point.x >= (this.x - this.w))
				&& (point.x <  (this.x + this.w))
				&& (point.y >= (this.y - this.h))
				&& (point.y <  (this.y + this.h))
			);
		}
		
		insersects(range) {
			return !(
				   range.x - range.w > this.x + this.w
				|| range.x + range.w < this.x - this.w
				|| range.y - range.h > this.y + this.h
				|| range.y + range.h < this.y - this.h
			);
		}
	}
	

================================================================================
END: qt-rectangle.js
================================================================================



================================================================================
FILE: qt-sketch.js
================================================================================

/*
title: QT Sketch
*/
	
	let qtree;
	
	function setup() {
		createCanvas(600, 600);
		
		let boundary = new Rectangle(300, 300, 300, 300);
		qtree = new QuadTree(boundary, 4);
		
		for(let i = 0; i < 500; i++) {
			//let p = new Point(random), random(height));
			let x = randomGaussian(width/2, width/8);
			let y = randomGaussian(height/2, height/8);
			let p = new Point(x, y);
			
			qtree.insert(p);
		}
	}
	
	function draw() {
		if(mouseIsPressed) {
			let p = new Point(mouseX, mouseY);
			qtree.insert(p);
		}
		
		background(0);
		
		qtree.show();
		
		stroke(0, 255, 0);
		strokeWeight(1);
		rectMode(CENTER);
		
		let range = new Rectangle(mouseX, mouseY, 75, 64);
		
		let points = qtree.query(range);
		
		stroke(200, 0, 0);
		strokeWeight(1);
		text("Found: "+ points.length, (range.x + 3 - range.w), (range.y - 10 - range.h));
		
		stroke(0, 255, 0);
		strokeWeight(1);
		fill(color(0, 255, 0, 30));
		rect(range.x, range.y, (range.w * 2), (range.h * 2));
		
		stroke(0, 255, 0);
		strokeWeight(3);
		
		for(let p of points) {
			point(p.x, p.y);
		}
	}
	

================================================================================
END: qt-sketch.js
================================================================================



================================================================================
FILE: quad-curve.js
================================================================================

/*
title: Quad Curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js



 */
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        // this.pa = new Point(150, 150, 100, 90)

        this.ma = new Point(300, 400, 100)
        this.mb = new Point(600, 400, 100)

        let lpoints = [this.ma, this.mb]

        this.line = new QuadraticCurve(...lpoints)
        this.projection = this.ma.project()

        this.lineStroke = new Stroke({
            color: 'green'
            , width: 5
            , dash: [7, 4]
        })

        this.strokes.create('line', {
            color: 'green'
            , width: 5
            , dash: [7, 4]
        })

        this.dragging.add(this.ma, this.mb, this.projection)
    }

    coupling() {
        this.ma.lookAt(this.projection)
        this.ma.radius = this.ma.distanceTo(this.projection)
        // this.mb.rotation = this.ma.rotation + 180
    }

    updateTip() {
        let { dx, dy } = get_bezier_derivative(this.ma
                                    , this.projection
                                    , this.mb, this.mb, .9)
        this.mb.radians = Math.atan2(dy, dx);
    }

    draw(ctx){
        this.clear(ctx)
        this.coupling()
        let pos = this.mouse.position
        pos.pen.circle(ctx)

        this.ma.pen.indicator(ctx)
        this.mb.pen.indicator(ctx)

        this.projection.pen.fill(ctx, '#33DDAA')

        let lineStroke = this.lineStroke
        // // lineStroke.set(ctx)
        // this.strokes.set('line')
        // this.line.render(ctx)
        // this.strokes.unset('line')
        // // lineStroke.unset(ctx)

        // let off = this.strokes.line()
        // this.line.render(ctx)
        // off()

        this.strokes.line(()=>this.line.render(ctx))

    }
}

;stage = MainStage.go();

================================================================================
END: quad-curve.js
================================================================================



================================================================================
FILE: quad-loop.js
================================================================================

/*
---
title: Quad Curve Loop
categories: quadcurve
    curve
files:
    head
    stroke
    pointlist
    point
    mouse
    dragging
    stage
    ../point_src/curve-extras.js

---

Draw a quad curve (as a loop) using the  `PointList.draw.quadCurve` method.
It uses `quadraticCurveTo` across all points, with loop closure
*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = new PointList(
                [40, 240, 10]
                , [150, 140, 10]
                , [240, 220, 10]
                , [350, 500, 10]
                , [460, 200, 10]
                , [120, 234, 10]
                , [150, 100, 10]
                , [360, 97, 10]
                // , [350, 300, 10]
                // , [226, 340, 10]
            ).cast()

        this.dragging.addPoints(...this.points)
        this.points.shape.radius(200, new Point(300,300))
    }

    draw(ctx){
        this.clear(ctx)
        ctx.fillStyle = '#661177';
        ctx.strokeStyle = '#661177';

        // this.points.pen.line(ctx)
        this.points.pen.quadCurve(ctx, {color:undefined}, 1)
        // ctx.stroke()
        // ctx.fill()
        this.points[0].pen.fill(ctx)
        this.points.pen.indicator(ctx, {color: '#555'})
    }
}


;stage = MainStage.go();

================================================================================
END: quad-loop.js
================================================================================



================================================================================
FILE: quadratic-example.js
================================================================================

/*
title: Quadratic Example
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/text/beta.js


 */
let rotationPoint = new Point(300, 300)


class MainStage extends Stage {
    canvas = 'playspace'
    rot = 0

    mounted(){
        this.pointA = new Point(100, 100, 5)
        this.pointB = new Point(250, 250, 5)
        this.pointC = new Point(350, 120, 5)
        this.controlPointA = new Point(230, 150, 5)
        this.controlPointB = new Point(270, 400, 5)

        this.dragging.add(
                this.pointA
                , this.pointB
                , this.pointC
                , this.controlPointA
                , this.controlPointB
            )
    }

    draw(ctx){
        this.clear(ctx)
        let pa = this.pointA;
        let pb = this.pointB;
        let pc = this.pointC;
        let cpa = this.controlPointA;
        let cpb = this.controlPointB;

        let c = '#aa0077'

        pa.pen.fill(ctx, c)
        // pb.pen.fill(ctx, c)
        pc.pen.fill(ctx, c)

        cpa.pen.circle(ctx)
        cpb.pen.circle(ctx)

        ctx.strokeStyle = c;
        ctx.beginPath();
        ctx.moveTo(pa.x, pa.y);
        ctx.quadraticCurveTo(cpa.x, cpa.y, pb.x, pb.y);
        ctx.quadraticCurveTo(cpb.x, cpb.y, pc.x, pc.y);
        ctx.stroke();


    }

}


;stage = MainStage.go()

================================================================================
END: quadratic-example.js
================================================================================



================================================================================
FILE: quadtree-example.js
================================================================================

/*
title: Linear Arrangement
categories: arrange
files:
    head
    stage
    point
    pointlist
    dragging
    stroke
    mouse
    ../point_src/random.js
    ../theatre/qt-rectangle.js
    ../theatre/qt-quadtree.js
*/
let boundary = new Rectangle(340, 340, 300, 300);
qtree = new QuadTree(boundary, 4);

class MainStage extends Stage {
    canvas = 'playspace'

    mounted() {
        this.reset()
    }

    reset() {
        this.points = PointList.generate.random(2000, 600, [100,100, 1])
        qtree.clear()
        this.points.forEach(p=>qtree.insert(p))
    }

    onMousedown(ev) {
        let p = Point.from(ev)
        qtree.insert(p);
        this.points.push(p)
    }

    draw(ctx) {
        this.clear(ctx);
        this.points.pen.circle(ctx, undefined, 'red')
        draw(ctx, this.mouse.point)
    }

}


function draw(ctx, mouse) {
    ctx.strokeStyle = 'orange'
    qtree.show(ctx);
    ctx.stroke()

    // rectMode(CENTER);

    let range = new Rectangle(mouse.x, mouse.y, 50, 50);
    let found = qtree.query(range);

    ctx.strokeStyle = 'green'
    let hw = range.w
    let hh = range.h
    ctx.rect(range.x - hw
            , range.y - hh
            , range.w * 2
            , range.h * 2)
    ctx.stroke()

    found.pen.circle(ctx, undefined, 'yellow')

}

stage = MainStage.go()


================================================================================
END: quadtree-example.js
================================================================================



================================================================================
FILE: quantize-point.js
================================================================================

/*
title: Quantize Point
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/text/label.js
---

*/

function quantizeNumber(value, quantize=1) {
  const quantizedValue = Math.round(value / quantize) * quantize;
  return quantizedValue;
}



class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = new Point(200,200)
        this.pointB = new Point(100,100)
        this.dragging.addPoints(this.pointA, this.pointB)
        this.events.wake()

    }

    onMousemove(e) {
        this.pointA.x = e.offsetX
        this.pointA.y = e.offsetY
        this.pointB.copy(this.pointA.quantize(quantizeNumber(this.pointA.radius)))
    }

    onMousedown(e) {
        this.pointB.color = 'green'
    }

    onMouseup(e) {
        this.pointB.color = undefined
    }

    draw(ctx){
        this.clear(ctx)

        this.pointA.pen.indicator(ctx)
        this.pointB.pen.indicator(ctx, {color: this.pointB.color})

    }
}


;stage = MainStage.go();

================================================================================
END: quantize-point.js
================================================================================



================================================================================
FILE: rainbow-arc-pointlist-another.js
================================================================================

/*
title: Rainbow Arc Pointlist Another
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/bisector.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
---
*/
const arcLoop = function(ctx, points) {

    /*
    From start point, project of radius towards the next.
    Then arcTo until exausted.
    */
    //
    let startPoint = points.first()
    let nextPoint = points[1]

    let midPoint = startPoint.lerp(nextPoint, .5)
    // let midPoint = startPoint.lerpPixel(nextPoint, startPoint.radius)

    /* For convenience we render it. */
    midPoint.pen.indicator(ctx, {color: 'grey'});
    ctx.strokeStyle = 'red'

    ctx.beginPath();
    // ctx.moveTo(startPoint.x, startPoint.y);

    let previousPoint = midPoint
    let pl = points.length;

    for (var i = 1; i < pl; i++) {
        let p = points[i]

        let toPoint = p;
        let r = previousPoint.radius
        ctx.arcTo(previousPoint.x, previousPoint.y, toPoint.x, toPoint.y, r);
        previousPoint = p
    }

    let last = points[pl-1]

    ctx.arcTo(previousPoint.x, previousPoint.y, startPoint.x, startPoint.y, previousPoint.radius);
    ctx.arcTo(startPoint.x, startPoint.y, midPoint.x, midPoint.y, startPoint.radius);
    // ctx.arcTo(midPoint.x, midPoint.y, nextPoint.x, nextPoint.y, startPoint.radius);
    ctx.lineTo(midPoint.x, midPoint.y, nextPoint.x, nextPoint.y, startPoint.radius);

}



class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        // this.point = new Point(50, 50)
        const r = 200
        const shareSize = 15

        // 45

        this.points = new PointList(
                // this.center.add(-r, 0)
                new Point({ x: 100, y: 300  })
                , new Point({ x: 300, y: 300 })
                , new Point({ x: 400, y: 500, radius: 20  })
                , new Point({ x: 450, y: 300, radius: 8  })
                , new Point({ x: 500, y: 500, radius: 10  })
                , new Point({ x: 550, y: 550, radius: 10  })
            )

        this.points[1].radius = 30
        this.points[0].radius = this.points[1].radius = shareSize
        // this.points[0].color = "hsl(299deg 62% 44%)"
        // this.points[1].color = "hsl(244deg 71% 56%)"

        this.near = this.center.copy()

        this.dis = new Dragging
        this.dis.initDragging(this)
        // this.dis.onDragMove = this.onDragMove.bind(this)
        // this.dis.onDragEnd = this.onDragEnd.bind(this)
        this.dis.addPoints(...this.points)

    }


================================================================================
END: rainbow-arc-pointlist-another.js
================================================================================



================================================================================
FILE: rainbow-arc-pointlist.js
================================================================================

/*
title: Rainbow Arc Pointlist
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/bisector.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
---
*/


const arcLine = function(ctx, points) {
    ctx.beginPath();
    // midPoint.pen.indicator(ctx)

    let startPoint = points[0]

    ctx.moveTo(startPoint.x, startPoint.y);

    let previousPoint = startPoint;
    let pl = points.length;

    // debugger;
    for (var i = 0; i < pl; i++) {
        let p = points[i]
        // if(previousPoint) {
            // if(i == pl-1) {
                // end point
                // ctx.lineTo(p.x, p.y);
            // } else {
                let toPoint = p;
                let r = previousPoint.radius
                ctx.arcTo(previousPoint.x, previousPoint.y, toPoint.x, toPoint.y, r);
            // }
        // }
        previousPoint = p
        // this.drawArc(ctx, midPoint, pointC, pointD)
    }
    let last = points[pl-1]
    ctx.lineTo(last.x, last.y);

    // ctx.stroke();
}



class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        // this.point = new Point(50, 50)
        const r = 200
        const shareSize = 15

        // 45

        this.points = new PointList(
                // this.center.add(-r, 0)
                new Point({ x: 100, y: 300, color: 'red'  })
                , new Point({ x: 300, y: 300, color: 'orange' })
                , new Point({ x: 400, y: 500, radius: 20, color: 'green'  })
                , new Point({ x: 450, y: 300, radius: 8, color: 'blue'  })
                , new Point({ x: 500, y: 500, radius: 10, color: 'indigo'  })
                , new Point({ x: 550, y: 550, radius: 10, color: 'violet'  })
            )

        this.points[1].radius = 30
        this.points[0].radius = this.points[1].radius = shareSize
        // this.points[0].color = "hsl(299deg 62% 44%)"
        // this.points[1].color = "hsl(244deg 71% 56%)"

        this.near = this.center.copy()

        // this.dis = new Distances
        // this.dis.addPoints(this.center, this.point0, this.point1)
        this.dis = new Dragging
        this.dis.initDragging(this)
        this.dis.onDragMove = this.onDragMove.bind(this)
        // this.dis.onDragEnd = this.onDragEnd.bind(this)
        this.dis.addPoints(...this.points)

        this.generateGrad()

    }

    generateGrad() {


================================================================================
END: rainbow-arc-pointlist.js
================================================================================



================================================================================
FILE: random-example.js
================================================================================

/*
title: Tethered Controller Point
categories: binding
files:
    head
    point
    pointlist
    mouse
    stage
    dragging
    stroke
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/range.js
    ../point_src/tethers.js
    ../point_src/stage-clock.js
---

*/
addButton('Add Random',{
    onclick(){
        range(100).forEach(()=>{
            stage.addNewPoint()
        })
    }
})

addButton('Add Guassian',{
    onclick(){
        // stage.addNewPoint()
        range(100).forEach(()=>{
            stage.addGaussianNewPoint()
        })
    }
})


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.point = this.center.copy().update({radius: 100})
        this.points = new PointList()
        this.dragging.add(this.point)
        this.addGaussianNewPoint()
        this.addGaussianNewPoint()
    }

    addNewPoint() {
        let p = new Point(random.within(this.point, .5))
        p.radius = 3
        this.points.push(p)
        // this.dragging.add(p)
    }

    addGaussianNewPoint() {
        let r = this.point.radius
        let p = this.point.copy().update({radius: 3})
        p.x += random.gaussian(0, r*.5, 0, .5)
        p.y += random.gaussian(0, r*.5, 0, .5)
        this.points.push(p)
        // this.dragging.add(p)
    }

    draw(ctx){
        this.clear(ctx)
        let p = this.point
        p.pen.indicator(ctx, {color: '#336600'})
        this.points.pen.fill(ctx, {color: '#336600'})
    }
}



;stage = MainStage.go();

================================================================================
END: random-example.js
================================================================================



================================================================================
FILE: random-gauge-value.js
================================================================================

/*
title: Random Gauge Value
files:
    ../point_src/core/head.js
    ../point_src/point-content.js
    pointlist
    point
    stage
    mouse
    dragging
    stroke
    ../point_src/functions/clamp.js
    ../point_src/text/beta.js
    ../point_src/functions/rel.js
---
The _red_ gauge presents a raw `Math.random()`. The _green_ gauge presents
a random with a calculated bias, to correct the long-term drift of a random
function.

Over time you'll see the unbiased gauge slowly drift away from a zero summation, where the
biased gauge always tends towards zero.
 */


class MainStage extends Stage {
    canvas = 'playspace'

    /*
        Update speed of 1 is fastest.
    */
    updateSpeed = 1
    mounted(){
        let a = this.a = (new Point(this.center)).update({radius: 200, y: rel(-50)})
        let b = this.b = this.a.copy().update({y: rel(100)})
        this.modu = 0

        b.total = a.total = 0
        /*
        The Bias pushes the _needle_ in a preferred direction.
        In theory .5 is _no bias_ But the -1 to 1 may natually walk away
        from the bias.

        On _my machine_ this bias tends to negative at `.4999`,
        and tends to positive at `.49999`. So a heustic _nudge_ may be prudent.
        */
        b.bias = a.bias = .5
        b.biasOffset = a.biasOffset = .00001

        this.dragging.add(this.a, this.b)

        console.log('Mount')
        addControl('updateSpeed', {
            field: 'range'
            , label: 'update speed'
            , step: 1
            , max: 200
            , stage: this
            , onchange(ev) {
                /*slider changed. */
                // debugger;
                let sval = ev.currentTarget.value
                this.stage.updateSpeed = parseInt(Math.sqrt(sval)*2)
            }
        })
    }

    draw(ctx) {
        this.clear(ctx)
        this.modu += 1
        this.modu % this.updateSpeed == 0 && this.updateWalkers(1, .5)

        // this.a.pen.fill(ctx, '#222255')
        ctx.fillStyle = '#eeddcc'
        ctx.font = 'normal 20px Courier New'

        let b = this.b;
        b.pen.indicator(ctx)
        let t1 = `${b.total.toFixed(1)}\n${b.biasOffset.toFixed(3)}`
        b.text.string(ctx, t1)

        let a = this.a;
        a.pen.indicator(ctx, {color: 'red'})
        let t = `${a.total.toFixed(1)}\n${a.biasOffset.toFixed(3)}`
        a.text.string(ctx, t)
    }

    roll(p){
        return (-1 + Math.random()) + (.5 + Math.random()) - p.bias - p.biasOffset
    }

    lesserRoll(){
        /* The more _pure_ form of random tends to drift into positive.
        */
        return -.5 + Math.random()
    }

    updateWalkers(iterationLimit=1, max=1) {
        let correction = .00001
        let a = this.a
        let b = this.b


================================================================================
END: random-gauge-value.js
================================================================================



================================================================================
FILE: random-point-pump-emitter.js
================================================================================

/*
title: Random Point Pump Emitter
categories: Random Point Emitter
files:
    head
    ../point_src/math.js
    ../point_src/point-content.js
    pointlist
    point
    mouse
    ../point_src/random.js
    dragging
    stage
    stroke
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
---

A Pump Emitter spawns many points per iteration, around the circumference of the
point.


*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        // let e3 = new Emitter(500,200, 60)
        let e3 = new PumpRandomPointEmitter(500,200, 60)
        // e3.fromEdge = true
        // e3.tickModulo = 100
        // e3.birthrate = 100
        // e3.lifetime = 100
        // e3.radiusVariant = .1
        // e3.directionVariant = 360
        // e3.minSize = 2
        e3.wake()
        this.e3 = e3
        this.dragging.add(e3)
    }

    draw(ctx){
        this.clear(ctx)
        let es = this.e3
        ctx.strokeStyle = 'red'
        ctx.fillStyle = '#880000'
        es.step()
        // es.rotation += 1
        // es.lookAt(this.mouse.point)
        es.pen.indicator(ctx)
        // es.points.pen.indicators(ctx)
        es.points.pen.fill(ctx)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: random-point-pump-emitter.js
================================================================================



================================================================================
FILE: random_point_line.js
================================================================================

/*
title: Random_point_line
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
 */
const canvas = document.getElementById('playspace');
const ctx = canvas.getContext('2d');
// Point.mouse.listen(canvas)


const pendulum_main = function(){
    let rect = canvas.getBoundingClientRect()
    ctx.canvas.width  = rect.width;
    ctx.canvas.height = rect.height;
    draw()
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    update()
    requestAnimationFrame(draw);
}

const update = function() {
    drawRandomLine()
}


const UNSET = {}


const quickStroke = function(color='green', lineWidth=UNSET) {
    ctx.strokeStyle = color
    if(lineWidth != UNSET) {
        ctx.lineWidth = lineWidth
    }
    ctx.stroke()
}

const randomLine = PointList.generate.random(20, 500)

const drawRandomLine = function(){
    /* draw a randomly generated line path */

    /* Draw the horizon line - a straight project from A to B*/
    ctx.beginPath();
    randomLine.draw.horizonLine(ctx)
    quickStroke('red')

    /* Draw each point as a line to its next sibling.*/
    randomLine.draw.pointLine(ctx)
    quickStroke('teal', 2)


    /* Draw each point; wrapping the _draw_ call_ with our own functionality.*/
    // randomLine.draw.pointLine(ctx)
    // randomLine.draw.points(ctx, (item,f)=>{
    //     ctx.beginPath();
    //     f(item)
    //     quickStroke('pink', 2)
    // })
    // quickStroke('pink', 2)

    // May bleed if not applied.
    ctx.closePath();
}



;pendulum_main();

================================================================================
END: random_point_line.js
================================================================================



================================================================================
FILE: ray-example.js
================================================================================

/*
title: Ray Example
files:
    ../point_src/core/head.js
    ../point_src/stage.js
    ../point_src/point-content.js
    ../point_src/pointdraw.js
    ../point_src/pointpen.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/constrain-distance.js
    ../point_src/distances.js

 */
const ray = {start: {x:100, y:300}, end: {x:500, y:500}}
const otherRay = {start: {x:100, y:20}, end: {x:50, y:350}}


const checkIntersection = function(line, otherLine, length=400) {
    const x1 = line.start.x;
    const y1 = line.start.y;


    // Normalize the direction vector (end - start) and apply the length
    const dx = line.end.x - x1;
    const dy = line.end.y - y1;
    const magnitude = Math.sqrt(dx * dy + dy * dy);

    let directionX = (dx / magnitude) * length;
    let directionY = (dy / magnitude) * length;

    const x2 = line.start.x + directionX;
    const y2 = line.start.y + directionY;

    const x3 = otherLine.start.x;
    const y3 = otherLine.start.y;

    const x4 = otherLine.end.x;
    const y4 = otherLine.end.y;

    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (denom === 0) return false; // Parallel lines

    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

    if (t > 0 && t < 1 && u > 0 && u < 1) {
        const intersectX = x1 + t * (x2 - x1);
        const intersectY = y1 + t * (y2 - y1);
        return { x: intersectX, y: intersectY };
    }
    return false;
}

const checkIntersectionWithRotation = function(line, otherLine, length=400) {
    const x1 = line.start.x;
    const y1 = line.start.y;

    // Normalize the direction vector (end - start) and apply the length
    const dx = line.end.x - x1;
    const dy = line.end.y - y1;
    const magnitude = Math.sqrt(dx * dx + dy * dy);

    let directionX = (dx / magnitude) * length;
    let directionY = (dy / magnitude) * length;

    const x2 = line.start.x + directionX;
    const y2 = line.start.y + directionY;

    const x3 = otherLine.start.x;
    const y3 = otherLine.start.y;

    const x4 = otherLine.end.x;
    const y4 = otherLine.end.y;

    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (denom === 0) return false; // Parallel lines

    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

    if (t > 0 && t < 1 && u > 0 && u < 1) {
        const intersectX = x1 + t * (x2 - x1);
        const intersectY = y1 + t * (y2 - y1);

        // Calculate the angle from the intersection point to the start of otherLine
        const angleRad = Math.atan2(y3 - intersectY, x3 - intersectX);

        return { x: intersectX, y: intersectY, radians: angleRad };
    }
    return false;
}


/* Reflect _through_ the ray, landing on the opposite side of the ray */


================================================================================
END: ray-example.js
================================================================================



================================================================================
FILE: rectangle-example.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    pointlist
    stage
    stroke
    ../point_src/rectangle.js
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/
class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {

        this.points = PointList.generate.list(8, new Point(100, 0), new Point(100, 200))
        this.points.each.radius = 15
        this.point = this.points[2].copy()
        this.point.radius = 30
    }

    draw(ctx){
        this.clear(ctx)
        // this.points.pen.rect(ctx,{width: 4, color: '#444'})
        this.points.pen.rectangles(ctx, {color:'purple'})
        this.point.pen.rectangle(ctx, {
                width: 60
                , color: '#8f6faf'
                , radii:[7]
                , strokeWidth: 1
            })
        // this.point.pen.rect(ctx, {color: '#8f6faf'})
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: rectangle-example.js
================================================================================



================================================================================
FILE: recttools-example.js
================================================================================

/*
---
title: RectTools example
categories: rectangles
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/split.js
    ../point_src/jiggle.js
    ../point_src/random.js
    ../point_src/recttools.js
    ../point_src/curve-extras.js
---
*/

const rt = new RectTools(20, 20, 200, 200)
// the overspill radius * .5


class MainStage extends Stage {
    canvas='playspace'

    mounted(){

        let a = this.a = new Point({x:200,y:200, radius: 50, rotation: 0})
        let b = this.b = new Point({x:300,y:200, radius: 50, rotation: 0})
        this.dragging.add(a, b)
        this.events.wake()

        const box = new PointList(
                  new Point(150, 150)
                , new Point(500, 400)
            )

        this.lines = twoPointBox(...box)

        this.rectTools = new RectTools(
                                    box[0].x, box[0].y
                                    , box[1].x, box[1].y
                                )
        // testRect()
    }

    onClick(){

    }

    draw(ctx){
        this.clear(ctx)
        // this.a.rotation += .5
        let a = this.a
        let color = 'hsl(100deg, 50%, 20%)'
        if( this.rectTools.containsPoint(a) ){
            color = 'hsl(200deg, 100%, 60%)'
        }
        a.pen.fill(ctx, color)

        let b = this.b
        color = 'hsl(100deg, 50%, 20%)'
        if( this.rectTools.touchingPoint(b) ){
        // if( this.rectTools.hasPoint(b) ){
            color = 'hsl(200deg, 100%, 60%)'
        }
        b.pen.fill(ctx, color)

        this.lines.forEach(l=>l.render(ctx, {color: 'red'}))
    }
}


;stage = MainStage.go();

================================================================================
END: recttools-example.js
================================================================================



================================================================================
FILE: reflect-1.js
================================================================================

/*
title: Reflect 1
categories: reflections
files:
    ../point_src/core/head.js
    ../point_src/stage.js
    ../point_src/point-content.js
    ../point_src/pointdraw.js
    ../point_src/pointpen.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/constrain-distance.js

 */
const ray = {start: {x:100, y:300}, end: {x:500, y:500}}
const otherRay = {start: {x:100, y:20}, end: {x:50, y:350}}


const checkIntersection = function(line, otherLine, length=400) {
    const x1 = line.start.x;
    const y1 = line.start.y;


    // Normalize the direction vector (end - start) and apply the length
    const dx = line.end.x - x1;
    const dy = line.end.y - y1;
    const magnitude = Math.sqrt(dx * dy + dy * dy);

    let directionX = (dx / magnitude) * length;
    let directionY = (dy / magnitude) * length;

    const x2 = line.start.x + directionX;
    const y2 = line.start.y + directionY;

    const x3 = otherLine.start.x;
    const y3 = otherLine.start.y;

    const x4 = otherLine.end.x;
    const y4 = otherLine.end.y;

    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (denom === 0) return false; // Parallel lines

    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

    if (t > 0 && t < 1 && u > 0 && u < 1) {
        const intersectX = x1 + t * (x2 - x1);
        const intersectY = y1 + t * (y2 - y1);
        return { x: intersectX, y: intersectY };
    }
    return false;
}

const checkIntersectionWithRotation = function(line, otherLine, length=400) {

    const x1 = line.start.x;
    const y1 = line.start.y;

    // Normalize the direction vector (end - start) and apply the length
    const dx = line.end.x - x1;
    const dy = line.end.y - y1;
    const magnitude = Math.sqrt(dx * dx + dy * dy);

    let directionX = (dx / magnitude) * length;
    let directionY = (dy / magnitude) * length;

    const x2 = line.start.x + directionX;
    const y2 = line.start.y + directionY;

    const x3 = otherLine.start.x;
    const y3 = otherLine.start.y;

    const x4 = otherLine.end.x;
    const y4 = otherLine.end.y;

    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (denom === 0) return false; // Parallel lines

    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

    if (t > 0 && t < 1 && u > 0 && u < 1) {
        const intersectX = x1 + t * (x2 - x1);
        const intersectY = y1 + t * (y2 - y1);

        // Calculate the angle from the intersection point to the start of otherLine
        const angleRad = Math.atan2(y3 - intersectY, x3 - intersectX);

        return { x: intersectX, y: intersectY, radians: angleRad };
    }
    return false;
}


================================================================================
END: reflect-1.js
================================================================================



================================================================================
FILE: reflect-2.js
================================================================================

/*
title: Reflect 2
categories: reflections
files:
    ../point_src/core/head.js
    ../point_src/stage.js
    ../point_src/point-content.js
    ../point_src/pointdraw.js
    ../point_src/pointpen.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/constrain-distance.js
*/
const checkIntersection = function(planeLine, raybeam, length) {
    const x1 = planeLine.start.x;
    const y1 = planeLine.start.y;

    if(length == undefined) {
        length = distance(planeLine.start, planeLine.end)
    }

    // Normalize the direction vector (end - start) and apply the length
    const dx = planeLine.end.x - x1;
    const dy = planeLine.end.y - y1;
    const magnitude = Math.sqrt(dx * dx + dy * dy);

    let directionX = (dx / magnitude) * length;
    let directionY = (dy / magnitude) * length;

    const x2 = planeLine.start.x + directionX;
    const y2 = planeLine.start.y + directionY;

    const x3 = raybeam.start.x;
    const y3 = raybeam.start.y;

    const x4 = raybeam.end.x;
    const y4 = raybeam.end.y;

    const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
    if (denom === 0) return false; // Parallel lines

    const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
    const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;

    if (t > 0 && t < 1 && u > 0 && u < 1) {
        const intersectX = x1 + t * (x2 - x1);
        const intersectY = y1 + t * (y2 - y1);

        // Calculate the angle from the intersection point to the start of raybeam
        const angleRad = Math.atan2(y3 - intersectY, x3 - intersectX);

        return { x: intersectX, y: intersectY, radians: angleRad };
    }
    return false;
}


/* Reflect _through_ the ray, landing on the opposite side of the ray */
function getAngle(point, line) {
    // Step 1: Convert the incident angle (from radians) to a vector
    const incidentVectorX = Math.cos(point.radians);
    const incidentVectorY = Math.sin(point.radians);

    // Step 2: Calculate the normal of the line (perpendicular to the line)
    const dx = line.end.x - line.start.x;
    const dy = line.end.y - line.start.y;

    // The normal vector can be (-dy, dx) or (dy, -dx)
    const normalX = -dy;
    const normalY = dx;

    // Normalize the normal vector
    const normalMagnitude = Math.sqrt(normalX * normalX + normalY * normalY);
    const normalUnitX = normalX / normalMagnitude;
    const normalUnitY = normalY / normalMagnitude;

    // Step 3: Reflect the incident vector using the normal vector
    const dotProduct = incidentVectorX * normalUnitX + incidentVectorY * normalUnitY;
    const reflectVectorX = incidentVectorX - 2 * dotProduct * normalUnitX;
    const reflectVectorY = incidentVectorY - 2 * dotProduct * normalUnitY;

    // Step 4: Convert the reflected vector back to an angle in radians
    const reflectAngle = Math.atan2(reflectVectorY, reflectVectorX);

    return reflectAngle;
}


function getAngleAlt(point, line) {
    // Step 1: Convert the incident angle (from radians) to a vector
    const incidentVectorX = Math.cos(point.radians);
    const incidentVectorY = Math.sin(point.radians);



================================================================================
END: reflect-2.js
================================================================================



================================================================================
FILE: reflect-3.js
================================================================================

/*
title: Reflect 3
categories: reflections
files:
    head
    stage
    ../point_src/point-content.js
    stroke
    point
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    mouse
    dragging
    ../point_src/constrain-distance.js
*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){

        // ray beam
        this.ray = new PointList(
            new Point(250, 150, 10)
            , new Point(400, 320, 10)
        )

        // A Line representing the plane in 2d (front view)
        this.plane = new PointList(
            new Point(200, 300, 10)
            , new Point(500, 300, 10)
        )

        this.dragging.add(...this.ray, ...this.plane)
    }

    draw(ctx){
        this.clear(ctx)

        let ray = this.ray;
        let line = this.plane;
        let rayBeam = {start: ray[0], end: ray[1]}

        // ray beam from 0 to 1
        ray[0].lookAt(ray[1])
        ray[1].lookAt(ray[0])

        ray.pen.indicators(ctx)
        // Draw the plane
        line.pen.line(ctx, {color:'#AAA', width: 3})

        let planeRay = {start: line[0], end: line[1]}
        let planeLen = distance(line[0], line[1])
        // let p = checkIntersection(planeRay, rayBeam, planeLen)
        let hitPoint = checkIntersection(planeRay, rayBeam, planeLen)

        let p1 = this.center
        if(!hitPoint) {

            p1.copy().update({
                radius: 10
                , radians: getBounceAngle(ray[1], planeRay)
            }).pen.indicator(ctx, {color: 'red'})

            return
        }

        p1 = new Point(hitPoint)
        p1.radius = 20

        /* inbound angle, pointing at the first point. */
        // p1.pen.line(ctx, null, 'green', 2)

        /* symmetry angle, inverse of the inbound */
        // const mirrorPoint = p1.copy().update({
        //     radius: 20
        //     , radians: getAngle(hitPoint, planeRay)
        // })
        // mirrorPoint.pen.indicator(ctx, {color: 'gray'})


        /* reflect angle.*/
        const reflectPoint = p1.copy().update({
            radius: 20
            , radians: getBounceAngle(hitPoint, planeRay)
        })


        let overLen = distance(reflectPoint, ray[1])
        reflectPoint.project(overLen).pen.indicator(ctx, {color: 'gray'})
        reflectPoint.pen.line(ctx, null, 'red', 2)
    }
}

const checkIntersection = function(planeLine, raybeam, length) {
    const x1 = planeLine.start.x;
    const y1 = planeLine.start.y;

    if(length == undefined) {


================================================================================
END: reflect-3.js
================================================================================



================================================================================
FILE: rel-function.js
================================================================================

/*
title: Rel Function
categories: relative
    functions
files:
    head
    ../point_src/point-content.js
    pointlist
    point
    mouse
    dragging
    stroke
    ../point_src/functions/clamp.js
    ../point_src/functions/rel.js
    stage
    ../point_src/split.js
    ../point_src/random.js
---

The `rel()` function provides _relative_ offset to values, such as the `point.x`.

In this example the center point is copied, and offset by `rel(-200)`.
*/

const boundCaller = function(func) {
    /* return a function to call the _given_ function.

    This allows a _dynamic_ value, called every update.

    For example, ensure the `y` value of a point is the same as `x`:

        a.y = boundCaller((p, k) => p.x)
    */
    return function relCaller(p, k) {
        console.log('Call once')
        return func.bind(p)
    }
}


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let offsetValue = -200
        this.center.radius = 40

        let a = this.a = this.center.copy()
        a.x = rel(offsetValue)

        this.dragging.add(a)
        a.y = boundCaller((p, k) => this.center.y + offsetValue)
    }

    draw(ctx){
        this.clear(ctx)
        this.a.pen.fill(ctx, `hsl(90deg 100% 30%)`)
        this.center.pen.fill(ctx, `hsl(90deg 10% 10%)`)
    }
}


;stage = MainStage.go();

================================================================================
END: rel-function.js
================================================================================



================================================================================
FILE: relative-bubbles.js
================================================================================

/*
title: Relative Bubbles
categories: relative
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/stage-clock.js
    ../point_src/text/alpha.js
    ../point_src/text/fps.js
    ../point_src/distances.js
    ../point_src/dragging.js
---

A relative motion of each point witin a random pointlist
*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.center.radius = 50

        let radius = 7
        let rowCount = 5 /* How many items per row within the grid */
        let count = 180
        const pointList = PointList.generate.random(count, 900, {x: 50, y:50})

        pointList.forEach(p=>p.radius = 2 + random.int(15))
        this.points = pointList

        this.dragging.add(...pointList)
        this.dragging.onEmptyDown = this.onEmptyDown.bind(this)
        this.events.wake()
    }

    onEmptyDown(ev) {
        console.log('onEmptyDown')
        this.isPanning = true
        this.origin = Point.from(ev)

    }

    onMousemove(ev) {
        if(!this.isPanning) {
            return
        }

        let d = Point.from(ev).distance2D(this.origin)
        console.log('Pan', d)
    }

    onMouseup(ev) {
        this.isPanning = false
    }

    step() {
        let tick = this.clock.tick * .01
        let offset = 40
        this.points.forEach(p=>{
            let r = p.rel
            r.x = Math.sin(p.x * .02 + tick) * offset
            r.y = Math.cos(p.y * .02 + tick) * offset
        })
    }

    draw(ctx){
        this.step()
        this.clear(ctx)
        let mousePoint = Point.mouse.position
        this.points.lookAt(mousePoint)
        /* Draw each point; wrapping the _draw_ call_ with our own functionality.*/
        this.points.pen.indicators(ctx, { color: 'gray', width: 1})

        this.origin?.pen.circle(ctx)

        this.fps.drawFPS(ctx);
    }
}

stage = MainStage.go()


================================================================================
END: relative-bubbles.js
================================================================================



================================================================================
FILE: relative-car-motion-2.js
================================================================================

/*
title: Relative Car Motion 2
categories: relative
    keyboard
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/keyboard.js
    ../point_src/relative.js
    ../point_src/functions/clamp.js
    ../point_src/screenwrap.js

*/

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        this.mouse.position.vy = this.mouse.position.vx = 0
        this.a = new Point({ x: 200, y: 200, vx: 0, vy: 0})
        this.events.click(this.mouseClick.bind(this))
        this.clickPoint = new Point(0,0)

        this.keyboard.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        this.keyboard.onKeyup(KC.UP, this.onUpKeyup.bind(this))

        this.keyboard.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))        
        this.keyboard.onKeyup(KC.DOWN, this.onDownKeyup.bind(this))
        
        this.keyboard.onKeydown(KEYS.SPACE, this.onSpaceKeydown.bind(this))
        this.keyboard.onKeyup(KEYS.SPACE, this.onSpaceKeyup.bind(this))

        this.keyboard.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        this.keyboard.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))

        this.keyboard.onKeyup(KC.LEFT, this.onLeftKeyup.bind(this))
        this.keyboard.onKeyup(KC.RIGHT, this.onRightKeyup.bind(this))

        this.a.update({radius: 10})
        this.rotationSpeed = 0
        this.speed = 0
        
        // Steering wheel simulation
        this.steeringAngle = 0        // Current steering wheel angle (-1 to 1)
        this.steeringRate = 0.03      // How fast steering wheel turns when holding key
        this.steeringReturn = 0.92    // How fast steering returns to center (lower = faster return)
        this.maxSteeringInput = 1.0   // Maximum steering wheel angle
        
        // Car body dimensions (visual)
        this.carLength = 40
        this.carWidth = 20
        
        // Center of mass offset (positive = toward rear, negative = toward front)
        // Rear-biased COM makes the rear swing out easier (better for drifting)
        this.comOffset = 5  // Slightly rear-biased
        
        // Wheel positions (relative to car center)
        this.frontWheelOffset = 15
        this.rearWheelOffset = -15
        
        // Drifting physics parameters
        this.frontGrip = 0.0010      // Front wheel lateral grip (REDUCED: less grip = more drift)
        this.rearGrip = 0.000005      // Rear wheel lateral grip (HALVED: super slippery rear end)
        this.grip = 0.99           // Overall forward grip factor (maintains speed)
        this.braking = false
        this.driftAngle = 0        // Visual drift angle for effect
        
        // Drift enhancement
        this.driftMultiplier = 2.5  // Amplifies lateral slip when turning at speed (INCREASED: way more sideways action)
        this.driftMomentum = 0      // Tracks drift state (0 = not drifting, 1 = full drift)
        this.driftMomentumDecay = 0.985  // How slowly drift momentum fades (INCREASED: longer sustained drifts)
        this.driftMomentumGain = 0.15   // How fast drift builds up (INCREASED: easier to initiate drifts)
        
        // Weight transfer (for Scandinavian flick)
        this.weightTransfer = .8    // Current weight bias (-1 = front heavy, +1 = rear heavy)
        this.weightTransferRate = 2.5   // CRAZY INCREASED: Weight shifts SUPER fast = INTENSE flicking action
        this.weightTransferDecay = 0.88  // Faster return = more snappy and responsive flicks
        
        // Steering limits (realistic car physics)
        this.maxSteeringAngle = 5.0     // Maximum rotation speed per frame in DEGREES (tighter turning)
        this.steeringSpeed = 3.0        // How fast steering responds to input
        this.minSpeedForTurning = 0.1   // Minimum speed needed for full steering effectiveness
        
        // Speed control parameters
        this.maxSpeed = 8            // Maximum velocity magnitude
        this.acceleration = 0.1     // How fast to accelerate (INCREASED for better drifting)
        this.speedDecay = 0.5       // Natural speed decay (higher = less friction)
        this.keyUpPressed = false
    }



================================================================================
END: relative-car-motion-2.js
================================================================================



================================================================================
FILE: relative-car-motion-3.js
================================================================================

/*
title: Relative Car Motion 3
categories: relative
    keyboard
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/keyboard.js
    ../point_src/relative.js
    ../point_src/functions/clamp.js
    ../point_src/screenwrap.js

*/

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        this.mouse.position.vy = this.mouse.position.vx = 0
        this.a = new Point({ x: 200, y: 200, vx: 0, vy: 0})
        this.events.click(this.mouseClick.bind(this))
        this.clickPoint = new Point(0,0)

        this.keyboard.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        this.keyboard.onKeyup(KC.UP, this.onUpKeyup.bind(this))

        this.keyboard.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))
        this.keyboard.onKeyup(KC.DOWN, this.onDownKeyup.bind(this))

        this.keyboard.onKeydown(KEYS.SPACE, this.onSpaceKeydown.bind(this))
        this.keyboard.onKeyup(KEYS.SPACE, this.onSpaceKeyup.bind(this))

        this.keyboard.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        this.keyboard.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))

        this.keyboard.onKeyup(KC.LEFT, this.onLeftKeyup.bind(this))
        this.keyboard.onKeyup(KC.RIGHT, this.onRightKeyup.bind(this))

        this.a.update({radius: 10})
        this.rotationSpeed = 0
        this.speed = 0

        // Steering wheel simulation
        this.steeringAngle = 0        // Current steering wheel angle (-1 to 1)
        this.steeringRate = 0.03      // How fast steering wheel turns when holding key
        this.steeringReturn = 0.92    // How fast steering returns to center (lower = faster return)
        this.maxSteeringInput = 1.0   // Maximum steering wheel angle

        // Car body dimensions (visual)
        this.carLength = 40
        this.carWidth = 20

        // Center of mass offset (positive = toward rear, negative = toward front)
        // Rear-biased COM makes the rear swing out easier (better for drifting)
        this.comOffset = 5  // Slightly rear-biased

        // Wheel positions (relative to car center)
        this.frontWheelOffset = 15
        this.rearWheelOffset = -15

        // Drifting physics parameters (using 0-100 scale for easier tuning)
        this.frontGripLevel = .10     // Front wheel lateral grip level (0-100 scale)
        this.rearGripLevel = 0.0010     // Rear wheel lateral grip level (0-100 scale, can go very low)
        this.frontGrip = this.frontGripLevel / 10000  // Converted to physics scale
        this.rearGrip = this.rearGripLevel / 100000   // Converted to physics scale (more sensitive)
        this.grip = 0.99           // Overall forward grip factor (maintains speed)
        this.lateralGripMultiplier = 0.1  // How much extra grip at high sideways speeds (higher now, throttle modulates it)
        this.lateralGripCurve = 5       // Exponential curve for lateral grip (INCREASED: only kicks in at high speeds)
        this.braking = false
        this.driftAngle = 0        // Visual drift angle for effect

        // Drift enhancement
        this.driftMultiplier = 4.0  // Amplifies lateral slip when turning at speed (INCREASED: 2.5  4.0 for MORE sideways action)
        this.driftMomentum = 0      // Tracks drift state (0 = not drifting, 1 = full drift)
        this.driftMomentumDecay = 0.988  // How slowly drift momentum fades (INCREASED: 0.985  0.988 for LONGER sustained drifts)
        this.driftMomentumGain = 0.20   // How fast drift builds up (INCREASED: 0.15  0.20 for easier initiation)

        // Weight transfer (for Scandinavian flick)
        this.weightTransfer = .8    // Current weight bias (-1 = front heavy, +1 = rear heavy)
        this.weightTransferRate = 5.0   // MASSIVELY INCREASED: Instant, violent weight shifts
        this.weightTransferDecay = 0.82  // Much faster return = more violent snap-back effect
        this.weightTransferMomentum = 0  // Tracks the momentum of weight shifts for visual feedback

        // Steering limits (realistic car physics)
        this.maxSteeringAngle = 5.0     // Maximum rotation speed per frame in DEGREES (tighter turning)
        this.steeringSpeed = 3.0        // How fast steering responds to input
        this.minSpeedForTurning = 0.1   // Minimum speed needed for full steering effectiveness

        // Speed control parameters
        this.maxSpeed = 15            // Maximum velocity magnitude


================================================================================
END: relative-car-motion-3.js
================================================================================



================================================================================
FILE: relative-car-motion-4.js
================================================================================

/*
title: Relative Car Motion 4
categories: relative
    keyboard
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/keyboard.js
    ../point_src/relative.js
    ../point_src/functions/clamp.js
    ../point_src/screenwrap.js

*/

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        this.mouse.position.vy = this.mouse.position.vx = 0
        this.a = new Point({ x: 200, y: 200, vx: 0, vy: 0})
        this.events.click(this.mouseClick.bind(this))
        this.clickPoint = new Point(0,0)

        this.keyboard.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        this.keyboard.onKeyup(KC.UP, this.onUpKeyup.bind(this))

        this.keyboard.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))        
        this.keyboard.onKeyup(KC.DOWN, this.onDownKeyup.bind(this))
        
        this.keyboard.onKeydown(KEYS.SPACE, this.onSpaceKeydown.bind(this))
        this.keyboard.onKeyup(KEYS.SPACE, this.onSpaceKeyup.bind(this))

        this.keyboard.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        this.keyboard.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))

        this.keyboard.onKeyup(KC.LEFT, this.onLeftKeyup.bind(this))
        this.keyboard.onKeyup(KC.RIGHT, this.onRightKeyup.bind(this))

        this.a.update({radius: 10})
        this.rotationSpeed = 0
        this.speed = 0
        
        // Steering wheel simulation
        this.steeringAngle = 0        // Current steering wheel angle (-1 to 1)
        this.steeringRate = 0.03      // How fast steering wheel turns when holding key
        this.steeringReturn = 0.92    // How fast steering returns to center (lower = faster return)
        this.maxSteeringInput = 1.0   // Maximum steering wheel angle
        
        // Car body dimensions (visual)
        this.carLength = 40
        this.carWidth = 20
        
        // Center of mass offset (positive = toward rear, negative = toward front)
        // Rear-biased COM makes the rear swing out easier (better for drifting)
        this.comOffset = 5  // Slightly rear-biased
        
        // Wheel positions (relative to car center)
        this.frontWheelOffset = 15
        this.rearWheelOffset = -15
        
        // Drifting physics parameters (using 0-100 scale for easier tuning)
        this.frontGripLevel = .10     // Front wheel lateral grip level (0-100 scale)
        this.rearGripLevel = 0.0010     // Rear wheel lateral grip level (0-100 scale, can go very low)
        this.frontGrip = this.frontGripLevel / 10000  // Converted to physics scale
        this.rearGrip = this.rearGripLevel / 100000   // Converted to physics scale (more sensitive)
        this.grip = 0.99           // Overall forward grip factor (maintains speed)
        this.lateralGripMultiplier = 0.1  // How much extra grip at high sideways speeds (higher now, throttle modulates it)
        this.lateralGripCurve = 5       // Exponential curve for lateral grip (INCREASED: only kicks in at high speeds)
        this.braking = false
        this.driftAngle = 0        // Visual drift angle for effect
        
        // Drift enhancement
        this.driftMultiplier = 2.5  // Amplifies lateral slip when turning at speed (INCREASED: way more sideways action)
        this.driftMomentum = 0      // Tracks drift state (0 = not drifting, 1 = full drift)
        this.driftMomentumDecay = 0.985  // How slowly drift momentum fades (INCREASED: longer sustained drifts)
        this.driftMomentumGain = 0.15   // How fast drift builds up (INCREASED: easier to initiate drifts)
        
        // Weight transfer (for Scandinavian flick)
        this.weightTransfer = .8    // Current weight bias (-1 = front heavy, +1 = rear heavy)
        this.weightTransferRate = 5.0   // MASSIVELY INCREASED: Instant, violent weight shifts
        this.weightTransferDecay = 0.82  // Much faster return = more violent snap-back effect
        this.weightTransferMomentum = 0  // Tracks the momentum of weight shifts for visual feedback
        
        // Steering limits (realistic car physics)
        this.maxSteeringAngle = 5.0     // Maximum rotation speed per frame in DEGREES (tighter turning)
        this.steeringSpeed = 3.0        // How fast steering responds to input
        this.minSpeedForTurning = 0.1   // Minimum speed needed for full steering effectiveness
        
        // Speed control parameters
        this.maxSpeed = 7            // Maximum velocity magnitude


================================================================================
END: relative-car-motion-4.js
================================================================================



================================================================================
FILE: relative-car-motion.js
================================================================================

/*
title: Relative Car Motion
categories: relative
    keyboard
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/keyboard.js
    ../point_src/relative.js
    ../point_src/functions/clamp.js

*/

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        this.mouse.position.vy = this.mouse.position.vx = 0
        this.a = new Point({ x: 200, y: 200, vx: 0, vy: 0})
        this.events.click(this.mouseClick.bind(this))
        this.clickPoint = new Point(0,0)

        this.keyboard.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        this.keyboard.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        this.keyboard.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))
        this.keyboard.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))

        this.a.update({radius: 10})
        this.rotationSpeed = 0
        this.speed = 0
    }

    onUpKeydown(ev) {
        // this.a.relative.forward(20)
        this.speed = .2 + (this.speed * 1.02)
    }

    onDownKeydown(ev) {
        this.speed = -.2 + (this.speed * .98)
        // this.speed -= 1
        // this.a.relative.backward(20)
        // this.a.relative.forward(-20)
    }

    onLeftKeydown(ev) {
        if(ev.shiftKey || ev.ctrlKey) {
            this.a.relative.left(10)
            return
        }

        this.rotationSpeed -= .2
    }

    onRightKeydown(ev) {
        if(ev.shiftKey || ev.ctrlKey) {
            this.a.relative.right(10)
            return
        }
        this.rotationSpeed += .2
    }

    mouseClick(ev) {
        this.clickPoint = new Point(ev.x, ev.y)
        this.a.target = this.clickPoint
    }

    draw(ctx) {
        this.clear(ctx)
        this.a.rotation += this.rotationSpeed
        this.rotationSpeed *= .98
        this.a.relative.forward(this.speed)
        // this.a.relative.move({x: 1, y: 0}, 0, 4)
        // this.a.relative.towards(this.clickPoint)
        this.a.pen.indicator(ctx)
        this.clickPoint.pen.indicator(ctx)
    }
}

const stage = MainStage.go()


================================================================================
END: relative-car-motion.js
================================================================================



================================================================================
FILE: relative-iter.js
================================================================================

/*
title: Relative Iter
categories: relative
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage-clock.js


A relative motion of each point witin a random pointlist
*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = this.center.copy().update({radius: 20})

        this.dragging.add(this.point)
        this.dragging.onEmptyDown = this.onEmptyDown.bind(this)
        this.events.wake()
    }

    onEmptyDown(ev) {
        console.log('onEmptyDown')
        this.origin = Point.from(ev)

    }

    onMousemove(ev) {
    }

    onMouseup(ev) {
    }

    step() {
        let speed = 6
        let radius = 100
        let tick = this.clock.tick * (speed * .01)
        this.point.rel.x = Math.sin(tick) * radius
        this.point.rel.y = Math.cos(tick) * radius
    }

    draw(ctx){
        this.step()
        this.clear(ctx)
        let mousePoint = Point.mouse.position
        this.point.lookAt(mousePoint)
        /* Draw each point; wrapping the _draw_ call_ with our own functionality.*/
        this.point.pen.indicator(ctx, { color: 'gray', width: 1})

        this.origin?.pen.circle(ctx)
    }
}

stage = MainStage.go()


================================================================================
END: relative-iter.js
================================================================================



================================================================================
FILE: relative-motion-2.js
================================================================================

/*
title: Relative Forward
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/keyboard.js
---

The point will always walk towards the plot direction, turning through
the _shortest_ angle
*/
const forward = function(p, turnSpeed=1, minSpeed=0, maxSpeed=1) {
    /* walk in the direction of the rotation*/

    let target = p.target
    if(target == undefined) {
        // target = p.project()
        target = Point.mouse.position
    }

    const mp = target //Point.mouse.position // target;
    p.turnTo(mp, turnSpeed);
    const r = p.radians
    const distance = p.distanceTo(mp)
    const radius = p.radius

    let stepAmount = (distance / radius ) * .3

    if(distance *.5 < radius) {
        p.target = undefined
    }

    stepAmount = clamp(stepAmount, minSpeed, maxSpeed)
     p.x += stepAmount * Math.cos(r);
     p.y += stepAmount * Math.sin(r);
}

// Helper function to clamp a value within a range
// const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

const relMoveNoRotation = function(p, direction, speed = 1, minSpeed = 0, maxSpeed = 1) {
    // Normalize the direction vector to ensure it's unit length
    const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y);

    // Avoid division by zero if direction vector is zero
    if (magnitude === 0) return;

    const normalizedDir = {
        x: direction.x / magnitude,
        y: direction.y / magnitude
    };

    // Clamp speed to be within the allowed range
    const clampedSpeed = clamp(speed, minSpeed, maxSpeed);

    // Update position `p` based on the normalized direction and speed
    p.x += normalizedDir.x * clampedSpeed;
    p.y += normalizedDir.y * clampedSpeed;
};


const relMoveD = function(p, direction, speed = 1, minSpeed = 0, maxSpeed = 1) {
    // Normalize the direction vector
    const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y);

    // Avoid division by zero if direction vector is zero
    if (magnitude === 0) return;

    const normalizedDir = {
        x: direction.x / magnitude,
        y: direction.y / magnitude
    };
    // Clamp speed to be within the allowed range
    // const clampedSpeed = clamp(speed, minSpeed, maxSpeed);

    // Get the current rotation of the point `p` in radians
    const r = p.radians;

    // Apply the direction based on the point's rotation
    // Transform the direction vector to account for the point's rotation
    const rotatedDir = {
        x: normalizedDir.x * Math.cos(r) - normalizedDir.y * Math.sin(r),
        y: normalizedDir.x * Math.sin(r) + normalizedDir.y * Math.cos(r)
    };

    // Update position `p` based on the rotated direction and clamped speed
    p.x += rotatedDir.x * clamp(direction.x, minSpeed, maxSpeed);
    p.y += rotatedDir.y * clamp(direction.y, minSpeed, maxSpeed);
};


================================================================================
END: relative-motion-2.js
================================================================================



================================================================================
FILE: relative-motion-5.js
================================================================================

/*
title: Relative Motion 5
categories: relative
    keyboard
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/keyboard.js
    ../point_src/relative.js


*/
// Function to convert angle to velocity vector
function angleToVelocity(theta, speed) {
  return {
    x: speed * Math.cos(theta),
    y: speed * Math.sin(theta)
  };
}


class Sectoring {
    /* Each movement through a bound will change the sector
        Assuming a rect space, we can calculate the 2D through vectoring

            [-1, 1]   [0,  1]   [1,  1]

            [-1, 0]    [0,0]    [1,  0]

            [-1, -1]  [0, -1]   [1, -1]

    */

   constructor(stage, point){
        this.stage = stage
        this.point = point
        this.secConst = this.sectorConstants()
        this._origin = [0, 0]
    }

    sectorConstants() {
        return {
            TOP_LEFT: [-1, 1]
            , TOP: [0,  1]
            , TOP_RIGHT: [1,  1]
            , LEFT: [-1, 0]
            , CENTER: [0,0]
            , RIGHT: [1,  0]
            , BOTTOM_LEFT: [-1, -1]
            , BOTTOM: [0, -1]
            , BOTTOM_RIGHT: [1, -1]
        }
    }

    step() {
        let item = this.point
        let bounds = this.stage.dimensions
        let boundry = this.getBound(item, bounds)
        if(boundry) {
            this.moveSector(item, boundry, bounds)
        }
    }

    moveSector(item, boundry, bounds) {
        /* Apply the boundry update. */
        let rel = this._origin
        rel[0] += boundry[0]
        rel[1] += boundry[1]
        this.printSector()

        item.x = item.x - (bounds.width * boundry[0])
        item.y = item.y + (bounds.height * boundry[1])
    }

    listSectors() {
        let sn = (v)=>{
            let n = this.sectorName(v)
            console.log(v, n)
        }

        sn([0, 0])
        sn([0, -1])
        sn([0, -2])
        sn([0, -3])
        sn([0, -4])
        sn([0, -5])

        sn([-1, 0])
        sn([-1, 1])
        sn([-1, 2])


================================================================================
END: relative-motion-5.js
================================================================================



================================================================================
FILE: relative-motion.js
================================================================================

/*
title: Relative Motion
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js


*/
const forward = function(p, turnSpeed=1, minSpeed=0, maxSpeed=1) {
    /* walk in the direction of the rotation*/

    let target = p.target
    if(target == undefined) {
        // target = p.project()
        target = Point.mouse.position
    }

    const mp = target //Point.mouse.position // target;
    p.turnTo(mp, turnSpeed);
    const r = p.radians
    const distance = p.distanceTo(mp)
    const radius = p.radius

    let stepAmount = (distance / radius ) * .3

    if(distance *.5 < radius) {
        p.target = undefined
    }

    stepAmount = clamp(stepAmount, minSpeed, maxSpeed)
     p.x += stepAmount * Math.cos(r);
     p.y += stepAmount * Math.sin(r);
}

// Helper function to clamp a value within a range
// const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

const relMoveNoRotation = function(p, direction, speed = 1, minSpeed = 0, maxSpeed = 1) {
    // Normalize the direction vector to ensure it's unit length
    const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y);

    // Avoid division by zero if direction vector is zero
    if (magnitude === 0) return;

    const normalizedDir = {
        x: direction.x / magnitude,
        y: direction.y / magnitude
    };

    // Clamp speed to be within the allowed range
    const clampedSpeed = clamp(speed, minSpeed, maxSpeed);

    // Update position `p` based on the normalized direction and speed
    p.x += normalizedDir.x * clampedSpeed;
    p.y += normalizedDir.y * clampedSpeed;
};


const relMove = function(p, direction, speed = 1, minSpeed = 0, maxSpeed = 1) {
    // Normalize the direction vector
    const magnitude = Math.sqrt(direction.x * direction.x + direction.y * direction.y);

    // Avoid division by zero if direction vector is zero
    if (magnitude === 0) return;

    const normalizedDir = {
        x: direction.x / magnitude,
        y: direction.y / magnitude
    };

    // Clamp speed to be within the allowed range
    const clampedSpeed = clamp(speed, minSpeed, maxSpeed);

    // Get the current rotation of the point `p` in radians
    const r = p.radians;

    // Apply the direction based on the point's rotation
    // Transform the direction vector to account for the point's rotation
    const rotatedDir = {
        x: normalizedDir.x * Math.cos(r) - normalizedDir.y * Math.sin(r),
        y: normalizedDir.x * Math.sin(r) + normalizedDir.y * Math.cos(r)
    };

    // Update position `p` based on the rotated direction and clamped speed
    p.x += rotatedDir.x * clampedSpeed;
    p.y += rotatedDir.y * clampedSpeed;
};




================================================================================
END: relative-motion.js
================================================================================



================================================================================
FILE: relative-spaceship2d-motion.js
================================================================================

/*
title: Relative Spaceship2d Motion
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/screenwrap.js

The arrow keys pushes the ship in a frictionless 2D space.

Keydown performs an `impartOnRads` to _push_ the ship in the pointing direction
*/

// Function to convert angle to velocity vector
function angleToVelocity(theta, speed) {
  return {
    x: speed * Math.cos(theta),
    y: speed * Math.sin(theta)
  };
}


class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        console.log('mounted')
        // this.screenwrap = new ScreenWrap
        this.mouse.position.vy = this.mouse.position.vx = 0
        this.a = new Point({ x: 200, y: 200, vx: 0, vy: 0})

        this.keyboard.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        this.keyboard.onKeyup(KC.UP, this.onUpKeyup.bind(this))
        this.keyboard.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        this.keyboard.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))
        this.keyboard.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))
        this.keyboard.onKeyup(KC.DOWN, this.onDownKeyup.bind(this))

        this.a.update({radius: 10})
        this.rotationSpeed = 0
        this.power = 0
        this.powerDown = false
    }

    addMotion(point, speed=1) {
        /* Because we're in a zero-gravity space, the velocity is simply _added_
        to the current XY, pushing the point in the direction of forced. */
        point.x += point.vx
        point.y += point.vy
        return
    }

    performPower(){
        if(this.powerDown === true) {
            /* Applied here, bcause a spaceship only applied force when the thottle is on.*/
            this.impart(.01)
            return
        }

        this.power = 0

        if(this.reverseDown === true) {
            this.impart(-.01)
        }
    }

    onUpKeydown(ev) {
        /* On keydown we add some to the throttle.
        As keydown first repeatedly, this will raise the power until
        keyup */
        this.powerDown = true
    }

    onUpKeyup(ev) {
        /* Reset the throttle */
        this.powerDown = false
    }

    impart(speed=1, direction=new Point(1,0)){
        /* Impart _speed_ for momentum relative to the direction the the point.

        For example - pointing _right_ and applying the _{1,0}_ direction (denoting forward)
        will push the point further right, applying _{0, 1}_ pushes the point _left_
        relative to its direction.

        Or to rephase, imagine a engine on the back of the point - pushing _forward_.
        */
        let a = this.a
        const r = impartOnRads(a.radians, direction)


================================================================================
END: relative-spaceship2d-motion.js
================================================================================



================================================================================
FILE: relative-spaceship2d-vector-engines-2.js
================================================================================

/*
title: Relative Spaceship2d Vector Engines 2
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    pointlist
    stroke
    ../point_src/events.js
    ../point_src/text/beta.js
    ../point_src/automouse.js
    ../point_src/relative.js
    ../point_src/keyboard.js
*/

// Function to convert angle to velocity vector
function angleToVelocity(theta, speed) {
  return {
    x: speed * Math.cos(theta),
    y: speed * Math.sin(theta)
  };
}



class MainStageKeys extends Stage {
    setupKeys(){

        this.keyboard.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        this.keyboard.onKeyup(KC.UP, this.onUpKeyup.bind(this))
        this.keyboard.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        this.keyboard.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))
        this.keyboard.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))
        this.keyboard.onKeyup(KC.DOWN, this.onDownKeyup.bind(this))
        // this.keyboard.onKeyPress(KC.SPACE, this.onSpaceKeyPress.bind(this))

    }

    onUpKeydown(ev) {
        /* On keydown we add some to the throttle.
        As keydown first repeatedly, this will raise the power until
        keyup */
        this.powerDown = true
    }

    onUpKeyup(ev) {
        /* Reset the throttle */
        this.powerDown = false
    }

    onDownKeydown(ev) {
        // this.speed -= .1
        this.reverseDown = true
        // this.speed -= 1
        // this.a.relative.backward(20)
        // this.a.relative.forward(-20)
    }

    onDownKeyup(ev) {
        this.reverseDown = false
    }

    onLeftKeydown(ev) {
        /* Rotate the point as if spinning on the spot.
        This rotation Speed is applied constantly in `this.updateSimpleShip`
        */
        if(ev.shiftKey || ev.ctrlKey) {
            /* Perform a _crab_ left */
            this.impart(.02, new Point(0, -1))
            return
        }

        this.rotationSpeed -= 1
    }

    onRightKeydown(ev) {
        /* Rotate the point as if spinning on the spot.
        This rotation Speed is applied constantly in `this.updateSimpleShip`
        */
        if(ev.shiftKey || ev.ctrlKey) {
            /* Perform a _crab_ right */
            this.impart(.02, new Point(0, 1))
            return
        }

        this.rotationSpeed += 1
    }

    onSpaceKeyPress(ev){}

}



================================================================================
END: relative-spaceship2d-vector-engines-2.js
================================================================================



================================================================================
FILE: relative-spaceship2d-vector-engines.js
================================================================================

/*
title: Relative Spaceship2d Vector Engines
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    pointlist
    stroke
    ../point_src/events.js
    ../point_src/text/beta.js
    ../point_src/automouse.js
    ../point_src/relative.js
    ../point_src/keyboard.js
*/

// Function to convert angle to velocity vector
function angleToVelocity(theta, speed) {
  return {
    x: speed * Math.cos(theta),
    y: speed * Math.sin(theta)
  };
}



class MainStageKeys extends Stage {
    setupKeys(){

        this.keyboard.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        this.keyboard.onKeyup(KC.UP, this.onUpKeyup.bind(this))
        this.keyboard.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        this.keyboard.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))
        this.keyboard.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))
        this.keyboard.onKeyup(KC.DOWN, this.onDownKeyup.bind(this))
        // this.keyboard.onKeyPress(KC.SPACE, this.onSpaceKeyPress.bind(this))

    }

    onUpKeydown(ev) {
        /* On keydown we add some to the throttle.
        As keydown first repeatedly, this will raise the power until
        keyup */
        this.powerDown = true
    }

    onUpKeyup(ev) {
        /* Reset the throttle */
        this.powerDown = false
    }

    onDownKeydown(ev) {
        // this.speed -= .1
        this.reverseDown = true
        // this.speed -= 1
        // this.a.relative.backward(20)
        // this.a.relative.forward(-20)
    }

    onDownKeyup(ev) {
        this.reverseDown = false
    }

    onLeftKeydown(ev) {
        /* Rotate the point as if spinning on the spot.
        This rotation Speed is applied constantly in `this.updateSimpleShip`
        */
        if(ev.shiftKey || ev.ctrlKey) {
            /* Perform a _crab_ left */
            this.impart(.02, new Point(0, -1))
            return
        }

        this.rotationSpeed -= 1
    }

    onRightKeydown(ev) {
        /* Rotate the point as if spinning on the spot.
        This rotation Speed is applied constantly in `this.updateSimpleShip`
        */
        if(ev.shiftKey || ev.ctrlKey) {
            /* Perform a _crab_ right */
            this.impart(.02, new Point(0, 1))
            return
        }

        this.rotationSpeed += 1
    }

    onSpaceKeyPress(ev){}

}




================================================================================
END: relative-spaceship2d-vector-engines.js
================================================================================



================================================================================
FILE: rope-and-text.js
================================================================================

/*
title: Pinnable Rope
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
---

A very pinnable verlet constraint chain for a rope-like catenary solution.

*/

// const distance = 5;
const gravity2D = {x:0, y:1};
const gravity = 0.35;
const friction = 0.9;

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })

    }

    /*  GPT 4.5 absolutely knocked it out the park.*/
    mounted() {
        this.numPoints = 10;
        this.segmentLength = 20;
        this.gravity = .31;
        this.gravity2D = gravity2D
        this.points = Array.from({ length: this.numPoints }, () => ({
            x: this.mouse.point.x,
            y: this.mouse.point.y,
            oldX: this.mouse.point.x,
            oldY: this.mouse.point.y,
        }));
        // this.points[9].invMass = .01
        this.points = new PointList(...this.points).cast()
        this.endPin = new Point(100, 200)
        this.midPin =  new Point(250, 200)
        this.points.last().invMass = 2
        this.midPin.color = 'red'
        this.dragging.add(this.midPin, this.endPin)

    }

    applyPhysics(points, gravity) {
        points.forEach((p, index) => {
            if (index === 0) {
                // first point follows mouse
                p.x = this.mouse.point.x;
                p.y = this.mouse.point.y;
            } else {
                const vx = (p.x - p.oldX) * 0.98;
                const vy = (p.y - p.oldY) * 0.98;

                p.oldX = p.x;
                p.oldY = p.y;

                p.x += vx;
                p.y += vy + gravity;
            }
        });
    }

    applyPhysics2(points, gravity2D, pinnedIndices){
        points.forEach((p, index) => {
            if (!pinnedIndices.includes(index) && (p.invMass ?? 1) !== 0) {
                p.x += gravity2D.x * (p.invMass ?? 1) * this.gravity;
                p.y += gravity2D.y * (p.invMass ?? 1) * this.gravity;
            }
        });
    }

    solveConstraints1(points, segmentLength, iterations = 5) {
        for (let j = 0; j < iterations; j++) {
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];

                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const difference = segmentLength - distance;
                const percent = difference / distance / 2;

                const offsetX = dx * percent;
                const offsetY = dy * percent;


================================================================================
END: rope-and-text.js
================================================================================



================================================================================
FILE: rotate-selection.js
================================================================================

/*
title: Draw Box
files:
    head
    point
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    stage
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    ../point_src/curve-extras.js
    dragging
    stroke
    ../point_src/random.js
    ../point_src/functions/clamp.js
    ../point_src/functions/within.js
    ../point_src/automouse.js
    ../point_src/windings.js
    ../point_src/recttools.js
---

Create a bounding box by click-dragging a selection.
*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){

        /* The (soon to be) generated lines */
        this.lines = []

        /* A flag for later */
        this.drawing = false

        /* A bunch of random points.*/
        this.points = PointList.generate.random(100,
                [800, 600],  // size
                {x: 100, y: 100} // top left
            )

        /* Box stroke. */
        this.stroke = new Stroke({
            color: '#5555FF'
            , width: 1
            , dash: [1]
        })

        /* populated when drawing */
        this.selected = new Set
        this.mouse.point.radius = 20
    }

    onClick(ev) {}

    onDblclick(ev) {}

    onMousedown(ev) {
        /* On mouse down, we flag the drawing as active and store the down Point */
        if(this.dragging.getPoint()?.uuid == 'handle'){
            // Dragging box mode.
            return
        }

        this.drawing = true
        this.downPoint = Point.from(ev)
        // this.selectItems()
    }

    onMouseup(ev) {
        /* On mouse up, flag the drawing=false, and store the up point. */
        this.drawing = false
        this.upPoint = Point.from(ev)
        // this.lines = []
    }

    onMousemove(ev) {
        /* On every move, creata a draw box from the down point
        to the mouse point, then test for selected items.*/
        if(!this.drawing) {
            return
        }

        /* render the concurrent box from downPoint to mousePoint*/
        let dp = this.downPoint
        let mp = this.mouse.point
        this.lines = twoPointBox(dp, mp)
        this.selectItems(dp, mp)
    }

    selectItems(a,b){

        let rect = twoPointsAsRectOrdered(a,b)
        let keep = new Set;

        let handList = new PointList(...rect)

        /* For every _point_ in the list, test to see if


================================================================================
END: rotate-selection.js
================================================================================



================================================================================
FILE: rotation-field.js
================================================================================

/*
title: Example
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    mouse
    dragging
    stroke
    ../point_src/velocity.js
    ../point_src/random.js
---

*/


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        let rowCount = 44
        this.ps = PointList.generate.grid(2000, rowCount, 10)
        this.gt = this.ps.generate.getGridTool(rowCount)
        this.ps.each.radius = 10
        // this.ps.each.rotation = ()=> random.int(10)
        console.log('mounted')
        this._i = 0
        this.ps[1366].rotation = 122
    }

    onMousedown(ev) {
        let p = this.dragging.getPoint()
        // p && this.pushVelocities(p)
        this.ps.each.rotation = (p)=>p.rotation += random.int(-360)
    }

    step() {
        /*
            The rotation of a neighbour is applies to a current..
        */
        let gt = this.gt
        let ps = this.ps
        let pi = Math.PI

        ps.forEach(function(p, i){
            if(i==1366) {
                return
            }
            let siblings = gt.getSiblings(i, 1000, 10)
            let r = siblings.map(j=>ps[j]?.radians || 0)
            let resultantTheta = combineAngles(r);

            let currentAngle = p.radians
            let targetAngle = resultantTheta + random.float(-.05, .05)

            p.radians = relativeTurnAdd(targetAngle, currentAngle, .1)
        })


    }

    draw(ctx){
        this._i += 1
        this.clear(ctx);
        /*(this._i % 5 == 0) &&*/ this.step()
        // this.ps.pen.indicators(ctx, undefined, 'purple')

        // let subVal = this.subVal
        this.ps.forEach(function(p, i){
            p.pen.line(ctx, undefined, i==1366?'yellow':'red')
        //     // p.velocity.mutableSub({x:subVal, y:subVal})
        //     p.velocity.mutableMul({x:subVal, y:subVal})
        })
    }
}


const relativeTurnAdd = function(targetAngle=1, currentAngle=0, rotationSpeed = 0.1){
    //  find the shortest angular difference
    let diff = targetAngle - currentAngle;
    let PI = Math.PI
    //    b) ensure diff is in [-, ] so we rotate the shortest way around
    diff = (diff + PI) % (2 * PI) - PI;
    // 3. Move only a fraction, say 1% (0.01) or 5% (0.05) per frame
    return currentAngle + (diff * rotationSpeed);
}


function combineAngles(angles) {
    // Sum of all x,y unit vectors
    let sumX = 0;
    let sumY = 0;



================================================================================
END: rotation-field.js
================================================================================



================================================================================
FILE: screen-lock.js
================================================================================

/*
title: Screen Lock
*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        origin = {x:200, y:200, radius: 20}
        this.point = new Point(origin)
        this.point.origin = origin

        let newRel = this.getScreenXY(origin)
        this.icon = this.point.copy()
        this.icon.copy(newRel)

        this.events.wake()
        this.dragging.add(this.point)//, this.icon)
        this.dragging.onDragEnd = this.onDragEnd.bind(this)
        this.tick =0
    }

    getScreenXY(origin) {
        let canvas = this.canvas
        return {
            x:  origin.x - (window.screenLeft + canvas.offsetLeft + canvas.clientLeft)
            , y: origin.y -  (window.screenTop + canvas.offsetTop + canvas.clientTop)
        }
    }

    onDragEnd(ev, point) {
        let canvas = this.canvas
        console.log(point)
        point.origin = this.getScreenXY({x: point.x, y:point.y})
    }

    async onMousedown(ev) {
        /* assign lock.*/

    }

    async onMousemove(ev) {
        // this.point.copy(this.point.add({x:ev.movementX, y:ev.movementY}))
        // console.log(this.getScreenXY(this.point))
    }

    async onMouseup(ev) {
    }

    draw(ctx){
        this.clear(ctx)
        this.tick += 1

        if(this.tick % 1 == 0) {
            // console.log(this.getScreenXY(this.point))
            let newRel = this.getScreenXY(this.point.origin)
            this.icon.copy(newRel)//.update(newRel)
        }
        this.point.pen.circle(ctx, undefined, '#880000')
        this.icon.pen.fill(ctx, '#880000')
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: screen-lock.js
================================================================================



================================================================================
FILE: screenshot-example.js
================================================================================

/*
title: Screenshot
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/screenshot.js
    ../point_src/image-edge-detection.js
    ../point_src/offscreen.js
---

Download a screenshot of the stage using `stage.screenshot` methods.

    this.screenshot.downloadImage("my-filename.jpg")

 */

class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.pointA = new Point(200, 300, 10, 20)
        this.pointB = new Point(230, 330, 10, 20)
        let _this = this

        addButton('download', {
            label: 'Download Image'
            , onclick(ev){
                _this.screenshot.downloadImage("my-filename.jpg")
            }
        })
        addButton('download-cropped', {
            label: 'Download Cropped Image'
            , onclick(ev){
                _this.screenshot.downloadCroppedImage("my-filename.jpg", true)
            }
        })
    }

    manualExample(){
        _this.screenshot.toBlobURL(function(url){
            const anchor = document.createElement('a');
            anchor.download = 'my-filename.jpg'; // optional, but you can give the file a name
            anchor.href = url // URL.createObjectURL(blob);
            anchor.click(); //  magic!
            // URL.revokeObjectURL(anchor.href); // remove it from memory and save on memory! 
            setTimeout(()=> URL.revokeObjectURL(anchor.href), 1000)
        })

        // // cropped image
        // const croppedUrl = await canvas.asObject("image/png", 0.9, {
        //     x: 50,
        //     y: 50,
        //     width: 200,
        //     height: 200
        // });

    }

    draw(ctx){
        this.clear(ctx)
        this.pointA.pen.indicator(ctx, { color: 'red'})
    }

}


;stage = MainStage.go()

================================================================================
END: screenshot-example.js
================================================================================



================================================================================
FILE: shuffled-grid.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    pointlist
    ../point_src/events.js
    mouse
    stage
    dragging
    stroke
    ../point_src/random.js
    ../point_src/rectangle.js
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/

addButton('Plot', {
    onclick(){
        stage.plot()
    }
})

addButton('shuffle', {
    onclick(){
        stage.shuffle()
    }
})

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.plot()
    }

    plot(){
        this.points = PointList.generate.grid(48, 8, 100)
        this.points.each.radius = ()=> random.int(5,15)
        // random.shuffle(this.points, 2)
        this.dragging.set(...this.points)
    }

    shuffle(){
        random.shuffle(this.points, 2)
    }

    draw(ctx){
        this.clear(ctx)

        this.points.pen.fill(ctx, {color:'purple'})

    }
}

// Polypoint.head.deferredProp('PointList', )

stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: shuffled-grid.js
================================================================================



================================================================================
FILE: simple-chain-gpt-example.js
================================================================================

/*
title: Image Data Reshading
categories: imagedata
    raw
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
---

*/

// const distance = 5;
const gravity = 0.35;
const friction = 0.9;

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })

    }

    updatePoints(points, target) {
        const distance = 20;
        points.forEach((point, index) => {
            const dx = target.x - point.x;
            const dy = target.y - point.y;
            const angle = Math.atan2(dy, dx);

            point.x = target.x - Math.cos(angle) * distance;
            point.y = target.y - Math.sin(angle) * distance;

            target = point;
        });
    }

    draw(ctx){
        this.clear(ctx)
        this.updatePoints2(this.points, this.mouse.point)
        // this.updatePoints(this.points, this.mouse.point)
        this.points.pen.indicator(ctx)
    }

    /*
        GPT 4.5

        Hi GPT. I am working on my polypoint library.
        Can you please show me rope or chain like stringy pully thing,
        such that I have a mouse point and then a range of points of which
        follow the mouse - but act like a rope or long chain,
        affected by physics.

        Can you show me a function to do that?
    */

    updatePoints2(points, mouse) {
        /* GPT - Poor */
        points[0].x = mouse.x;
        points[0].y = mouse.y;
        const distance = 5;

        for (let i = 1; i < points.length; i++) {
            const point = points[i];
            point.vy += gravity;

            point.x += point.vx;
            point.y += point.vy;

            const prev = points[i - 1];
            let dx = point.x - prev.x;
            let dy = point.y - prev.y;
            let dist = Math.sqrt(dx * dx + dy * dy);
            let difference = distance - dist;
            let percent = difference / dist / 2;

            let offsetX = dx * percent;
            let offsetY = dy * percent;

            point.x += offsetX;
            point.y += offsetY;

            prev.x -= offsetX;
            prev.y -= offsetY;

            point.vx *= friction;
            point.vy *= friction;
        }
    }
    /*
        This doesn't work very well.


================================================================================
END: simple-chain-gpt-example.js
================================================================================



================================================================================
FILE: simple-chain.js
================================================================================

/*
title: Simple Chain
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
---

This example acts very similar to the leashing method but with more focused steps (less code.)

*/
class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })

    }

    updatePoints(points, target) {
        const distance = 20;
        points.forEach((point, index) => {
            const dx = target.x - point.x;
            const dy = target.y - point.y;
            const angle = Math.atan2(dy, dx);

            point.x = target.x - Math.cos(angle) * distance;
            point.y = target.y - Math.sin(angle) * distance;

            target = point;
        });
    }

    draw(ctx){
        this.clear(ctx)
        this.updatePoints(this.points, this.mouse.point)
        this.points.pen.indicator(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: simple-chain.js
================================================================================



================================================================================
FILE: simple-rope.js
================================================================================

/*
title: Simple Rope
categories: chain
    rope
    constraints
files:
    head
    pointlist
    point
    stage
    stroke
    mouse
    dragging
    ../point_src/random.js
---

A very simple verlet constraint chain for a rope-like catenary solution
*/

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.points = PointList.generate.random(10, [100, 200], [0,0, 5, 0])
        this.points.forEach((p)=>{
            p.update({vx: 0, vy:0 })
        })

    }

    mounted() {
        this.numPoints = 30;
        this.segmentLength = 10;
        this.gravity = .001;

        this.points = Array.from({ length: this.numPoints }, () => ({
            x: this.mouse.point.x,
            y: this.mouse.point.y,
            oldX: this.mouse.point.x,
            oldY: this.mouse.point.y,
        }));
        this.points = new PointList(...this.points).cast()
        this.endPin = new Point(100, 200)
        this.dragging.add(this.endPin)

    }

    applyPhysics(points, gravity) {
        points.forEach((p, index) => {
            if (index === 0) {
                // first point follows mouse
                p.x = this.mouse.point.x;
                p.y = this.mouse.point.y;
            } else {
                const vx = (p.x - p.oldX) * 0.98;
                const vy = (p.y - p.oldY) * 0.98;

                p.oldX = p.x;
                p.oldY = p.y;

                p.x += vx;
                p.y += vy + gravity;
            }
        });
    }

    solveConstraints1(points, segmentLength, iterations = 5) {
        for (let j = 0; j < iterations; j++) {
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];

                let dx = p2.x - p1.x;
                let dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const difference = segmentLength - distance;
                const percent = difference / distance / 2;

                const offsetX = dx * percent;
                const offsetY = dy * percent;

                if (i !== 0) {
                    p1.x -= offsetX;
                    p1.y -= offsetY;
                }
                p2.x += offsetX;
                p2.y += offsetY;
            }
        }
    }

    draw(ctx) {
        this.clear(ctx);
        this.applyPhysics(this.points, this.gravity);
        this.solveConstraints1(this.points, this.segmentLength);
        // this.points.pen.indicator(ctx);
        this.points.pen.quadCurve(ctx);
    }

}


================================================================================
END: simple-rope.js
================================================================================



================================================================================
FILE: sin-wave-plot.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    pointlist
    stage
    stroke
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/
class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        // this.point = new Point(30, 40, 100)
        this.points = PointList.generate.list(100, 5, 100)
        this.tick = 0

        /* stage.phase = Math.PI2  == 0 */
        this.phase = 1
        this.speed = .02
        this.size = 90
        this.min = 0

        this.phase = Math.PI /109
        this.speed = .01
    }

    draw(ctx){
        this.clear(ctx)
        this.tick += 1
        // this.point.pen.line(ctx, undefined, 'red')
        this.points.each.radius = (p, i)=> (Math.cos((i * this.phase)+ (this.tick * this.speed) ) * this.size) + this.min

        this.points.forEach((p)=>{
            p.pen.line(ctx, undefined, 'red')
        })
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: sin-wave-plot.js
================================================================================



================================================================================
FILE: sinewave.js
================================================================================

/*
title: Sinewave
categories: curve
files:
    head
    ../point_src/point-content.js
    pointlist
    point
    mouse
    stage
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js

 */

let time = 0
const frequency = 10; // Hz
const amplitude = 100;
const speed = 0 // time scaling
const offset = {x: 100, y:0}
const width = 600
const height = 500
// const points = [];

class MainStage extends Stage {
    canvas='playspace'

    // In your stage's draw method
    draw(ctx) {
        this.clear(ctx);

        drawSineWave(ctx, width, height);
        drawSineWaveLimited(ctx, 50, width, height);
        // drawSineWaveTips(ctx, width, height, time);
        let rps = drawSineWaveTips(ctx, width, height, time);

        let ps = PointList.from(rps).cast()
        this.ps = ps
        ps.offset(offset)
        ps.pen.line(ctx)

        // ps.pen.quadCurve(ctx)

        time += 1 / 600;
    }
}


function drawSineWave(ctx, width, height) {
    let points = plotSineWave(width, height)
    generalDrawPoints(ctx, points, offset)
}

function drawSineWaveLimited(ctx, numPoints, width, height) {
    let points = plotSineWaveLimited(numPoints, width, height)
    generalDrawPoints(ctx, points, offset, '#FF6699')
}


function drawSineWaveTips(ctx, width, height, time) {
    let points = plotSineWaveTips(width, height, time)
    // let points = plotSineWaveLimited(10, width, height)
    generalDrawPoints(ctx, points, offset, '#AA66DD', drawTips)
    return points
}

function generalDrawPoints(ctx, points, offset, color='#66AAFF', func=drawPoints){
    ctx.beginPath();
    func(ctx, points, offset)
    ctx.strokeStyle = color;
    ctx.stroke();
}


const drawPoints = function(ctx, points, o={x:0, y:0}) {
    for (let i = 0; i < points.length; i++) {
        const p = points[i];
        if (i === 0) ctx.moveTo(p.x + o.x, p.y + o.y);
        else ctx.lineTo(p.x + o.x, p.y + o.y);
    }
}

function drawTips(ctx, points, o={x:0, y:0}) {
    ctx.fillStyle = 'yellow';
    for (let p of points) {
        ctx.beginPath();
        ctx.arc(p.x + o.x, p.y + o.y, 3, 0, Math.PI * 2);
        ctx.fill();
    }
}


// function plotSineWaveTips(width, height, time = 0) {
//     const centerY = height * 0.5;
//     const numTips = frequency * 2; // 2 tips (peak + trough) per full wave
//     let points = [];

//     for (let i = 0; i < numTips; i++) {
//         const t = time + i / (2 * frequency); // step by 1/(2f) to hit peaks/troughs


================================================================================
END: sinewave.js
================================================================================



================================================================================
FILE: single-chord-example.js
================================================================================

/*
title: Circle Segment
category: chords
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    pointlist
    point
    stage
    mouse
    dragging
    stroke
    ../point_src/random.js
    ../point_src/chords.js
---

A _segment_, is a non-equidistant chord. !here the points are _anywhere_ around the edge.

In this example the single point projects a chord within the area point, through
the its own direction.
*/

class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.areaPoint = new Point({x: 250, y: 150 , radius: 100})
        this.iPoint = new Point({x: 250, y: 150 , radius: 10, rotation: 33})

        this.dragging.add(this.areaPoint, this.iPoint)
    }

    // onMousedown(ev) {
    //     this.iPoint.rotation = random.int(180)
    // }

    draw(ctx){
        this.clear(ctx)

        let p = this.areaPoint
        let chord = this.iPoint

        chord.pen.indicator(ctx)

        let r = chordEndpoints2(p, chord)

        p.pen.circle(ctx, undefined, 'purple')

        if(r) {
            new Point(r[0]).pen.line(ctx, r[1], 'green')

            r.forEach(d=>{
                new Point(d).pen.fill(ctx, 'purple')
            });
        }
    }
}


stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: single-chord-example.js
================================================================================



================================================================================
FILE: snapshot-upload.js
================================================================================

/*
title: Snapshot Upload
*/
    /*
title: Upload Snapshots
categories: gif
files:
    head
    pointlist
    point
    stage
    mouse
    stroke
    ../point_src/random.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
    ../theatre/utils/snapshots.js
---

Save many images on the server to generate an animated gif using the backend.
*/

addButton('Start Recording', {
    onclick() {
        stage.startRecord()
    }
})

addButton('Stop Recording', {
    onclick() {
        stage.stopRecord()
    }
})


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        let count = 50
        this.a = PointList.generate.random(count, [200,350, 20, 200], [60, 150, 1, 1])
        this.b = PointList.generate.radius({count, offset: {radius:3}}, 140, new Point(300, 300))
        this.c = PointList.generate.random(count)
        this.isRecording = false
    }

    onMousedown(e) {
        console.log('mousedown')
        this.update()
        this.draw(this.ctx)
        sendImage(this.canvas)
    }

    startRecord() {
        this.isRecording = true
        this.stepRecord()
    }

    stopRecord() {
        this.isRecording = false
    }

    stepRecord() {
        if(this.isRecording) {
            this.update()
            this.draw(this.ctx)
            sendImage(this.canvas).then(this.stepRecord.bind(this))
        }
    }


    draw(ctx) {
        this.clear(ctx, '#010101')

        this.a.pen.indicator(ctx, 'green')
        this.b.pen.indicator(ctx, {color:'#333'})

        this.c.lerper.through(this.a, this.b, {seconds: 5,
                                        easing: linearInOut, fps: 30})
        this.c.pen.indicator(ctx, {color:'purple'})
    }
}


;stage = MainStage.go({
    loop: false
});

================================================================================
END: snapshot-upload.js
================================================================================



================================================================================
FILE: snotite-ai-brownian-walker.js
================================================================================

/*
title: Brownian Walker
categories: brownian
    random
files:
    ../theatre/brain.js
    head
    point
    pointlist
    stage
    mouse
    dragging
    stroke
    ../point_src/random.js
    ../point_src/functions/range.js
    ../point_src/relative.js
    ../point_src/constrain-distance.js
    ../point_src/screenwrap.js
---

A tiny walker to move towards a browian point.
*/


// const trainingData = [
//      [0.93,0.93,.34,.34,0.33,0.63,.53,.53,.01],
//      [0.93,.34,0.63,0.63,.53,.01],
//      [.01,.01,.01],
//      [.34,.34,0.93,0.93,0.63,0.63,.53,.53,.34,.77]
// ];

// const lstm = new brain.recurrent.LSTM();
// const result = lstm.train(trainingData, {
//   iterations: 15,
//   log: details => console.log(details),
//   errorThresh: 0.011
// });

// const run1 = lstm.run(0.01);
// const run2 = lstm.run(.9);
// const run3 = lstm.run(.53);
// const run4 = lstm.run(.7);

// console.log('run 1:', run1);
// console.log('run 2:', run2);
// console.log('run 3:', run3);
// console.log('run 4:', run4);


let fleeSettings = {
    tailLength: 3,
    turnSpeed: .18,
    maxTouchDistance: 6,
    viewSpaceOffset: 10,
    viewSpaceMultiplerSize: 3,
    forwardSpeed: 1.7,
    leashDistanceMultiplier: 2,
    radius: 1.2,
    color: 'green',
}


const sliderValue = function(value, min, max, step) {
    let d = {}
    if(step != undefined) { d.step = step }
    if(value != undefined) { d.value = value }
    if(min != undefined) { d.min = min }
    if(max != undefined) { d.max = max }
    return d;
}

const sliders = {
    tailLength:              sliderValue(   3,   2, 40)
    , turnSpeed:               sliderValue( .18,  .1,  1,  .05)
    , maxTouchDistance:        sliderValue(   6,   6, 20)
    , viewSpaceOffset:         sliderValue(  10,  10, 30)
    , viewSpaceMultiplerSize:  sliderValue(   3,   2, 20)
    , forwardSpeed:            sliderValue( 1.7,  .1,  3,  .10)
    , leashDistanceMultiplier: sliderValue(   2, 1.5, 20,   .2)
    , radius:                  { step: .10, value: 1.2, min: 1, max: 20 }
};

addSliderControlSet(sliders);

addButton('Generate', {
    onclick: ()=> {
        let d = {}
        for(let k in sliders) {
            d[k] = parseFloat(appShared.miniApp.controls[k].value)
        };

        stage.newWalker(Object.assign(d, { x: 300, y: 300}))
    }
})


class Walker extends Point {

    init(d) {
        this.updateSpeed = 20


================================================================================
END: snotite-ai-brownian-walker.js
================================================================================



================================================================================
FILE: spaceship-vectors-controller.js
================================================================================

/*
title: Spaceship Vectors Controller
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    point
    dragging
    stroke
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/constrain-distance.js
    ../point_src/screenwrap.js

Coupled Vector Engines - Rigid Body Physics Simulation

This demonstrates a proper 2D rigid body physics system where multiple engines
are coupled together to form a single ship. Key physics concepts:

1. CENTER OF MASS (COM): The true pivot point calculated from all masses
2. MOMENT OF INERTIA: Resistance to rotation based on mass distribution
3. TORQUE: Rotational force = distance  force (cross product)
4. GRAVITY-GRADIENT TORQUE: Instability from mass distribution in gravity field

Physics Improvements (v2):
- Fixed: Ship now rotates around actual COM, not reference point
- Fixed: Gravity strength consistent between linear and rotational
- Fixed: Multiple COM calculations optimized to single calculation per frame
- Added: getTotalMass() helper to avoid repeated calculations
- Cleaned: Removed unused helper functions and variables

Physics Improvements (v3):
- Refactored: Extracted calculateMomentOfInertia() as standalone function
- Documented: Complete API reference in docs/moment-of-inertia-api.md
- Educational: Added beginner's guide in docs/moment-of-inertia-explained.md
- Simplified: Unified body list API - all bodies treated equally, distinguished by isLocal flag
- Extracted: calculateTotalMass(), calculateCenterOfMass(), applyEngineForces(), applyGravityGradientTorque(), applyGamepadControls(), and updateRigidBodyPhysics() as reusable standalone functions
*/


// ============================================================================
// MOMENT OF INERTIA CALCULATION
// ============================================================================

/**
 * Calculate the moment of inertia for a rigid body system around its center of mass.
 * 
 * WHAT IS MOMENT OF INERTIA?
 * Think of it as "rotational mass" - it describes how hard it is to spin an object.
 * Just like mass resists being pushed (linear motion), moment of inertia resists 
 * being spun (rotational motion).
 * 
 * KEY INSIGHT:
 * - A heavy object far from the spin point is VERY hard to spin (high I)
 * - A light object close to the spin point is EASY to spin (low I)
 * 
 * FORMULA: I = (mass  distance)
 * For each piece of mass, multiply its mass by the SQUARE of its distance from 
 * the center of rotation. Then add them all up.
 * 
 * WHY DISTANCE SQUARED?
 * Moving mass twice as far away makes it FOUR times harder to spin (2 = 4).
 * This is why figure skaters spin faster when they pull their arms in!
 * 
 * PRACTICAL EXAMPLES:
 * 1. Ice skater with arms out: HIGH moment of inertia  spins SLOWLY
 *    Ice skater with arms in: LOW moment of inertia  spins FAST
 * 
 * 2. Bicycle wheel: mass at the rim  HIGH I  stable, hard to tilt
 *    Solid disc of same mass: mass at center  LOW I  easy to tilt
 * 
 * 3. A hammer: easy to spin around handle (mass is far), hard to spin around 
 *    the middle (mass evenly distributed)
 * 
 * IN THIS SIMULATION:
 * - Ship with cargo far from center  HIGH I  sluggish rotation
 * - Ship with cargo at center  LOW I  responsive rotation
 * - Engines firing off-center create torque based on this I value
 * 
 * SIMPLIFIED API:
 * All bodies (ship, engines, cargo, fuel tanks) are treated uniformly as mass points.
 * The difference between "engines" and "cargo" is only that engines apply force - 
 * both contribute equally to moment of inertia based on their mass and position.
 * 
 * @param {Object} centerOfMass - The pivot point {x, y}
 * @param {Object} mainBody - The main rigid body with {x, y, mass, radians}
 * @param {Array} bodies - Array of ALL mass-bearing objects:
 *                         - World-space bodies: {x, y, mass} (engines, asteroids, etc.)
 *                         - Local-space bodies: {x, y, mass, isLocal: true} (cargo, fuel)
 *                         Local-space bodies will be rotated by mainBody.radians
 * @returns {number} The moment of inertia (I) in mass  distance units


================================================================================
END: spaceship-vectors-controller.js
================================================================================



================================================================================
FILE: spaceship-vectors-keyboard.js
================================================================================

/*
title: Spaceship Vectors Keyboard
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    point
    dragging
    stroke
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/constrain-distance.js
    ../point_src/screenwrap.js

The arrow keys pushes the ship in a frictionless 2D space.

Keydown performs an `impartOnRads` to _push_ the ship in the pointing direction
*/

// Function to convert angle to velocity vector
function angleToVelocity(theta, speed) {
  return {
    x: speed * Math.cos(theta),
    y: speed * Math.sin(theta)
  };
}


class MainStage extends Stage {
    canvas = 'playspace'

    mounted() {
        console.log('mounted')
        // this.screenwrap = new ScreenWrap
        this.mouse.position.vy = this.mouse.position.vx = 0
        
        // Create the virtual "ship" body (center of mass)
        this.ship = new Point({ 
            x: 200, 
            y: 225,  // midpoint between a and b
            vx: 0, 
            vy: 0, 
            radians: -Math.PI/2,  // -90 degrees
            rotationSpeed: 0,
            mass: 10,
            radius: 5
        })
        
        // Create the engines with offsets from ship center
        this.a = new Point({ x: 200, y: 200, vx: 0, vy: 0, rotation: -90, radius: 10, mass: 1, force: 0})
        this.b = new Point({ x: 200, y: 250, vx: 0, vy: 0, rotation: -90, radius: 10, mass: 1, force: 0})
        this.c = new Point({ x: 225, y: 225, vx: 0, vy: 0, rotation: 0, radius: 10, mass: 1, force: 0})
        
        // Store initial offsets (in ship's local space)
        // radians is the LOCAL rotation offset (0 = forward, Math.PI/2 = right, etc.)
        this.engineOffsets = [
            { x: 0, y: -25, radians: .10 },           // engine 'a' - top, pointing forward
            { x: 0, y: 25, radians: -.10 },            // engine 'b' - bottom, pointing forward
            { x: 25, y: 0, radians: 0 }     // engine 'c' - right side, pointing right
        ]
        
        this.engines = [this.a, this.b, this.c]

        // Add additional mass points to shift center of mass
        // These are "virtual" mass points that don't render but affect physics
        // For a top-heavy VTOL: put heavy mass at the top
        this.massPoints = [
            { x: 80, y: 0, mass: 10 }  // Heavy payload at the top (15 mass units)
            // { x: 30, y: 0, mass: 8 },   // Additional mass slightly lower
            // , { x: 0, y: 40, mass: 20 }   // Light fuel tank at bottom (uncomment to test)
        ]

        this.asteroids = new PointList(
                [250, 200]
                , [200, 250]
                , [200, 350]
            ).cast()
        this.asteroids.update({vx: 0, vy: 0, mass: 1})

        this.keyboard.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        this.keyboard.onKeyup(KC.UP, this.onUpKeyup.bind(this))
        this.keyboard.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        this.keyboard.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))
        this.keyboard.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))
        this.keyboard.onKeyup(KC.DOWN, this.onDownKeyup.bind(this))

        this.rotationSpeed = 0
        this.power = 0
        this.powerDown = false

        this.dragging.add(...this.asteroids)


================================================================================
END: spaceship-vectors-keyboard.js
================================================================================



================================================================================
FILE: spaceship-vectors-radio-controls.js
================================================================================

/*
title: Spaceship Vectors Radio Controls
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    point
    dragging
    stroke
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/constrain-distance.js
    ../point_src/screenwrap.js
    ../theatre/objects/vectors/physics.js
    ../theatre/objects/vectors/controller.js
    ../theatre/objects/vectors/ship.js
---

Coupled Vector Engines - Rigid Body Physics Simulation
*/

class MainStage extends Stage {
    canvas = 'playspace'

    mounted() {
        console.log('mounted')
        // this.screenwrap = new ScreenWrap
        this.mouse.position.vy = this.mouse.position.vx = 0

        // Create the ship as a Ship instance
        this.ship = new Ship({
            x: 200,
            y: 225,  // midpoint between a and b
            vx: 0,
            vy: 0,
            radians: -Math.PI/2,  // -90 degrees (pointing up)
            rotationSpeed: 0,
            mass: 10,
            radius: 5
        })

        // Create engine points with RELATIVE positions (local space)
        // These will be transformed to world space by Ship.addEngine()
        this.a = new Point({ x: 50, y: 0, vx: 0, vy: 0, rotation: 0, radius: 10 })     // Top engine (25 units above ship center)
        this.b = new Point({ x: 0, y: -20, vx: 0, vy: 0, rotation: 0, radius: 10 })     // Left engine (25 units left of ship center)
        this.c = new Point({ x: 0, y: 20, vx: 0, vy: 0, rotation: 0, radius: 10 })     // Right engine (25 units right of ship center)

        // Add engines to ship - addEngine transforms from relative to world space
        this.ship
            .addEngine(this.a, 1)   // Top engine
            .addEngine(this.b, 1)   // Left engine
            .addEngine(this.c, 1)   // Right engine
            ;

        // Convenience references (for backward compatibility with existing code)
        this.engines = this.ship.engines
        this.engineOffsets = this.ship.engineOffsets

        // Add additional mass points to shift center of mass
        // These are "virtual" mass points that don't render but affect physics
        // For a top-heavy VTOL: put heavy mass at the top
        this.massPoints = [
            { x: 60, y: 0, mass: 20 },  // Heavy payload at the top (15 mass units)
            { x: 30, y: 0, mass: 8 },   // Additional mass slightly lower
            // , { x: 0, y: 40, mass: 20 }   // Light fuel tank at bottom (uncomment to test)
        ]

        this.asteroids = new PointList(
                [250, 200]
                , [200, 250]
                , [200, 350]
            ).cast()
        this.asteroids.update({vx: 0, vy: 0, mass: 1})

        this.power = 0
        this.powerDown = false
        this.triggerForce = 0.26
        this.powerSensitivity = 0.1  // Rotation sensitivity (0.0 to 1.0, lower = slower rotation)
        this.axisDeadzone = 0.01  // Controller axis deadzone (0.0 to 1.0, lower = more sensitive)
        this.engineRotationMode = 'spring-back'  // 'accumulate' or 'spring-back' - engine rotation behavior
        this.invertRotation = true  // Invert rightStickX rotation direction

        this.setupKeyboard()
        this.dragging.add(...this.asteroids)

        // Initialize gamepad controller
        // Change profile here: 'XBOX' or 'RADIOMASTER_TS16S'
        this.gamepad = new GamepadController('RADIOMASTER_TS16S')
        this.gamepad.deadzone = this.axisDeadzone  // Apply custom deadzone

    }


================================================================================
END: spaceship-vectors-radio-controls.js
================================================================================



================================================================================
FILE: spaceship-vectors-zero-gravity.js
================================================================================

/*
title: Spaceship Vectors Zero Gravity
categories: relative
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    point
    dragging
    stroke
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/constrain-distance.js
    ../point_src/screenwrap.js

The arrow keys pushes the ship in a frictionless 2D space.

Keydown performs an `impartOnRads` to _push_ the ship in the pointing direction
*/

// Function to convert angle to velocity vector
function angleToVelocity(theta, speed) {
  return {
    x: speed * Math.cos(theta),
    y: speed * Math.sin(theta)
  };
}


class MainStage extends Stage {
    canvas = 'playspace'

    mounted() {
        console.log('mounted')
        // this.screenwrap = new ScreenWrap
        this.mouse.position.vy = this.mouse.position.vx = 0

        // Create the virtual "ship" body (center of mass)
        this.ship = new Point({
            x: 200,
            y: 225,  // midpoint between a and b
            vx: 0,
            vy: 0,
            radians: -Math.PI/2,  // -90 degrees
            rotationSpeed: 0,
            mass: 10,
            radius: 5
        })

        // Create the engines with offsets from ship center
        this.a = new Point({ x: 200, y: 200, vx: 0, vy: 0, rotation: -90, radius: 10, mass: 1, force: 0})
        this.b = new Point({ x: 200, y: 250, vx: 0, vy: 0, rotation: -90, radius: 10, mass: 1, force: 0})
        this.c = new Point({ x: 225, y: 225, vx: 0, vy: 0, rotation: 0, radius: 10, mass: 1, force: 0})

        // Store initial offsets (in ship's local space)
        // radians is the LOCAL rotation offset (0 = forward, Math.PI/2 = right, etc.)
        this.engineOffsets = [
            { x: 0, y: -25, radians: .0 },           // engine 'a' - top, pointing forward
            { x: 0, y: 25, radians: 0 },            // engine 'b' - bottom, pointing forward
            { x: 25, y: 0, radians: 0 }     // engine 'c' - right side, pointing right
        ]

        this.engines = [this.a, this.b, this.c]

        this.asteroids = new PointList(
                [250, 200]
                , [200, 250]
                , [200, 350]
            ).cast()
        this.asteroids.update({vx: 0, vy: 0, mass: 1})

        this.keyboard.onKeydown(KC.UP, this.onUpKeydown.bind(this))
        this.keyboard.onKeyup(KC.UP, this.onUpKeyup.bind(this))
        this.keyboard.onKeydown(KC.LEFT, this.onLeftKeydown.bind(this))
        this.keyboard.onKeydown(KC.RIGHT, this.onRightKeydown.bind(this))
        this.keyboard.onKeydown(KC.DOWN, this.onDownKeydown.bind(this))
        this.keyboard.onKeyup(KC.DOWN, this.onDownKeyup.bind(this))

        this.rotationSpeed = 0
        this.power = 0
        this.powerDown = false

        this.dragging.add(...this.asteroids)
    }

    updateEnginePositions() {
        /* Update the visual positions of engines based on ship position and rotation */
        const ship = this.ship
        const cos = Math.cos(ship.radians)
        const sin = Math.sin(ship.radians)

        this.engines.forEach((engine, i) => {


================================================================================
END: spaceship-vectors-zero-gravity.js
================================================================================



================================================================================
FILE: spectrum-lines.js
================================================================================

/*
---
title: Spectrum Line
categories: curve
    raw
    noise
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js

---

*/



/*https://codepen.io/Thibka/pen/LWGOWR.js*/

// Ported from Stefan Gustavson's java implementation
// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
// Read Stefan's excellent paper for details on how this code works.
//
// Sean McCullough banksean@gmail.com

/**
 * You can pass in a random number generator object if you like.
 * It is assumed to have a random() method.
 */
var ClassicalNoise = function(r) { // Classic Perlin noise in 3D, for comparison
  if (r == undefined) r = Math;
  this.grad3 = [[1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
                                 [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
                                 [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]];
  this.p = [];
  for (var i=0; i<256; i++) {
    this.p[i] = Math.floor(r.random()*256);
  }
  // To remove the need for index wrapping, double the permutation table length
  this.perm = [];
  for(var i=0; i<512; i++) {
    this.perm[i]=this.p[i & 255];
  }
};

ClassicalNoise.prototype.dot = function(g, x, y, z) {
    return g[0]*x + g[1]*y + g[2]*z;
};

ClassicalNoise.prototype.mix = function(a, b, t) {
    return (1.0-t)*a + t*b;
};

ClassicalNoise.prototype.fade = function(t) {
    return t*t*t*(t*(t*6.0-15.0)+10.0);
};

  // Classic Perlin noise, 3D version
ClassicalNoise.prototype.noise = function(x, y, z) {
  // Find unit grid cell containing point
  var X = Math.floor(x);
  var Y = Math.floor(y);
  var Z = Math.floor(z);

  // Get relative xyz coordinates of point within that cell
  x = x - X;
  y = y - Y;
  z = z - Z;

  // Wrap the integer cells at 255 (smaller integer period can be introduced here)
  X = X & 255;
  Y = Y & 255;
  Z = Z & 255;

  // Calculate a set of eight hashed gradient indices
  var gi000 = this.perm[X+this.perm[Y+this.perm[Z]]] % 12;
  var gi001 = this.perm[X+this.perm[Y+this.perm[Z+1]]] % 12;
  var gi010 = this.perm[X+this.perm[Y+1+this.perm[Z]]] % 12;
  var gi011 = this.perm[X+this.perm[Y+1+this.perm[Z+1]]] % 12;
  var gi100 = this.perm[X+1+this.perm[Y+this.perm[Z]]] % 12;
  var gi101 = this.perm[X+1+this.perm[Y+this.perm[Z+1]]] % 12;
  var gi110 = this.perm[X+1+this.perm[Y+1+this.perm[Z]]] % 12;
  var gi111 = this.perm[X+1+this.perm[Y+1+this.perm[Z+1]]] % 12;

  // The gradients of each corner are now:
  // g000 = grad3[gi000];
  // g001 = grad3[gi001];
  // g010 = grad3[gi010];


================================================================================
END: spectrum-lines.js
================================================================================



================================================================================
FILE: speed-2.js
================================================================================

/*
title: Speed 2
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/text/beta.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/text/styler.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js

 */
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        this.textPos = new Point(100, 100, 20)
        // this.events.wake()
        // let e1 = this.e1 = new Emitter(200,200, 80)

        // let e1 = this.e1 = new RandomPointEmitter(400,400, 60)

        // // e1.radiusVariant = .1
        // e1.directionVariant = 100
        // e1.particleSpeed = .6
        // e1.lifetime = 600
        // e1.fromEdge = true
        // e1.tickModulo = 2
        // // e1.speed = 100
        // e1.birthrate = 1
        // e1.pointLimit = 1000
        // debugger;
        let e1 = this.e1 = new RandomPointEmitter()
        e1.update({
            x: 400
            , y: 400
            , radius: 60
            // , radiusVariant: .1
            , directionVariant: 100
            , particleSpeed: .6
            , lifetime: 200
            , fromEdge: true
            , tickModulo: 2
            // , speed: 100
            , birthrate: 1
            , pointLimit: 1000
        })

        e1.wake()

        // e1.direction = {x:-1, y:0} //inward.

        this.e1 = e1

        e1.wake()

        this.dragging.add(this.point, this.e1)
    }

    draw(ctx){
        this.clear(ctx)
        this.e1.step()

        let v = this.point.speed2D.absFloat()
        let vh = (v * .5)
        let speed = (1+v) * .1
        speed = clamp((speed * speed) * .5, .1, 10)

        this.e1.points.forEach(p => {
            if (p._vx == undefined) {
                p._vx = p.vx;
                p._vy = p.vy;
            }
            p.vx = p._vx * speed * 2;
            p.vy = p._vy * speed * 2;
        })

        this.point.pen.indicator(ctx, '#880000')
        this.point.rotation = 90-radiansToDegrees(this.point.speed2D.direction())
        this.e1.pen.fill(ctx, '#aaa')
        this.e1.points.pen.circle(ctx, undefined, '#aaa')

        this.e1.birthrate = v * speed
        this.e1.particleSpeed = (vh * .1)


================================================================================
END: speed-2.js
================================================================================



================================================================================
FILE: speed.js
================================================================================

/*
title: Speedy Eject Points
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/text/beta.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/text/styler.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
    ../point_src/screenwrap.js

*/
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        this.textPos = new Point(100, 100, 20)

        let e1 = this.e1 = new RandomPointEmitter()
        e1.update({
            x: 400
            , y: 400
            , radius: 60
            // , radiusVariant: .1
            , directionVariant: 100
            , particleSpeed: .6
            , lifetime: 600
            , fromEdge: true
            , tickModulo: 2
            // , speed: 100
            , birthrate: 1
            , pointLimit: 1000
        })

        // e1.direction = {x:-1, y:0} //inward.
        this.e1 = e1
        e1.wake()
        this.screenWrap.edgeMethod = 'performCull'
        this.dragging.add(this.point, this.e1)
    }

    draw(ctx){
        this.clear(ctx)
        this.e1.step()

        this.point.pen.indicator(ctx, '#880000')
        /* the primary emitter point */
        this.e1.pen.fill(ctx, '#aaa')
        /* The spawned points.*/
        // this.e1.points.pen.circle(ctx, undefined, '#aaa')
        this.e1.points.pen.lines(ctx,'#aaa')

        let v = this.point.speed2D.absFloat()
        let vh = (v * .5)
        this.e1.birthrate = 1 + v
        this.e1.particleSpeed = 1 + (vh * .2)
        this.e1.lifetime = this.e1.distanceTo(this.point) - vh

        ctx.fillStyle = 'white';
        ctx.font = `500 16px arial`;

        this.screenWrap.performMany(this.e1.points)
        this.textPos.text.fill(ctx, this.e1.points.length,)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: speed.js
================================================================================



================================================================================
FILE: spin-plotter-2.js
================================================================================

/*

title: Plotter
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
    stroke
    fps
    ../point_src/functions/signedNorm.js
    ../theatre/objects/vectorpoint.js
    ../theatre/objects/spinplotter.js
    ../point_src/screenwrap.js
    ../point_src/velocity.js
---

Plotting captures the XY RAD ROT of a point upon request, and stashes it in a
pointlist. This is useful for timestep captures such as spline walks.

*/

/*
title: Simple Starfield
categories: minimal
    starfield
files:
    head
    point
    pointlist
    stroke
    stage
    mouse
    dragging
    ../point_src/random.js
    ../point_src/screenwrap.js
    ../point_src/velocity.js
---

A simple starfield, with recycled points and general _direction_ and _speed_.

*/

class StarsStage extends Stage {
    canvas = 'playspace'
    mounted() {
        let pin = new Point(0, 0, 1, 0)
        let pin2 = new Point(0, 0, .1, 0)
        this.points = PointList.generate.random(50, [1200, 800], pin)
        this.pins = PointList.generate.random(20, [1200, 800], pin2)

        this.reactor = new VelocityReactor()
        this.reactor.points = this.points

        // the direction of travel, applied to each points velocity.
        let direction = new Point(-3, 0)

        // this.reactor.randomize()

        this.points.forEach(p=>{
            // circle plot area
            // p.xy = random.within(pin, 600)

            p.velocity.set(direction.multiply(p.radius * -.05))

            let light = 30 * (p.radius * .25)
            p.color = `hsl(0, 40%, ${light}%)`
            p.radius *= 3

            // turn to direction of travel
            faceVelocity(p)
        })
    }

    draw(ctx){
        this.clear(ctx)
        this.reactor.step()
        this.points.forEach(p=>this.screenWrap.perform(p))
        // this.pins.pen.fill(ctx, '#666')
        this.points.pen.lines(ctx)
        // this.points.pen.indicator(ctx)
        // this.points.pen.fill(ctx, 'green')
    }
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){

        let slideSpeed = [2,0];

        this.spinPlotter3 = new SpinPlotter({
            x: this.center.x
            , y: this.center.y
            , radius: 100


================================================================================
END: spin-plotter-2.js
================================================================================



================================================================================
FILE: spin-plotter.js
================================================================================

/*

title: Plotter
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
    stroke
    fps
    ../point_src/functions/signedNorm.js
    ../theatre/objects/vectorpoint.js
    ../theatre/objects/spinplotter.js
---

Plotting captures the XY RAD ROT of a point upon request, and stashes it in a
pointlist. This is useful for timestep captures such as spline walks.

*/



class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){

        this.vectorPoint = new VectorPoint(100, 100, 50)
        let slideSpeed = [1,1];
        this.spinPlotter = new SpinPlotter({
            x: 200
            , y: 250
            , radius: 90
            , maxPlotCount: 50
            , slideSpeed
            , spinSpeed: 0
            , plotModulo: 5
            , plotColor: '#AA4400'
        })

        this.spinPlotter2 = new SpinPlotter({
            x: 450
            , y: 250
            , radius: 90
            , maxPlotCount: 50
            , rotation: 90
            , slideSpeed
            , spinSpeed: 2
            , plotModulo: 4
            , plotColor: '#880000'
        })

        this.spinPlotter3 = new SpinPlotter({
            x: 700
            , y: 250
            , radius: 90
            , maxPlotCount: 50
            , slideSpeed
            , plotModulo: 5
            , spinSpeed: 4
            // , direction: 'cos'
            , plotColor: '#AAAA88'
        })

        // this.spinPlotter.xy = this.spinPlotter2.xy = this.spinPlotter3.xy

        this.spinPlotter4 = new SpinPlotter({
            x: 950
            , y: 250
            , radius: 90
            , maxPlotCount: 200
            , slideSpeed
            , spinSpeed: 0
            , plotModulo: 2
            , lineWidth: 3
            , plotColor: '#AACC88'
        })

        let plotters = this.plotters = [
                this.spinPlotter
                , this.spinPlotter2
                , this.spinPlotter3
                , this.spinPlotter4
            ]

        this.spinPlotter4.brush = new Point(10, 20)

        let vcp = this.vectorPoint.addNewPoint(this.vectorPoint.copy().add(5,10))
        this.vectorPoint.onTipDragMove = ()=>{
            // console.log('onTipDragMove')
            let slideSpeed = (new Point(this.vectorPoint.getComputed())).multiply(-.01).xy

            this.plotters.forEach(p=>{
                p.slideSpeed = slideSpeed
            })
        }
        // this.vectorPoint.addNewPoint()


================================================================================
END: spin-plotter.js
================================================================================



================================================================================
FILE: spiral-plotter.js
================================================================================

/*

title: Spiral Plots
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
    stroke
    fps
    ../point_src/functions/signedNorm.js
---

Plotting a spiral.

*/


class SpinPlotter extends Point {

    created() {
        this.plotList = new PointList()

        let o = {
            slideSpeed: [2]
            , spinSpeed: 2
            , maxPlotCount: 200
            , plotModulo: 20
            , plotColor: '#ccc'
            , lineWidth: 1
            , sliceCount: 2
            , direction: 'sin'
            , periodOffset: 0
        }

        for(let k in o) {
            if(this[k] === undefined) {
                this[k] = o[k]
            }
        }

        this._ticker = 0
    }

    getNormValue() {
        /* return -1 0 1 for centroid scale of the spin. */
        let brushTipSin = this.getBrush()
        /* Define the axis to normalise. Math.PI*.5 is `sin` or y,
        because it's 1/4 PI, with the 0 degree on the horizontal line. */
        let axis = Math.PI * .5
        if(this.direction == 'cos') {
            // Check the horizontal.
            axis = 0
        }

        const sLR = signedNorm(brushTipSin, this, this.radius, axis, this.periodOffset);
        return sLR
    }


    getBrush() {

        if(this.brush !== undefined) {
            return this.brush
        }

        let tip = this.project()

        return {
            'sin': ()=> new Point(this.x, tip.y)
            , 'cos': ()=> new Point(tip.x, this.y)
            , 'both': ()=> tip
        }[this.direction]()

        // let brushTipSin = new Point(this.x, tip.y)
        // let brushTipCos = new Point(tip.x, this.y)
        // return brushTipSin
    }

    checkSlice() {
        let plotList = this.plotList
        if(plotList.length > this.maxPlotCount) {
            plotList = plotList.slice(this.sliceCount)
        }
        return plotList
    }

    render(ctx) {
        this.rotation += this.spinSpeed
        this._ticker++;

        // let plotList = this.plotList;
        let brushTipSin = this.getBrush()
        let plotList = this.updatePlot(this.plotList, brushTipSin)
        this.drawPrimaryPoint(ctx)
        this.drawPlotList(ctx, plotList)
        this.drawBrush(ctx, brushTipSin)



================================================================================
END: spiral-plotter.js
================================================================================



================================================================================
FILE: splatout-stack.js
================================================================================

/*
---
title: Splatout
files:
    head
    point
    pointlist
    mouse
    stage
    stroke
    dragging
    ../point_src/random.js
    ../point_src/stage-clock.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
---

*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    mounted(){
        this.p = this.center.copy()
        this._lastP = undefined
        this.p.color = random.color()

        this.microValue = this.clock.frameStepValue(1) // seconds
        this.backgroundColor = undefined; //this.randomColor()
    }


    onMousedown(e){
        /*
            Grab Point
            Animate To size.
            Then the new background color,
        */
        this._lastP = this.p
        let p = Point.from(e).update({ radius: 1 })
        this.p = p
        p.color = random.color()
        let width = this.dimensions.width * 1.5
        let easing = easingFunctions.get('sine', 'in')
        let st = this;
        let v = this.v = new Value(this.p.radius, width, easing)
        v.doneHandler = ()=>{
            this.nextTick(this.switchOut.bind(this))
        }

        this.microStep = 0
    }

    switchOut() {
        console.log('doneHandler')
        let p = this.p
        this.v = undefined;
    }

    step(){
        if(this.v) {
            this.p.radius = this.v.get(this.microStep)
        }
        this.microStep += this.microValue
    }

    draw(ctx){
        this.clear(ctx)
        this.step()
        this._lastP && this._lastP.pen.fill(ctx)
        this.p.pen.fill(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: splatout-stack.js
================================================================================



================================================================================
FILE: splatout.js
================================================================================

/*
---
title: Splatout
files:
    head
    point
    pointlist
    mouse
    stage
    stroke
    dragging
    ../point_src/random.js
    ../point_src/stage-clock.js
    ../point_src/easing.js
    ../point_src/iter/lerp.js
---

*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    mounted(){
        this.p = this.center.copy()
        this.p.color = this.randomColor()

        this.microValue = this.clock.frameStepValue(1) // seconds
        this.backgroundColor = undefined; //this.randomColor()
    }


    onMousedown(e){
        /*
            Grab Point
            Animate To size.
            Then the new background color,
        */
        let p = Point.from(e).update({ radius: 5 })
        this.p = p
        p.color = this.randomColor()
        let width = this.dimensions.width * 1.5
        let easing = easingFunctions.get('sine', 'in')
        let st = this;
        let v = this.v = new Value(this.p.radius, width, easing)
        v.doneHandler = ()=>{
            // st.switchOut()
            this.nextTick(this.switchOut.bind(this))
        }

        this.microStep = 0
    }

    randomColor(){
        let deg = random.int(360)
        let sat = random.int(100)
        let lig = random.int(100)
        return `hsl(${deg}deg ${sat}% ${lig}%)`
    }

    switchOut() {
        console.log('doneHandler')
        let p = this.p
        this.v = undefined;

        this.backgroundColor = p.color

        // this.nextTick(
        setTimeout(()=>{
            // p.color = this.randomColor()
            // p.radius = 5
            // this.p.radius = 50
        }, 400)
    }

    step(){
        if(this.v) {
            let t = this.v.get(this.microStep)
            this.p.radius = t
        } else {
            // this.p.radius -= this.microValue * 30
        }

        this.microStep += this.microValue
    }

    draw(ctx){
        this.clear(ctx, this.backgroundColor)
        this.p.pen.fill(ctx)
        this.step()
        // this.p.pen.indicator(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: splatout.js
================================================================================



================================================================================
FILE: split-2.js
================================================================================

/*
title: Split 2
categories: split
files:
    ../point_src/math.js
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
 */
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.gWidth = 50
        this.point = new Point(100, 100, this.gWidth, 0)
        this.count = 20

        this.dragging.add(this.point)//, ...lpoints, ...lpoints2, ...lpoints3, ...lpoints4)
    }

    draw(ctx){
        this.clear(ctx)
        this.gWidth = this.point.radius
        this.point.radians += .01
        this.point.pen.circle(ctx)

        let p = this.point.copy()

        let count = 7;
        let cp = p.copy()
        for (var i = 1; i < count; i++) {
            let ip = cp.copy()
            ip.x += this.gWidth * 3
            let ps = ip.split(i)//.pen.indicators(ctx)
            ps.each.radius = 5
            ip.pen.indicator(ctx, { color: '#444'})
            ps.pen.indicators(ctx)
            cp = ip
        }

        let innerSpinner = -this.point.radians

        /* reset the origin */
        p = p.copy()
        p.y += this.gWidth * 3
        p.x = this.gWidth * 2

        cp = p.copy()
        for (var i = 1; i < count; i++) {
            let ip = cp.copy()
            ip.x += this.gWidth * 3
            let ps = ip.split(i, innerSpinner)//.pen.indicators(ctx)
            ps.each.radius = 10
            ip.pen.indicator(ctx, { color: '#444'})
            ps.pen.indicators(ctx)
            cp = ip
        }

        // this.line.render(ctx)
        // this.line.split(this.count, 90).pen.indicators(ctx)

        // this.line2.splitInner(this.count, 90).pen.indicators(ctx, {color:'green'})
        // this.line2.render(ctx, {color: 'green'})

        // this.curve.render(ctx, {color: 'green'})
        // this.curve.splitInner(this.count, degToRad(0)).pen.indicators(ctx)

        // this.curve2.render(ctx, {color: 'red'})
        // this.curve2.split(this.count,  0, ctx).pen.indicators(ctx)

    }
}


;stage = MainStage.go();

================================================================================
END: split-2.js
================================================================================



================================================================================
FILE: split-another.js
================================================================================

/*
---
title: Split
categories: split
    curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/screenwrap.js
    ../point_src/curve-extras.js
*/
class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        this.count = 80
        let lpoints4 = [new Point(200, 300, 300, 90), new Point(800, 400, 200, 100)]
        this.curve2 = new BezierCurve(...lpoints4)
        this.dragging.add( ...lpoints4)

        // Ball setup
        this.ball = new Point({
            x: 400,
            y: 100,
            radius: 15,
            vx: 0,
            vy: 0
        })

        this.showNormals = false
        this.showHitPoint = false
        this.drawCollisonPoints = false
        // Physics constants
        this.gravity = 0.1
        this.damping = 1  // Bounce damping (affects normal velocity)
        this.rollingFriction = 0.98  // Rolling resistance (affects tangential velocity)
        this.dragging.add(this.ball)

    }

    draw(ctx){
        this.clear(ctx)

        // Apply gravity to ball
        this.ball.vy += this.gravity
        this.ball.x += this.ball.vx
        this.ball.y += this.ball.vy

        this.curve2.render(ctx, {color: '#777'})
        let normals = this.curve2.split(this.count,  0)
        this.screenWrap.perform(this.ball)

        normals.each.radius = 10
        if(this.showNormals) {
            normals.pen.lines(ctx, 'green', 2)
        }

        // Create and draw ray projecting in direction of velocity
        // Adaptive ray length: shorter when moving slowly or close to the curve
        let velocityMag = Math.sqrt(this.ball.vx * this.ball.vx + this.ball.vy * this.ball.vy)

        // Base ray length on velocity magnitude, with minimum and maximum bounds
        let baseRayLength = Math.max(this.ball.radius * 2, Math.min(100, velocityMag * 20))

        let rayStart = new Point(this.ball.x, this.ball.y)

        // Calculate ray direction from velocity (or default to downward if no velocity)
        let rayDirX, rayDirY

        if (velocityMag > 0.01) {
            // Ray points in direction of velocity
            rayDirX = this.ball.vx / velocityMag
            rayDirY = this.ball.vy / velocityMag
        } else {
            // Default to pointing downward if ball is stationary
            rayDirX = 0
            rayDirY = 1
        }

        let rayEnd = new Point(
            this.ball.x + rayDirX * baseRayLength,
            this.ball.y + rayDirY * baseRayLength
        )


================================================================================
END: split-another.js
================================================================================



================================================================================
FILE: split-bar-2.js
================================================================================

/*
title: Split Bar 2
categories: split
    curve
files:
    ../point_src/math.js
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
 */

const zip = function(a, b) {

}

class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.gWidth = 50
        this.point = new Point(100, 100, this.gWidth, 0)
        this.count = 20

        let lpoints = [new Point(100, 100, 100), new Point(500, 100, 20)]
        // this.line = new Line(...lpoints)
        this.line = new BezierCurve(...lpoints)

        let lpoints2 = [new Point(300, 300, 50), new Point(500, 300)]
        // this.line2 = new Line(...lpoints2)
        this.line2 = new BezierCurve(...lpoints2)

        this.dragging.add(this.point, ...lpoints, ...lpoints2)//, ...lpoints, ...lpoints2, ...lpoints3, ...lpoints4)
    }

    draw(ctx){
        this.clear(ctx)
        let normRelRotation = 90
        this.point.radians += .01
        // this.point.pen.circle(ctx)
        // this.point.split(this.count).pen.indicators(ctx)

        let as = this.line.split(this.count, -normRelRotation)
        let bs = this.line2.split(this.count, normRelRotation)

        // as.pen.indicators(ctx, {color:'#333'})
        // bs.pen.indicators(ctx, {color:'#333'})

        let lines = []
        let l = as.length
        let asFirst = this.line[0]
        let asLast = this.line[1]
        let bsFirst = this.line2[0]
        let bsLast = this.line2[1]

        const lerpRadius = function(a, b, v) {
            /* Process the width from the _first_ to the _last_ of a line.*/
            // let av = ((asLast.radius - asFirst.radius) * (i/l))+asFirst.radius
            return ((b - a) * (i/l)) + a
        }

        const radiusManual = function(a, b, i) {
            /* Manual lerping from line points. */
            a.radius = lerpRadius(asFirst.radius, asLast.radius, i/l)
            b.radius = lerpRadius(bsFirst.radius, bsLast.radius, i/l)
        }
        const radiusDistance = function(a, b, i) {
            /* Auto by distance. */
            let d = a.distanceTo(b)
            a.radius = b.radius = d * .4
        }

        const radiusLocked = function(a, b, i) {
            /*locked.*/
            a.radius = b.radius = 100
        }

        for (var i = 0; i < l; i++) {

            // radiusManual(as[i], bs[i], i)
            radiusDistance(as[i], bs[i], i)
            // radiusLocked(as[i], bs[i], i)

            // let line = new Line(as[i], bs[i])


================================================================================
END: split-bar-2.js
================================================================================



================================================================================
FILE: split-bar-warp-2.js
================================================================================

/*
title: Split Bar Warp 2
categories: split
    curve
tags: ribbon
files:
    ../point_src/math.js
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
 */

class Ribbon {
    /* two lines, connected by many lines */
    constructor(settings) {
        if(settings != undefined) {
            this.setup(settings)
        }

    }

    setup(settings){
        this.settings = settings
        this.setupPairMethods()
        this.gWidth = 50
        let c = this.point = settings.point
        // this.count = 20
        let givenPoints = settings.points

        let l = givenPoints.length;
        let aMap = {
            1: ()=>{
                // split 4
                let gp = givenPoints[0]
                // gp.rotate(-45)
                let [a,b,c,d] = gp.split(4)
                let v = [b,a,c,d]
                v.forEach(p=>p.radius = gp.radius  * .25)
                return v
            }
            , 2: ()=>{
                // two points, split,
                return [...givenPoints[0].split(2), ...givenPoints[1].split(2)]
            }
        }
        let f = aMap[l]
        let points = new PointList(...(f? f(): givenPoints))
        // let points = new PointList(
        //       new Point(c.x-300, c.y-200, 50)
        //     , new Point(c.x+300, c.y-200, 50)
        //     , new Point(c.x-300, c.y+200, 50)
        //     , new Point(c.x+300, c.y+200, 50)
        // )

        this.points = points
        // let lpoints = [new Point(c.x-300, c.y-200, 50), new Point(c.x+300, c.y-200, 50)]
        // let lpoints2 = [new Point(c.x-300, c.y+200, 50), new Point(c.x+300, c.y+200, 50)]
        this.lineA = new Line(points[0], points[1])
        this.lineB = new Line(points[2], points[3])
    }

    setupPairMethods(){
        const lerpRadius = function(a, b, i, l) {
            /* Process the width from the _first_ to the _last_ of a line.*/
            // let av = ((asLast.radius - asFirst.radius) * (i/l))+asFirst.radius
            return ((b - a) * (i/l)) + a
        }

        let parent = this;
        const radiusManual = function(a, b, i, l) {
            let asFirst = parent.lineA[0]
            let asLast = parent.lineA[1]
            let bsFirst = parent.lineB[0]
            let bsLast = parent.lineB[1]

            /* Manual lerping from line points. */
            a.radius = lerpRadius(asFirst.radius, asLast.radius, i, l)
            b.radius = lerpRadius(bsFirst.radius, bsLast.radius, i, l)
        }

        const radiusDistance = function(a, b, i, l) {
            /* Auto by distance. */
            let d = a.distanceTo(b)
            a.radius = b.radius = d * .4


================================================================================
END: split-bar-warp-2.js
================================================================================



================================================================================
FILE: split-bar-warp.js
================================================================================

/*
title: Split Bar Warp
categories: split
    curve
files:
    ../point_src/math.js
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
 */

const zip = function(a, b) {

}

class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.gWidth = 50
        let c = this.point = this.center.copy().update({ radius: 100})
        this.count = 20

        let lpoints = [new Point(c.x-300, c.y-200, 50), new Point(c.x+300, c.y-200, 50)]
        this.line = new Line(...lpoints)

        let lpoints2 = [new Point(c.x-300, c.y+200, 50), new Point(c.x+300, c.y+200, 50)]
        this.line2 = new Line(...lpoints2)

        this.dragging.add(this.point, ...lpoints, ...lpoints2)//, ...lpoints, ...lpoints2, ...lpoints3, ...lpoints4)
    }

    draw(ctx){
        this.clear(ctx)
        let normRelRotation = 90
        this.point.radians += .01
        // this.point.split(this.count).pen.indicators(ctx)

        let as = this.line.splitInner(this.count, -normRelRotation)
        let bs = this.line2.splitInner(this.count, normRelRotation)

        // as.pen.indicators(ctx, {color:'#333'})
        // bs.pen.indicators(ctx, {color:'#333'})

        let lines = []
        let l = as.length
        let asFirst = this.line[0]
        let asLast = this.line[1]
        let bsFirst = this.line2[0]
        let bsLast = this.line2[1]

        const lerpRadius = function(a, b, v) {
            /* Process the width from the _first_ to the _last_ of a line.*/
            // let av = ((asLast.radius - asFirst.radius) * (i/l))+asFirst.radius
            return ((b - a) * (i/l)) + a
        }

        const radiusManual = function(a, b, i) {
            /* Manual lerping from line points. */
            a.radius = lerpRadius(asFirst.radius, asLast.radius, i/l)
            b.radius = lerpRadius(bsFirst.radius, bsLast.radius, i/l)
        }

        const radiusDistance = function(a, b, i) {
            /* Auto by distance. */
            let d = a.distanceTo(b)
            a.radius = b.radius = d * .4
        }

        const radiusLocked = function(a, b, i) {
            /*locked.*/
            a.radius = b.radius = 100
        }

        let p = this.point;

        for (var i = 0; i < l; i++) {

            // radiusManual(as[i], bs[i], i)
            // radiusDistance(as[i], p, i)
            // radiusLocked(as[i], bs[i], i)

            as[i].radius = as[i].distanceTo(p)


================================================================================
END: split-bar-warp.js
================================================================================



================================================================================
FILE: split-bar.js
================================================================================

/*
title: Split Bar
categories: split
    lines
files:
    ../point_src/math.js
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
 */

const zip = function(a, b) {

}

class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.gWidth = 50
        this.point = new Point(100, 100, this.gWidth, 0)
        this.count = 20

        let lpoints = [new Point(100, 100, 100), new Point(500, 100, 20)]
        this.line = new Line(...lpoints)

        let lpoints2 = [new Point(300, 300, 50), new Point(500, 300)]
        this.line2 = new Line(...lpoints2)

        this.dragging.add(this.point, ...lpoints, ...lpoints2)//, ...lpoints, ...lpoints2, ...lpoints3, ...lpoints4)
    }

    draw(ctx){
        this.clear(ctx)
        let normRelRotation = 90
        this.point.radians += .01
        // this.point.pen.circle(ctx)
        // this.point.split(this.count).pen.indicators(ctx)

        let as = this.line.splitInner(this.count, -normRelRotation)
        let bs = this.line2.splitInner(this.count, normRelRotation)

        // as.pen.indicators(ctx, {color:'#333'})
        // bs.pen.indicators(ctx, {color:'#333'})

        let lines = []
        let l = as.length
        let asFirst = this.line[0]
        let asLast = this.line[1]
        let bsFirst = this.line2[0]
        let bsLast = this.line2[1]

        const lerpRadius = function(a, b, v) {
            /* Process the width from the _first_ to the _last_ of a line.*/
            // let av = ((asLast.radius - asFirst.radius) * (i/l))+asFirst.radius
            return ((b - a) * (i/l)) + a
        }

        const radiusManual = function(a, b, i) {
            /* Manual lerping from line points. */
            a.radius = lerpRadius(asFirst.radius, asLast.radius, i/l)
            b.radius = lerpRadius(bsFirst.radius, bsLast.radius, i/l)
            b.radians = lerpRadius(bsFirst.radians, bsLast.radians, i/l)
        }
        const radiusDistance = function(a, b, i) {
            /* Auto by distance. */
            let d = a.distanceTo(b)
            a.radius = b.radius = d * .4
        }

        const radiusLocked = function(a, b, i) {
            /*locked.*/
            a.radius = b.radius = 100
        }

        for (var i = 0; i < l; i++) {

            radiusManual(as[i], bs[i], i)
            // radiusDistance(as[i], bs[i], i)
            // radiusLocked(as[i], bs[i], i)

            // let line = new Line(as[i], bs[i])
            let line = new BezierCurve(as[i], bs[i])


================================================================================
END: split-bar.js
================================================================================



================================================================================
FILE: split-circle-warp-tunnel.js
================================================================================

/*
title: Split Circle Warp Tunnel
categories: split
    curve
    pseudo3D
files:
    ../point_src/math.js
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
 */

const zip = function(a, b) {

}

class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.gWidth = 50
        this.point = new Point(100, 100, this.gWidth, 0)
        this.point2 = new Point(200, 200, this.gWidth, 0)
        this.count = 20
        this.normRelRotation = 10

        this.dragging.add(this.point, this.point2)
    }

    draw(ctx){
        this.clear(ctx)
        let normRelRotation = this.normRelRotation
        this.point.rotation += .1
        this.point2.rotation += .1
        this.point.pen.circle(ctx)
        this.point2.pen.circle(ctx)

        let as = this.point.split(this.count, normRelRotation)
        let bs = this.point2.split(this.count, Math.PI)

        // as.pen.indicators(ctx, {color:'#333'})
        // bs.pen.indicators(ctx, {color:'#333'})

        let lines = []
        let l = as.length
        let asFirst = this.point
        let asLast = this.point
        let bsFirst = this.point2
        let bsLast = this.point2

        const lerpRadius = function(a, b, v) {
            /* Process the width from the _first_ to the _last_ of a line.*/
            // let av = ((asLast.radius - asFirst.radius) * (i/l))+asFirst.radius
            return ((b - a) * (i/l)) + a
        }

        const radiusManual = function(a, b, i) {
            /* Manual lerping from line points. */
            a.radius = lerpRadius(asFirst.radius, asLast.radius, i/l)
            b.radius = lerpRadius(bsFirst.radius, bsLast.radius, i/l)
        }
        const radiusDistance = function(a, b, i) {
            /* Auto by distance. */
            let d = a.distanceTo(b)
            a.radius = b.radius = d * .4
        }

        const radiusLocked = function(a, b, i) {
            /*locked.*/
            a.radius = b.radius = 100
        }

        for (var i = 0; i < l; i++) {

            // radiusManual(as[i], bs[i], i)
            // radiusDistance(as[i], bs[i], i)
            radiusLocked(as[i], bs[i], i)

            // let line = new Line(as[i], bs[i])
            let line = new BezierCurve(as[i], bs[i])
            line.doTips = false;
            lines.push(line)
        };


================================================================================
END: split-circle-warp-tunnel.js
================================================================================



================================================================================
FILE: split-zip.js
================================================================================

/*
---
title: Split
categories: split
    curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    stage
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
    ../point_src/functions/zip.js
*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.point = new Point(300, 400, 100)
        this.count = 20

        this.point1 = new Point(300, 400, 50)
        this.point2 = new Point(300, 400, 120)

        let lpoints = [new Point(100, 100), new Point(500, 100)]
        this.line = new Line(...lpoints)

        let lpoints2 = [new Point(100, 200), new Point(500, 200)]
        this.line2 = new Line(...lpoints2)

        this.dragging.add(this.point
                , ...lpoints
                , ...lpoints2
                , this.point1
                , this.point2

            )

        // this.splits1 = this.line.split(this.count, -90)
        // this.splits2 = this.line2.split(this.count, 90)
    }

    draw(ctx){
        this.clear(ctx)

        // let pos = this.mouse.position
        // pos.pen.circle(ctx)

        // this.point.pen.indicator(ctx)
        // this.point.split(this.count, degToRad(0)).pen.indicators(ctx)

        // this.splits1.pen.indicators(ctx)
        // this.splits2.pen.indicators(ctx, {color:'green'})

        this.line.render(ctx)
        this.line2.render(ctx, {color: 'green'})

        let splits1 = this.line.split(this.count, -90)
        let splits2 = this.line2.split(this.count, 90)

        this.point1.pen.circle(ctx)
        this.point2.pen.circle(ctx)

        let pointSplits1 = this.point1.split(this.count, -90)
        let pointSplits2 = this.point2.split(this.count, 90)

        for(let xx of zip(pointSplits1, pointSplits2)) {
            // (new PointList(...xx)).pen.line(ctx)  // Spread the pair
            xx.forEach(x=>x.radius=100);
            xx[0].pen.line(ctx, xx[1])
            // (new BezierCurve(...xx)).render(ctx)  // Spread the pair
        }

        for(let xx of zip(splits1, splits2)) {
            // (new PointList(...xx)).pen.line(ctx)  // Spread the pair
            xx.forEach(x=>x.radius=100);
            xx[0].pen.line(ctx, xx[1])
            // (new BezierCurve(...xx)).render(ctx)  // Spread the pair
        }

    }
}


;stage = MainStage.go();

================================================================================
END: split-zip.js
================================================================================



================================================================================
FILE: split.js
================================================================================

/*
---
title: Split
categories: split
    curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/curve-extras.js
*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.point = new Point(300, 400, 100)
        this.count = 20

        let lpoints = [new Point(100, 100), new Point(500, 100)]
        this.line = new Line(...lpoints)


        let lpoints2 = [new Point(100, 200), new Point(500, 200)]
        this.line2 = new Line(...lpoints2)

        let lpoints3 = [new Point(100, 700, 200), new Point(500, 700, 200)]
        this.curve = new BezierCurve(...lpoints3)

        let lpoints4 = [new Point(100, 800, 200), new Point(500, 800, 200)]
        this.curve2 = new BezierCurve(...lpoints4)

        this.dragging.add(this.point, ...lpoints, ...lpoints2, ...lpoints3, ...lpoints4)
    }

    draw(ctx){
        this.clear(ctx)

        let pos = this.mouse.position
        pos.pen.circle(ctx)

        this.point.pen.indicator(ctx)
        this.point.split(this.count, degToRad(0)).pen.indicators(ctx)

        this.line.render(ctx)
        this.line.split(this.count, 90).pen.indicators(ctx)

        this.line2.splitInner(this.count, 90).pen.indicators(ctx, {color:'green'})
        this.line2.render(ctx, {color: 'green'})

        this.curve.render(ctx, {color: 'green'})
        this.curve.splitInner(this.count, degToRad(0)).pen.indicators(ctx)

        this.curve2.render(ctx, {color: 'red'})
        this.curve2.split(this.count,  0, ctx).pen.indicators(ctx)
        // let l = this.curve.splitHinted(this.count).pen.indicators(ctx, {color:'red'})

        // let [p0, p3] = this.curve2.points
        // let midX = (p0.x + p3.x) * .5
        // let midY = (p0.y + p3.y) * .5
        // let mid = new Point(midX, midY)

        // mid.pen.indicator(ctx, {color:'yellow'})
    }
}


;stage = MainStage.go();

================================================================================
END: split.js
================================================================================



================================================================================
FILE: spray-brush.js
================================================================================

/*
title: Spray
categories: brush
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
    stroke
    ../point_src/random.js
    ../point_src/table.js
---

On mouse down the _paint spray_ functionality plots many points near
the mouse position, using the `random.within(point)` method.

To make it efficient the stage doesn't _loop draw_ with a clearing layer. Instead
the _drawOnce_ occurs after every mouse move without the clear.
*/

let keys = [
    /* Random rotation per point every spray down */
    'randomPointRot' // : true
    /* If the randomPointRot is true*/
    , 'randomPointRotMin' // : 0
    , 'randomPointRotMax' // : 360
    /* Random radius per point every spray down */
    , 'randomPointRadius' // : true
    , 'randomPointRadiusMin'
    , 'randomPointRadiusMax'

    , 'randomPointColor' // : false
    , 'fillPointColor' // : false

    /* How many point to plot per spray down*/
    , 'sprayDownMin' // : 5
    , 'sprayDownMax' // : 20

    , 'walkTicker' // : 100

    /* resize the mouse based on its speed.*/
    , 'speedMouse' // : true
    , 'speedMouseMin'
    , 'speedMouseMax'
    , 'minRandomColor'
]

const confTable = new Table(keys, {
      'a': [true, 0, 360, true, .1, 3, true, false, 2, 50, 10, true, 3, 50, 0]
      , 'b': [false, 0, 0, true, .1, 3, false, false, 5, 90, 50, false, 3, 50, 0]
      , 'c': [true, 0, 360, true, .1, 3, false, false, 2, 9, 5, true, 3, 50, 0]
      , 'd': [false, 0, 0, true, 1, 5, false, false, 2, 9, 50, false, 3, 50, 0]
      , 'e': [true, 0, 360, true, .1, 3, true, false, 2, 50, 100, false, 3, 50, 0]
      , 'f': [false, 0, 0, true, .1, 3, true, true, 2, 50, 900, true, 3, 50, 0]
      , 'g': [false, 0, 0, true, .1, 3, false, true, 2, 50, 900, true, 3, 50, 0]
      , 'h': [true, 0, 304, true, 10, 30, false, false, .1, .2, 1000, true, 3, 50, 0]
      , 'i': [false, 0, 0, true, .1, .7, false, true, 30, 90, 300, true, 1, 8, 90]
},)

// addControl('choice', {
//     field: 'select'
//     , options: confTable.getKeys()
//     , stage: this
//     , onchange(ev) {
//         let sval = ev.currentTarget.value
//         settings = confTable.get(sval)
//     }
// })

confTable.controls.choice((ev) => {
    let sval = ev.currentTarget.value
    settings = confTable.get(sval)
})

addButton('clear', {
    // label: 'my button'
    onclick(ev) {
        console.log('clear')
        stage.clear()
    }
});

var settings = confTable.get('i')

const _settings = {

    /* Random rotation per point every spray down */
    randomPointRot: true
    /* If the randomPointRot is true*/
    , randomPointRotMin: 0
    , randomPointRotMax: 360

    /* Random radius per point every spray down */
    , randomPointRadius: true
    , randomPointRotMin: .1
    , randomPointRotMax: 3

    , randomPointColor: false


================================================================================
END: spray-brush.js
================================================================================



================================================================================
FILE: spreadline-2.js
================================================================================

/*
---
title: Spread Line
src_dir: ../point_src/
files:
    ../point_src/core/head.js
    point
    pointlist
    mouse
    dragging
    stroke
    ../point_src/stage.js
    ../point_src/split.js
    ../point_src/jiggle.js
    ../point_src/random.js
---
*/

class SpreadLines extends PointList {

    static spawn(generalRadius=20, hue) {
        let items = PointList.generate.random(20,
            [300, 200, null, 0],
            [100, 100, 10, 0]
        )

        items.each.hue = hue;
        items.each.z = (p) => Math.random()
        items.each.radius = (p) => generalRadius * p.z

        items.forEach((p)=>{
                let v = (1 - p.z) * random.float(.1, .4)//Math.random()
                p.jiggler.options.speedReducer = v
                p.jiggler.options.height = 10 * p.z
        })

        return SpreadLines.from(items)
        // return items
    }

    render(ctx, minSaturation=10 /*percent*/, generalLineWidth=4) {
        this.forEach(function(p){
            let hue = p.hue - (100 * p.z)
            /* Build a saturation value from the Z */
            let saturation = ( (50 * (1-p.z) ) + minSaturation)
            let cleanSat = clamp(70-saturation, 10, 60).toFixed(1)


            let color = `hsl(${hue}deg 100% ${cleanSat}%)`

            p.jiggler.step()
            let pp = p.jiggler.point
            pp.split(2).pen.line(ctx, {
                    color
                    , width: generalLineWidth * p.z
                })
        })
    }
}


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.makePl()
        let a = this.a = new Point({x:200,y:200, radius: 50, rotation: 0})
        this.dragging.add(a)
        this.events.wake()
    }

    onClick(){
        this.makePl()
    }

    makePl() {
        let generalRadius = 40
        let hue = (Math.random() * 360).toFixed(1)
        this.pl = SpreadLines.spawn(generalRadius, hue)
    }

    draw(ctx){
        this.clear(ctx)
        let generalLineWidth = 5
        let minSaturation = 10 /*percent*/
        ctx.lineCap = "round"
        this.pl.render(ctx, minSaturation, generalLineWidth)
    }
}


;stage = MainStage.go();

================================================================================
END: spreadline-2.js
================================================================================



================================================================================
FILE: spreadline.js
================================================================================

/*
---
title: Spread Line
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/split.js
    ../point_src/jiggle.js
    ../point_src/random.js
---
*/
class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.makePl()
        let a = this.a = new Point({x:200,y:200, radius: 50, rotation: 0})
        this.dragging.add(a)
        this.events.wake()
    }

    onClick(){
        this.makePl()
    }

    makePl() {
        let generalRadius = 40
        let hue = (Math.random() * 360).toFixed(1)

        this.pl = PointList.generate.random(20,
                [300, 200, null, 0],
                [100, 100, 10, 0]
            )

        this.pl.each.hue = hue;
        this.pl.each.z = (p) => Math.random()
        this.pl.each.radius = (p) => generalRadius * p.z

        this.pl.forEach((p)=>{
                let v = (1 - p.z) * random.float(.1, .4)//Math.random()
                p.jiggler.options.speedReducer = v
                p.jiggler.options.height = 10 * p.z
        })


    }

    draw(ctx){
        let generalLineWidth = 5
        let minSaturation = 10 // percent
        this.clear(ctx)
        ctx.lineCap = "round";
        // this.a.rotation += .5
        let a = this.a
        // this.pl.pen.indicator(ctx, { color:'#444'})
        this.pl.forEach(function(p){
            let hue = p.hue - (100 * p.z)
            /* Build a saturation value from the Z */
            let saturation = ( (50 * (1-p.z) ) + minSaturation)
            let cleanSat = clamp(70-saturation, 10, 60).toFixed(1)


            let color = `hsl(${hue}deg 100% ${cleanSat}%)`

            p.jiggler.step()
            let pp = p.jiggler.point
            pp.split(2).pen.line(ctx, {
                    color
                    , width: generalLineWidth * p.z
                })
        })

        // this.a.pen.indicator(ctx, { color:'#444'})
        // this.a.split(2).pen.line(ctx, {color: 'red', width: 3})

    }
}


;stage = MainStage.go();

================================================================================
END: spreadline.js
================================================================================



================================================================================
FILE: spring-blob-manual-gravity.js
================================================================================

/*
title: Spring Blob Manual Gravity
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/rope.js
    ../point_src/collisionbox.js
    ../point_src/gravity.js
    */

const stringLength = 200

const heavyStep = function(followPoint, mouse, gravity,
                           damping=.9, dotDamping=.2, forceMultiplier=.1, forceValue=undefined) {
    // Apply gravity to the follow point's vertical velocity
    // Calculate the vector from the mouse to the follow point
    // let dx = followPoint.x - mouse.x ;
    // let dy = followPoint.y - mouse.y ;
    let dx = mouse.x - followPoint.x;
    let dy = mouse.y - followPoint.y;

    // Calculate the current distance between the follow point and the mouse
    let distance = Math.sqrt(dx * dx + dy * dy);

    // Set the follow point's position to be exactly on the circumference of the string length
    // const force = (distance - stringLength) * 0.01; // Tweak this factor as needed

    // If the distance exceeds the string length, we need to constrain the follow point
    if (distance > stringLength) {

        // Normalize the direction vector
        dx /= distance;
        dy /= distance;

        if(dotDamping!==false) {
            // Adjust the velocity so that it reflects the string tension
            let dotProduct = (followPoint.vx * dx + followPoint.vy * dy) * dotDamping;
            followPoint.vx -= dotProduct * dx;
            followPoint.vy -= dotProduct * dy;
        }

        if(forceMultiplier!==false){
            const force = forceValue? forceValue: (distance - stringLength) * forceMultiplier; // Tweak this factor as needed
            followPoint.vx += force * dx;
            followPoint.vy += force * dy;
        }

    }

    // Apply gravity
    if(gravity){
        followPoint.vy += gravity.y;
        followPoint.vx += gravity.x;
    }

    // Update the follow point's position based on its velocity
    followPoint.x += followPoint.vx;
    followPoint.y += followPoint.vy;

    if(damping) {
        // Apply damping continuously to smooth the motion
        followPoint.vx *= damping;
        followPoint.vy *= damping;
    }
};



class Balloon {

    defaults = {
            // gravity: .2

            gravity: {x:.05, y: 0}
            , visibleRopeGravity: {x:0, y:0.2}
            // gravity: undefined
            // , visibleRopeGravity: undefined
            , ropePointLength: 20
            , segmentLength: 10
            , invMass: .3
            , color: '#990000'
            , knotColor: '#225555'


================================================================================
END: spring-blob-manual-gravity.js
================================================================================



================================================================================
FILE: spring-blob-manual.js
================================================================================

/*
title: Spring Blob Manual
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/collisionbox.js


moved to functions/springs */

addButton('Add', {
    onclick() {
        let p = new Point({
             x: 280, y: 290
            , vx: 0, vy: 0
            , radius: 8
            , mass: 5
        })

        stage.points.push(p)

        // p.spring.to(ps.last(), rLen, springConstant, damping, lockedPoints, deltaTime)

    }
})


addSliderControlSet({
    restLength: {
        value: 1
        , min: 1
        , max: 60
        , onchange(ev, unit) {
            unit.value = stage.restLength = Number(ev.currentTarget.value);
        }
    }
    , springConstant: {
        value: .1
        , min: 0
        , max: 6
        , step: .1
        , onchange(ev, unit) {
            unit.value = stage.springConstant = Number(ev.currentTarget.value);
        }
    }
    , dampingFactor: {
        value: .01
        , min: 0
        , max: 1
        , step: .01
        , onchange(ev, unit) {
            unit.value = stage.dampingFactor = Number(ev.currentTarget.value);
        }
    }
})

addCheckbox('Show Braces', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showBraces = ev.currentTarget.checked

        }
    })

addCheckbox('Show Points', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showPoints = ev.currentTarget.checked

        }
    })


addCheckbox('Show Outer', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showOuter = ev.currentTarget.checked

        }
    })

addCheckbox('Show Ball', {


================================================================================
END: spring-blob-manual.js
================================================================================



================================================================================
FILE: spring-blob-spokes.js
================================================================================

/*
title: Spring Blob Spokes
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/split.js
    ../point_src/collisionbox.js


moved to functions/springs */

addButton('Add', {
    onclick() {
        let p = new Point({
             x: 280, y: 290
            , vx: 0, vy: 0
            , radius: 8
            , mass: 5
        })

        stage.points.push(p)

        // p.spring.to(ps.last(), rLen, springConstant, damping, lockedPoints, deltaTime)

    }
})


addSliderControlSet({
    restLength: {
        value: 1
        , min: 1
        , max: 60
        , onchange(ev, unit) {
            unit.value = stage.restLength = Number(ev.currentTarget.value);
        }
    }
    , springConstant: {
        value: .1
        , min: 0
        , max: 6
        , step: .1
        , onchange(ev, unit) {
            unit.value = stage.springConstant = Number(ev.currentTarget.value);
        }
    }
    , dampingFactor: {
        value: .01
        , min: 0
        , max: 1
        , step: .01
        , onchange(ev, unit) {
            unit.value = stage.dampingFactor = Number(ev.currentTarget.value);
        }
    }
})

addCheckbox('Show Braces', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showBraces = ev.currentTarget.checked

        }
    })

addCheckbox('Show Points', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showPoints = ev.currentTarget.checked

        }
    })


addCheckbox('Show Outer', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showOuter = ev.currentTarget.checked

        }
    })



================================================================================
END: spring-blob-spokes.js
================================================================================



================================================================================
FILE: spring-blob.js
================================================================================

/*
title: Spring Blob
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/collisionbox.js


moved to functions/springs */

addButton('Add', {
    onclick() {
        let p = new Point({
             x: 280, y: 290
            , vx: 0, vy: 0
            , radius: 8
            , mass: 5
        })

        stage.points.push(p)

        // p.spring.to(ps.last(), rLen, springConstant, damping, lockedPoints, deltaTime)

    }
})


addSliderControlSet({
    restLength: {
        value: 1
        , min: 1
        , max: 60
        , onchange(ev, unit) {
            unit.value = stage.restLength = Number(ev.currentTarget.value);
        }
    }
    , springConstant: {
        value: .1
        , min: 0
        , max: 6
        , step: .1
        , onchange(ev, unit) {
            unit.value = stage.springConstant = Number(ev.currentTarget.value);
        }
    }
    , dampingFactor: {
        value: .01
        , min: 0
        , max: 1
        , step: .01
        , onchange(ev, unit) {
            unit.value = stage.dampingFactor = Number(ev.currentTarget.value);
        }
    }
})

addCheckbox('Show Braces', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showBraces = ev.currentTarget.checked

        }
    })

addCheckbox('Show Points', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showPoints = ev.currentTarget.checked

        }
    })


addCheckbox('Show Outer', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showOuter = ev.currentTarget.checked

        }
    })

addCheckbox('Show Ball', {


================================================================================
END: spring-blob.js
================================================================================



================================================================================
FILE: spring-bolted-triangle.js
================================================================================

/*
title: Spring Bolted Triangle
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/collisionbox.js


moved to functions/springs */

addButton('Add', {
    onclick() {
        let p = new Point({
             x: 280, y: 290
            , vx: 0, vy: 0
            , radius: 8
            , mass: 5
        })

        stage.points.push(p)

        // p.spring.to(ps.last(), rLen, springConstant, damping, lockedPoints, deltaTime)

    }
})


addSliderControlSet({
    restLength: {
        value: 1
        , min: 1
        , max: 200
        , onchange(ev, unit) {
            unit.value = stage.restLength = Number(ev.currentTarget.value);
        }
    }
    , springConstant: {
        value: .1
        , min: 0
        , max: 6
        , step: .1
        , onchange(ev, unit) {
            unit.value = stage.springConstant = Number(ev.currentTarget.value);
        }
    }
    , dampingFactor: {
        value: .01
        , min: 0
        , max: 1
        , step: .01
        , onchange(ev, unit) {
            unit.value = stage.dampingFactor = Number(ev.currentTarget.value);
        }
    }
})

addCheckbox('Show Braces', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showBraces = ev.currentTarget.checked

        }
    })

addCheckbox('Show Points', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showPoints = ev.currentTarget.checked

        }
    })


addCheckbox('Show Outer', {
        checked: true
        , onchange(ev, unit){
            unit.value = stage.showOuter = ev.currentTarget.checked

        }
    })

addCheckbox('Show Ball', {


================================================================================
END: spring-bolted-triangle.js
================================================================================



================================================================================
FILE: spring-bound-point.js
================================================================================

/*
title: Spring Bound Point
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/functions/springs.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    dragging
    ../point_src/stage.js
    stroke
    mouse


moved to functions/springs
*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                 x: 150, y: 230
                , radius: 10
                , vx: 1, vy: 0
                , mass: 10
            })
            , new Point({
                 x: 350, y: 200
                , vx: -1, vy: 0
                , radius: 10
                , mass: 10
            })
            , new Point({
                 x: 450, y: 520
                , vx: .4, vy: -.1
                , radius: 8
                , mass: 8
            })
            // , new Point({
            //      x: 450, y: 520
            //     , vx: .4, vy: -.1
            //     , radius: 8
            //     , mass: 8
            // })
            // , new Point({
            //      x: 450, y: 520
            //     , vx: .4, vy: -.1
            //     , radius: 8
            //     , mass: 8
            // })
            // , new Point({
            //      x: 450, y: 520
            //     , vx: .4, vy: -.1
            //     , radius: 8
            //     , mass: 8
            // })
        )
    }

    draw(ctx){
        this.clear(ctx)

        let mouse = Point.mouse.position
        let ps = this.points;

        let restLength = 100;
        let springConstant = .6;
        let dampingFactor = 0.99; // Adjust this value between 0 and 1

        const lockedPoints = new Set([ps[0]]); // Lock pointA in place


        applySpringForceDistributed(ps[0], ps[1], restLength, springConstant, dampingFactor, lockedPoints);
        applySpringForceDistributed(ps[1], ps[2], restLength, springConstant, dampingFactor, lockedPoints);
        applySpringForceDistributed(ps[2], ps[0], restLength, springConstant, dampingFactor, lockedPoints);

        // this.points.last().rotation += 2
        this.points.pen.indicators(ctx)

    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: spring-bound-point.js
================================================================================



================================================================================
FILE: spring-draggable-bound-2-point.js
================================================================================

/*
title: Spring Draggable Bound 2 Point
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js


moved to functions/springs */

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                 x: 150, y: 230
                , radius: 10
                , vx: .1, vy: 0
                , mass: 10
            })
            , new Point({
                 x: 350, y: 200
                , vx: 2, vy: 0
                , radius: 12
                , mass: 12
            })
            , new Point({
                 x: 250, y: 270
                , vx: .4, vy: -1
                , radius: 8
                , mass: 8
            })

        )

        this.dragging.addPoints(...this.points)
        this.dragging.onWheel = this.onWheel.bind(this)
        this.dragging.onDragStart = this.onDragStart.bind(this)
        this.dragging.onDragEnd = this.onDragEnd.bind(this)

        this.restLength = 100;
        this.springConstant = .6;
        this.dampingFactor = 0.92; // Adjust this value between 0 and 1

    }

    onDragStart(ev, p) {
        this.dragPoint = p
    }

    onDragEnd(ev, p) {
        this.dragPoint = undefined
    }

    onWheel(ev, p) {
        p.mass = p.radius
    }

    draw(ctx){
        this.clear(ctx)

        let mouse = Point.mouse.position
        let ps = this.points;
        let sv = this.dragPoint != undefined? [this.dragPoint]: [];
        const lockedPoints = new Set(sv)//ps[0]]); // Lock pointA in place

        const rLen = this.restLength
        const springConstant = this.springConstant
        const damping = this.dampingFactor
        const deltaTime = 1

        ps[0].spring.to(ps[1], rLen, springConstant, damping, lockedPoints, deltaTime)
        ps[1].spring.to(ps[2], rLen, springConstant, damping, lockedPoints, deltaTime)
        ps[2].spring.to(ps[0], rLen, springConstant, damping, lockedPoints, deltaTime)

        this.points.pen.indicators(ctx)

    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: spring-draggable-bound-2-point.js
================================================================================



================================================================================
FILE: spring-draggable-bound-main.js
================================================================================

/*
title: Spring Forces Distributed With Time
tags: springs
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js


*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                 x: 150, y: 230
                , radius: 10
                , vx: .1, vy: 0
                , mass: 10
            })
            , new Point({
                 x: 350, y: 200
                , vx: 2, vy: 0
                , radius: 12
                , mass: 12
            })
            , new Point({
                 x: 250, y: 270
                , vx: .4, vy: -1
                , radius: 8
                , mass: 8
            })
        )

        this.dragging.addPoints(...this.points)
        this.dragging.onWheel = this.onWheel.bind(this)
        this.dragging.onDragStart = this.onDragStart.bind(this)
        this.dragging.onDragEnd = this.onDragEnd.bind(this)

        this.restLength = 100;
        this.springConstant = .6;
        this.dampingFactor = 0.99; // Adjust this value between 0 and 1

    }

    onDragStart(ev, p) {
        this.dragPoint = p
    }

    onDragEnd(ev, p) {
        this.dragPoint = undefined
    }

    onWheel(ev, p) {
        p.mass = p.radius
    }

    draw(ctx){
        this.clear(ctx)

        let mouse = Point.mouse.position
        let ps = this.points;
        let sv = this.dragPoint != undefined? [this.dragPoint]: [];
        const lockedPoints = new Set(sv)//ps[0]]); // Lock pointA in place


        const restLength = this.restLength
        const springConstant = this.springConstant
        const dampingFactor = this.dampingFactor
        const deltaTime = .1
        const f = applySpringForceDistributedWithTime
        // const f = applySpringForceDistributed
        // const f = applySpringForce //applySpringForceDistributed
        f(ps[0], ps[1], restLength, springConstant, dampingFactor, lockedPoints, deltaTime);
        f(ps[1], ps[2], restLength, springConstant, dampingFactor, lockedPoints, deltaTime);
        f(ps[2], ps[0], restLength, springConstant, dampingFactor, lockedPoints, deltaTime);

        // this.points.last().rotation += 2
        this.points.pen.indicators(ctx)

    }


================================================================================
END: spring-draggable-bound-main.js
================================================================================



================================================================================
FILE: spring-draggable-manual-bound-point.js
================================================================================

/*
title: Spring Draggable Manual Bound Point
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js


moved to functions/springs

*/

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                 x: 150, y: 230
                , radius: 10
                , vx: .1, vy: 0
                , mass: 10
            })
            , new Point({
                 x: 350, y: 200
                , vx: 2, vy: 0
                , radius: 12
                , mass: 12
            })
            , new Point({
                 x: 250, y: 270
                , vx: .4, vy: -1
                , radius: 8
                , mass: 8
            })
        )

        this.points = PointList.generate.random(4, 1, {x: 200, y:200})
        this.points.each.update({vx:0, vy:0, mass:10});

        this.dragging.addPoints(...this.points)
        this.dragging.onWheel = this.onWheel.bind(this)
        this.dragging.onDragStart = this.onDragStart.bind(this)
        this.dragging.onDragEnd = this.onDragEnd.bind(this)

        this.restLength = 100;
        this.springConstant = .6;
        this.dampingFactor = 0.92; // Adjust this value between 0 and 1
        this.deltaTime = .9;
    }

    onDragStart(ev, p) {
        this.dragPoint = p
    }

    onDragEnd(ev, p) {
        this.dragPoint = undefined
    }

    onWheel(ev, p) {
        p.mass = p.radius
    }

    draw(ctx){
        this.clear(ctx)

        let mouse = Point.mouse.position
        let ps = this.points;
        let sv = this.dragPoint != undefined? [this.dragPoint]: [];
        const lockedPoints = new Set(sv)//ps[0]]); // Lock pointA in place

        const rLen = this.restLength
        const springConstant = this.springConstant
        const damping = this.dampingFactor
        const deltaTime = this.deltaTime

        // ps.spring.loop(rLen, springConstant, damping, lockedPoints, deltaTime)
        this.springsManual(this.points)

        this.points.pen.indicators(ctx)
    }

    springsManual(ps){


================================================================================
END: spring-draggable-manual-bound-point.js
================================================================================



================================================================================
FILE: spring-ml-shape.js
================================================================================

/*
title: Spring Ml Shape
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/collisionbox.js


moved to functions/springs */

addButton('Add', {
    onclick() {
        let p = new Point({
             x: 280, y: 290
            , vx: 0, vy: 0
            , radius: 8
            , mass: 5
        })

        stage.points.push(p)

        // p.spring.to(ps.last(), rLen, springConstant, damping, lockedPoints, deltaTime)

    }
})

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){

        this.toEdges = true
        this.stack = [
                3, 5, 3
            ]

        this.createNet()

        // this.points = new PointList(
        //     new Point({
        //          x: 150, y: 230
        //         , radius: 10
        //         , vx: .1, vy: 0
        //         , mass: 5
        //     })
        //     , new Point({
        //          x: 350, y: 200
        //         , vx: 2, vy: 0
        //         , radius: 8
        //         , mass: 5
        //     })
        //     , new Point({
        //          x: 250, y: 270
        //         , vx: .4, vy: -1
        //         , radius: 8
        //         , mass: 5
        //     })
        // )

        // this.dragging.addPoints(...this.points)
        // this.dragging.onWheel = this.onWheel.bind(this)
        // this.dragging.onDragStart = this.onDragStart.bind(this)
        // this.dragging.onDragEnd = this.onDragEnd.bind(this)

        this.restLength = 40;
        this.springConstant = .6;
        this.dampingFactor = 0.92; // Adjust this value between 0 and 1

        // this.collisionBox = new CollisionBox(this.points)
    }

    createNet(stack=this.stack){
        let spreadY = 50
            , spreadX = 150
        let top = 100
            , left = 100

        let points = []
            , maxVal = Math.max.apply(Math, stack)
            ;

        for(let stackItem of stack) {


================================================================================
END: spring-ml-shape.js
================================================================================



================================================================================
FILE: spring-point-collisions.js
================================================================================

/*
title: Graph Chain Follow Points V3
categories: springs
    graph
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    point
    stage
    mouse
    ../point_src/graph-connections.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    ../point_src/functions/springs.js
    ../point_src/velocity.js
    stroke

---

In this version the pair callback method - tests for visits.

---

The `followPoint` method allows a point to _follow_ another point, at a distance.
This is a lot like constraints but with a _one to one_ relationship in a single
direction.

This _graph chain_ stores those one to one relationships, with methods to iterate
the chain in two directions. This allows use to grab the standard `A -> B -> C`,
and `C -> B -> A`.

The graph can resolve a "star based" configuration:

    A      C
      \   /
        B
        |
        D
        |
        E

Each connection is given in a pair, from an origin node (the `head`)

    head = B

    B -> C
    B -> D [ -> E ]
    D -> E
    B -> A
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
/*        this.points = new PointList(
            new Point(250, 150, 10)
            , new Point(400, 320, 10)
            , new Point(300, 520, 8)

            , new Point(340, 580, 8)
            , new Point(380, 520, 8)

            , new Point(410, 520, 8)
            , new Point(450, 520, 8)

            , new Point(430, 520, 8)
            , new Point(400, 520, 8)
        )
*/
        this.points = new PointList(
            new Point({x:250, y:150, radius:10, vx: .1, vy: 0, mass: 1 })
            , new Point({x:400, y:320, radius:10, vx: .1, vy: 0, mass: 1 })
            , new Point({x:300, y:520, radius:8, vx: .1, vy: 0, mass: 1 })

            , new Point({x:340, y:580, radius:8, vx: .1, vy: 0, mass: 1 })
            , new Point({x:380, y:520, radius:8, vx: .1, vy: 0, mass: 1 })

            , new Point({x:410, y:520, radius:8, vx: .1, vy: 0, mass: 1 })
            , new Point({x:450, y:520, radius:8, vx: .1, vy: 0, mass: 1 })

            , new Point({x:430, y:520, radius:8, vx: .1, vy: 0, mass: 1 })
            , new Point({x:400, y:520, radius:8, vx: .1, vy: 0, mass: 1 })
        )

        this.collisionBox = new CollisionBox(this.points)
        this.g = new GraphConnections;

        this.head = 0

        this.g.connect(0, 1, 2, 3, 4)
        this.g.connect(2, 5)
        this.g.connect(5, 6, 7, 8)

        this.dragging.add(...this.points)


================================================================================
END: spring-point-collisions.js
================================================================================



================================================================================
FILE: spring-popon.js
================================================================================

/*
title: Spring Popon
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/collisionbox.js


moved to functions/springs */

addButton('Add', {
    onclick() {
        let p = new Point({
             x: 280, y: 290
            , vx: 0, vy: 0
            , radius: 8
            , mass: 5
        })

        stage.points.push(p)

        // p.spring.to(ps.last(), rLen, springConstant, damping, lockedPoints, deltaTime)

    }
})

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                 x: 150, y: 230
                , radius: 10
                , vx: .1, vy: 0
                , mass: 5
            })
            , new Point({
                 x: 350, y: 200
                , vx: 2, vy: 0
                , radius: 8
                , mass: 5
            })
            , new Point({
                 x: 250, y: 270
                , vx: .4, vy: -1
                , radius: 8
                , mass: 5
            })
        )

        this.dragging.addPoints(...this.points)
        this.dragging.onWheel = this.onWheel.bind(this)
        this.dragging.onDragStart = this.onDragStart.bind(this)
        this.dragging.onDragEnd = this.onDragEnd.bind(this)

        this.restLength = 20;
        this.springConstant = .6;
        this.dampingFactor = 0.92; // Adjust this value between 0 and 1

        this.collisionBox = new CollisionBox(this.points)
    }

    onDragStart(ev, p) {
        this.dragPoint = p
    }

    onDragEnd(ev, p) {
        this.dragPoint = undefined
    }

    onWheel(ev, p) {
        p.mass = p.radius
    }

    draw(ctx){
        this.clear(ctx)

        this.collisionBox.shuffle()
        let mouse = Point.mouse.position
        let ps = this.points;
        let sv = this.dragPoint != undefined? [this.dragPoint]: [];


================================================================================
END: spring-popon.js
================================================================================



================================================================================
FILE: spring-rope-to-rope-gravity.js
================================================================================

/*
title: Spring Rope To Rope Gravity
categories: springs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/automouse.js
    ../point_src/functions/springs.js
    ../point_src/functions/clamp.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/rope.js
    ../point_src/collisionbox.js
    ../point_src/gravity.js
    */

const stringLength = 200

const heavyStep = function(followPoint, mouse, gravity,
                           damping=.9, dotDamping=.2, forceMultiplier=.1, forceValue=undefined) {
    // Apply gravity to the follow point's vertical velocity
    // Calculate the vector from the mouse to the follow point
    // let dx = followPoint.x - mouse.x ;
    // let dy = followPoint.y - mouse.y ;
    let dx = mouse.x - followPoint.x;
    let dy = mouse.y - followPoint.y;

    // Calculate the current distance between the follow point and the mouse
    let distance = Math.sqrt(dx * dx + dy * dy);

    // Set the follow point's position to be exactly on the circumference of the string length
    // const force = (distance - stringLength) * 0.01; // Tweak this factor as needed

    // If the distance exceeds the string length, we need to constrain the follow point
    if (distance > stringLength) {

        // Normalize the direction vector
        dx /= distance;
        dy /= distance;

        if(dotDamping!==false) {
            // Adjust the velocity so that it reflects the string tension
            let dotProduct = (followPoint.vx * dx + followPoint.vy * dy) * dotDamping;
            followPoint.vx -= dotProduct * dx;
            followPoint.vy -= dotProduct * dy;
        }

        if(forceMultiplier!==false){
            const force = forceValue? forceValue: (distance - stringLength) * forceMultiplier; // Tweak this factor as needed
            followPoint.vx += force * dx;
            followPoint.vy += force * dy;
        }

    }

    // Apply gravity
    if(gravity){
        followPoint.vy += gravity.y;
        followPoint.vx += gravity.x;
    }

    // Update the follow point's position based on its velocity
    followPoint.x += followPoint.vx;
    followPoint.y += followPoint.vy;

    if(damping) {
        // Apply damping continuously to smooth the motion
        followPoint.vx *= damping;
        followPoint.vy *= damping;
    }
};



class Balloon {

    defaults = {
            // gravity: .2
            gravity: {x:.01, y: -.03}
            , visibleRopeGravity: {x:0, y:0.02}
            , ropePointLength: 20
            , segmentLength: 10
            , invMass: .3
            , color: '#990000'
            , knotColor: '#225555'
            , ropeColor: '#AAA'
            , radius: 10
            // , position: [1,1]


================================================================================
END: spring-rope-to-rope-gravity.js
================================================================================



================================================================================
FILE: squares-ngon-box.js
================================================================================

/*
---
title: Simple Box Examples
categories: rectangles
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/protractor.js
    mouse
    dragging
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/angle.js
    ../point_src/text/label.js
 */


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.a = new Point({x:200, y:200, radius: 100, rotation: -90})
        this.b = new Point({x:200, y:300, radius: 100, rotation: -90})
        this.c = new Point({x:400, y:400, radius: 100, rotation: -90})
        this.d = new Point({x:300, y:400, radius: 100, rotation: -90})
        this.e = new Point({x:400, y:400, radius: 100, rotation: -90})
        this.f = new Point({x:400, y:400, radius: 100, rotation: -90})

        this.dragging.add(
            this.a,
            this.b,
            this.c,
            this.d,
            this.e,
            this.f,
            )
        // this.a.rotation -= 20
    }

    draw(ctx){
        this.clear(ctx)
        let a = this.a
        let b = this.b
        let c = this.c
        let d = this.d
        let e = this.e
        let f = this.f

        // a.rotation = b.rotation = c.rotation = d.rotation = e.rotation = f.rotation -= .1

        // a.pen.ngon(ctx, 4, a.radius * 1.4, true, '#eee', 2, degToRad(a.rotation))
        // a.pen.circleGon(ctx, 100, .01, true)
        // a.pen.arc(ctx, this.b, 'red', 100, 2)

        // a.pen.circle(ctx, undefined, '#333', 1)
        a.pen.indicator(ctx, {color: '#333'})
        /* An ngon can be projected and rotated.*/
        a.pen.ngon(ctx, 4, a.radius, true, '#33AAEE', 2, degToRad(a.rotation))

        ctx.strokeStyle = 'yellow'

        b.pen.indicator(ctx, {color: '#333'})

        /* A plain box */
        b.pen.box(ctx)

        c.pen.indicator(ctx, {color: '#333'})

        c.pen.box(ctx, undefined, undefined, undefined, a.radians)

        // d.pen.indicator(ctx, {color: '#333'})
        // d.pen.rect(ctx, undefined, undefined, '#880000', 2)

        // e.pen.indicator(ctx, {color: '#333'})
        // e.pen.rect(ctx, undefined, undefined, '#880000', 2, {
        //                 x: (e.radius) * -.5
        //                 , y: (e.radius) * -.5
        //             })

        // f.pen.indicator(ctx, {color: '#333'})

        // f.pen.rect(ctx, e.radius, e.radius * .5, '#880000', 2, {
        //                 x: e.radius * -.5
        //                 , y: e.radius * -.25
        //             })

        // d.pen.line(ctx, undefined, 'red')
        // a.pen.indicator(ctx)
        // ctx.fill()
    }
}


;stage = MainStage.go();

================================================================================
END: squares-ngon-box.js
================================================================================



================================================================================
FILE: squirqle.js
================================================================================

/*
title: Curve Circle (Egg bezierFactor)
categories: curve
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/stage-clock.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/curve-extras.js
    ../point_src/split.js
    ../point_src/angle.js

---

 */

function bezierFactor(count) {
    // Formula: factor = (4/3) * tan( ( / 2) / count )
    return (4 / 3) * Math.tan(Math.PI / (2 * count));
}


class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        this.generate()
        this.dragging.add(...this.points)
        this.lineStroke = new Stroke({
            color: '#fff'
            , width: 2
            , dash: [7, 4]
        })

        this.events.wake()
    }

    generate(count=4, radius=100) {
        let factor = bezierFactor(count)
        let size = radius * factor
        let p = this.center.copy().update({radius})
        this.point = this.center.copy().update({radius: radius - 5})
        let rot = Angle.from(1/4).turns

        /* Split on a point, returns many points around the radius. */
        const _splits = p.split(count, rot.rad)
        _splits.each.radius = size

        let lines = this.lines = []
        let length = _splits.length;

        /* Generate a new list of points, 2 points per line*/
        let res = new PointList;

        /* Generate many curves. connecting pairs. */
        for (var i = 0; i < length; i++) {
            let nextValue = i + 1;
            if(nextValue == length) {
                nextValue = 0 // wrap around.
            }
            let o = _splits[nextValue].copy()
            let a = _splits[i].copy()
            o.rotation += 180
            let line = new BezierCurve(a, o)
            res.push(a, o)
            lines.push(line)
        }

        this.points = res;
        return res
    }

    draw(ctx){
        this.clear(ctx)
        let col = {color: '#336600'}
        // this.points.pen.indicator(ctx, {color: '#336600'})
        let mouse = this.mouse.position
        this.points.forEach((p)=>{
            let d = p.distanceTo(mouse) * .2
            let td = d
            p.radius = 150 - (clamp(td, -90, 90))
        })
        let lineStroke = this.lineStroke
        lineStroke.set(ctx)


================================================================================
END: squirqle.js
================================================================================



================================================================================
FILE: stacks.js
================================================================================

/*
title: Stacks
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/random.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/automouse.js


*/

class Stack {
    /*


    let st = new Stack()
    let one = st.add('one')
    let two = st.add('two')
    let three = st.add('three')
    let four = st.add('four')

        // value == four
        console.log(st.remove(three), st.value())
        // value == four
        console.log(st.remove(one), st.value())
        // value == two
        console.log(st.remove(four), st.value())

    Useful for things like cursor stacks.

     */
    constructor() {
        this.map = new Map;
        this.keys = [];
    }
    add(data) {
        let id = random.string()
        this.map.set(id, data)
        this.keys.push(id)
        return id
    }

    value() {
        let keys = this.keys
        let _top = keys[keys.length - 1]
        return this.map.get(_top)
    }

    remove(id) {
        let data = this.map.get(id)
        this.map.delete(id)
        let keys = this.keys
        let _top = keys[keys.length - 1]

        if(_top == id) {
            // back-stack is required
            this.destack()
        }
        return data
    }

    destack(){
        // rebuild the keys list
        let map = this.map
        let res = [];
        this.keys.forEach((k)=> map.has(k) && res.push(k))
        this.keys = res
    }
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.generate(4)
        this.dragging.addPoints(...this.points)//, ...this.la, ...this.lb)
        // this.dragging.onDragEnd = this.onDragEnd.bind(this)
        // this.dragging.onDragMove = this.onDragMove.bind(this)
        // this.dragging.onWheel = this.onWheel.bind(this)
    }

    generate(pointCount=3){
        /* Generate a list. In this random... */
        this.points = PointList.generate.radius(pointCount, 100, point(200,200))


================================================================================
END: stacks.js
================================================================================



================================================================================
FILE: stage-auto-events.js
================================================================================

/*
category: events
title: Stage Auto Events
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    // autoEvents = true /* Default */

    mounted(){
        this.point = new Point(300, 300, 20)
        // this.events.wake()
    }

    onClick(ev) {
        this.clickPoint = Point.from(ev)
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.circle(ctx, {color:'#eee'})
        this.clickPoint && this.clickPoint.pen.fill(ctx, '#880000')
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: stage-auto-events.js
================================================================================



================================================================================
FILE: stage-center-example.js
================================================================================

/*
category: center
title: Stage Center Example
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js


 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.center.radius = 50
    }

    draw(ctx){
        this.clear(ctx)

        let c = this.center
        c.lookAt(Point.mouse.position)
        c.pen.indicator(ctx, {color:'green'})
    }
}

stage = MainStage.go()



================================================================================
END: stage-center-example.js
================================================================================



================================================================================
FILE: stage-example.js
================================================================================

/*
title: Stage Example
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/random.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/setunset.js
    ../point_src/stroke.js

 */
const canvas = document.getElementById('playspace');
// const ctx = canvas.getContext('2d');
// Point.mouse.listen(canvas)

var randomPoints;
var comPoint;
var weightedComPoint;
/* A basic setup for the small points. */
const rawPointConf = { circle: { color: 'orange', width: 1}}
let stage;


const automain = function(){
    stage = new MainStage()
    stage.prepare(canvas)
    stage.generate();
    // stage.update()
    stage.loopDraw()
    // stage.drawView(ctx)
}


// const update = function() {
//     stage.drawView(ctx)
//     // drawView(ctx)
// }


class MainStage extends Stage {

    generate(pointCount=4){

        /* Generate a list. In this random... */
        randomPoints = PointList.generate.radius(pointCount, 100, point(200,200))

        /* Customise the points, randomising the mass and rotation. */
        randomPoints.forEach(p => {
                // let mass = Math.random() * 10
                let mass = random.int(10)
                p.mass = mass
                p.rotation = random.int(360)
                // p.rotation = Math.random() * 360
                p.radius = Math.max(5, mass)
            })

        /* Call upon the list "center of mass" function */
        comPoint = randomPoints.centerOfMass()
        /* In this case we cater for mass and rotation additions */
        weightedComPoint = randomPoints.centerOfMass('deep')
    }

    draw(ctx){
        this.clear(ctx)
        ctx.beginPath()

        /* Use the pen to draw a simple circle at the Center of Mass.*/
        comPoint.pen.circle(ctx, undefined, 'teal', 3)

        // quickStroke('white', 1, ()=>comPoint.draw.circle(ctx)

        /* Draw an indicator at the _weighted_ Center of Mass. */
        weightedComPoint.pen.indicator(ctx)

        /* Draw a circle at the origin points */
        randomPoints.pen.indicators(ctx, rawPointConf)

        /* Render a line through all the points. When we "draw" (not pen), the
        next action should be a fill or stroke. */
        // randomPoints.draw.pointLine(ctx)
        // quickStroke('yellow', 1)

        // May bleed if not applied.
        ctx.closePath();
    }
}


;automain();


================================================================================
END: stage-example.js
================================================================================



================================================================================
FILE: stage-only.js
================================================================================

/*
title: Just a Stagr
categories: minimal
files:
    head
    ../point_src/stage.js
---

The minimal requirements include the _head_ and _stage_.
*/
class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
    }

    draw(ctx){
        this.clear(ctx)
        // this.points.pen.rect(ctx,{width: 4, color: '#444'})
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: stage-only.js
================================================================================



================================================================================
FILE: stage-stretch.js
================================================================================

/*
title: Stage Stretch
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js

---

A stage will adapt to its global size.

    #playspace {
        height: 100%;
        width: 100%;
        border: solid 1px;
    }

When resizing the page, the `canvas` element dimensions will change.
The Stage will adapt after the resize event.
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.center.radius = 50
    }

    draw(ctx){
        this.clear(ctx)

        let c = this.center
        // c.lookAt(Point.mouse.position)
        c.pen.indicator(ctx, {color:'green'})
    }
}

stage = MainStage.go()


================================================================================
END: stage-stretch.js
================================================================================



================================================================================
FILE: stamping.js
================================================================================

/*
title: Stamping
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    point
    stage
    mouse
    stroke
    ../point_src/emitter.js
    ../point_src/relative.js
    ../point_src/random.js

---
*/

class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        // this.events.wake()

        let e2 = new RandomPointEmitter(400,400, 60)
        // e2.direction = {x:-1, y:0} //inward.
        e2.fromEdge = true
        e2.tickModulo = 1
        e2.speed = .1
        e2.birthrate = 20

        e2.wake()
        this.e2 = e2

        let e3 = new PumpRandomPointEmitter(500,200, 60)
        e3.wake()
        this.e3 = e3

        this.dragging.add(e2, e3)
        // this.dragging.add(this.e1, e2, e3)

        this.stamp = new Stamp()
    }

    firstDraw(ctx){
        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px sans-serif`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
        ctx.strokeStyle = '#EEE'
    }

    draw(ctx){
        this.clear(ctx)

        // this.drawEmitters(ctx)
        this.rawDrawEmitters(ctx)
    }

    rawDrawEmitters(ctx){
        // e.pen.indicator(ctx)
        // e.points.pen.indicators(ctx)

        let e = this.e2;
        e.step()
        const pi2 = Math.PI2
        e.points.forEach(p=>{
            ctx.beginPath()
            const opts = p._opts
            ctx.arc(opts.x, opts.y, 5, 0, pi2)
            ctx.stroke()
        })
        // ctx.arc()
    }

    drawEmitters(ctx) {

        let e = this.e2;
        e.step()
        e.points.pen.stroke(ctx)

    }
}

class Stamp {

    render(ctx, points, func) {
        ctx.save();
        let prev = points[0]
        points.forEach((p)=>{
            // ctx.translate(p.x, p.y)
            let np = p.subtract(prev)
            ctx.translate(np.x, np.y)
            // ctx.rotate(p.radians)
            func(np)
            prev = p
        });


================================================================================
END: stamping.js
================================================================================



================================================================================
FILE: starfield-example.js
================================================================================

/*
title: Simple Starfield
categories: minimal
    starfield
files:
    head
    point
    pointlist
    stroke
    stage
    mouse
    dragging
    ../point_src/random.js
    ../point_src/screenwrap.js
    ../point_src/velocity.js
---

A simple starfield, with recycled points and general _direction_ and _speed_.

*/

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        let pin = new Point(0, 0, 1, 0)
        let pin2 = new Point(0, 0, .1, 0)
        this.points = PointList.generate.random(100, [1200, 800], pin)
        this.pins = PointList.generate.random(20, [1200, 800], pin2)

        this.reactor = new VelocityReactor()
        this.reactor.points = this.points

        // the direction of travel, applied to each points velocity.
        let direction = new Point(3, -.35)

        // this.reactor.randomize()

        this.points.forEach(p=>{
            // circle plot area
            // p.xy = random.within(pin, 600)

            p.velocity.set(direction.multiply(p.radius * -.05))

            let light = 80 * (p.radius * .25)
            p.color = `hsl(200, 70%, ${light}%)`
            p.radius *= 3

            // turn to direction of travel
            faceVelocity(p)
        })
    }

    draw(ctx){
        this.clear(ctx)
        this.reactor.step()
        this.points.forEach(p=>this.screenWrap.perform(p))
        this.pins.pen.fill(ctx, '#666')
        this.points.pen.lines(ctx)
        // this.points.pen.indicator(ctx)
        // this.points.pen.fill(ctx, 'green')
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: starfield-example.js
================================================================================



================================================================================
FILE: stick-figure.js
================================================================================

/*
title: Graph Based Rotation
categories:
    raw
    graph
files:
    head
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    dragging
    pointlist
    point
    stage
    mouse
    ../point_src/graph-connections.js
    ../point_src/constrain-distance.js
    ../point_src/constrain-distance-locked.js
    ../point_src/collisionbox.js
    ../point_src/functions/springs.js
    ../point_src/velocity.js
    stroke

---

Rotating any one point rotates them all.

---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        let midline = this.center.copy()
            , mx = midline.x
            ;

        class BodyPoint extends Point {
            created() {
                if(this._opts.radius != undefined) return;
                this.radius = 8
            }

        }

        this.points = new PointList(
                // name, x, y, radius
              ['head',      mx, 150, 50]
            , ['neck',      400, 180]
            , ['shoulders', mx, 200, 10]
            // arm
            , ['elbow',     mx-20, 220]
            , ['hand' ,     mx, 230]

            // right arm
            , ['elbow',  mx+20, 240]
            , ['hand',   mx+40, 250]

            // left leg
            , ['hips',   mx-20, 260, 15]
            , ['leg' ,   mx-50, 310]

            , ['foot',    mx, 320]
            , ['leg',    mx, 340]
            , ['foot',   400, 520]
        ).cast(BodyPoint, function(arrItem, type){
            let [name, ...xyr] = arrItem
            let o = new type(xyr)
            o.name = name
            return o 
        })

        this.points.update({
            vx: .1, vy: 0, mass: 1
        });
        
        let cb = this.collisionBox = new CollisionBox()
        cb.points.push(this.points[0])
        cb.points.push(this.points[4])
        cb.points.push(this.points[6])
        cb.points.push(this.points[9])
        cb.points.push(this.points[11])
        this.g = new GraphConnections;

        this.head = 0
        this.distances = {}
        let shoulderIndex = this.points.indexOf(this.points.getByName('shoulders'))
        let hipIndex = this.points.indexOf(this.points.getByName('hips'))

        // head neck
        this.g.connect(0, 1)
        this.g.connect(1, shoulderIndex)

        // left arm
        this.g.connect(shoulderIndex, 3, 4)
        // right arm


================================================================================
END: stick-figure.js
================================================================================



================================================================================
FILE: straight-line-connected-main.js
================================================================================

/*
title: Straight Line Connected Main
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/rel.js
    dragging
    ../point_src/constrain-distance.js


Simulate collisions using a _string_. Here we replicate one of those
little balls inside a circle
*/

class Line {
    constructor(p1, p2, color='red', width=1){
        // new Line([90, 130], [200, 300], 420)
        this.a = point(p1)
        this.b = point(p2)
        this.color = color
        this.width = width
    }

    draw(ctx, color=undefined) {
        ctx.beginPath();

        let a = this.a;
        let b = this.b;
        ctx.moveTo(a[0], a[1])
        ctx.strokeStyle = color == undefined? this.color: color
        ctx.lineWidth = this.width == undefined? 1: this.width
        ctx.lineTo(b[0], b[1])

        ctx.stroke()
    }
}


const randomPoints = PointList.generate.random(4, 200)


const UNSET = {}


const quickStroke = function(ctx, color='green', lineWidth=UNSET) {
    ctx.strokeStyle = color
    if(lineWidth != UNSET) {
        ctx.lineWidth = lineWidth
    }
    ctx.stroke()
}


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        let cumX = 0
            , cumOffset = 120
            , globalY = 100
            , offset = ()=> cumX+=cumOffset
            , c = this.compass
            ;

        this.points = new PointList(
            new Point({
                name: "a"
                , rotation: c.right
                , x: offset(), y: globalY
            })
            , new Point({
                name: "b"
                , rotation: c.left // RIGHT_DEG
                , x: offset(), y: globalY + 50
            })
        )

        this.points.setMany(20, 'radius');

        this.line = new Line([100, 200], [200, 200], 'green', 2)

    }


    draw(ctx){
        this.clear(ctx)

        // this.line.draw(ctx)
        this.drawPoints(ctx)


================================================================================
END: straight-line-connected-main.js
================================================================================



================================================================================
FILE: stroke-example.js
================================================================================

/*
    title: Stroke Example
    categories: strokes
    files:
        ../point_src/logging/logger.js
        ../point_src/math.js
        ../point_src/core/head.js
        ../point_src/pointpen.js
        ../point_src/pointdraw.js
        ../point_src/point-content.js
        ../point_src/pointlist.js
        ../point_src/point.js
        ../point_src/events.js
        ../point_src/automouse.js
        ../point_src/stage.js
        ../point_src/extras.js
        ../point_src/random.js
        ../point_src/distances.js
        ../point_src/functions/clamp.js
        ../point_src/dragging.js
        ../point_src/setunset.js
        ../point_src/stroke.js

 */
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true

    mounted(){
        this.pa = new Point(150, 150, 100, 90)

        this.lineStroke = new Stroke({
            color: 'green'
            , width: 5
            , dash: [7, 4]
            , march: .3
        })

    }

    draw(ctx){
        this.clear(ctx)
        let pos = this.mouse.position
        pos.pen.circle(ctx)

        let lineStroke = this.lineStroke

        lineStroke.step()
        lineStroke.set(ctx)
        this.pa.pen.indicator(ctx)
        lineStroke.unset(ctx)

    }
}

;stage = MainStage.go();

================================================================================
END: stroke-example.js
================================================================================



================================================================================
FILE: subdivide.js
================================================================================

/*
---
title: Subdivide
categories: subdivide
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/distances.js
    ../point_src/dragging.js
    stroke
---

To subdivide a grid of points, by adding additional points _between_ existing
points, essentially splitting a _quad_ into smaller quads.

This should work on 4 points, and a large grid of points.
*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    defaultRowCount = 10
    rowCount = 20
    spread = 40
    mounted(){
        /*this.points = new PointList(
                [20, 20]
                , [20, 120]
                , [120, 20]
                , [120, 120]
            ).cast()*/
        // this.dragging.add(...this.points)
        /* point count, row count, point spread (px) */
        this.reset()
        console.log("Points length == 40", this.points.length, this.points.length == 40)

        addButton('subdivide', {
            onclick(){
                stage.doSubdivide()
            }
        })

        addButton('reset', {
            onclick(){
                stage.reset()
            }
        })
    }

    doSubdivide(){
        let points = this.points
        let rowCount = this.rowCount
        this.points = subdivideA(points, rowCount)
        const newRowCount = rowCount + (rowCount-1)
        this.points.shape.grid(parseInt(this.spread * .5), newRowCount)
        this.rowCount = newRowCount
    }

    reset(){
        this.rowCount = this.defaultRowCount
        let ps = this.points = PointList.generate.grid(this.rowCount * this.rowCount, this.rowCount, this.spread)
        ps.each.color = '#666'
        // this.points = subdivideA(points, rowCount)
        this.tool = this.points.generate.getGridTool()
    }

    draw(ctx){
        this.clear(ctx)
        // let pos = this.mouse.position
        // pos.pen.circle(ctx)
        this.points.pen.fill(ctx)
        // this.points.forEach(p=>p.pen.fill(ctx))
    }
}

const _subdivide = function(split = 1, mutate = true) {
  /*
    Subdivide all cells (quads) in the grid.

    For each quad (defined by 4 original grid points), we compute five candidate
    points (center, and the four edge midpoints). To avoid duplicate insertions
    we choose to add only a subset based on the cell's position.

    For example, in a 44 grid (4 rows, 4 cols, 16 points) there are 9 cells.
    With the rules below the 9 cells produce 24 new points. When merged with the
    original 16 points, this yields a total of 40.

    If `mutate` is true, the new points are pushed into the grid's point list.
    Otherwise, the new points are returned.
  */



================================================================================
END: subdivide.js
================================================================================



================================================================================
FILE: sun.js
================================================================================

/*
title: Planets
files:
    ../point_src/core/head.js
    ../point_src/pointlistpen.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/bisector.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/rotate.js
    ../point_src/stage.js
    ../point_src/gradient.js
    ../point_src/json.js
    ../point_src/text/alpha.js
    ../point_src/text/label.js
 */

const arcLine = function(ctx, points) {
    ctx.beginPath();
    // midPoint.pen.indicator(ctx)

    let startPoint = points[0]

    ctx.moveTo(startPoint.x, startPoint.y);

    let previousPoint = startPoint;
    let pl = points.length;

    // debugger;
    for (var i = 0; i < pl; i++) {
        let p = points[i]
        // if(previousPoint) {
            // if(i == pl-1) {
                // end point
                // ctx.lineTo(p.x, p.y);
            // } else {
                let toPoint = p;
                let r = previousPoint.radius
                ctx.arcTo(previousPoint.x, previousPoint.y, toPoint.x, toPoint.y, r);
            // }
        // }
        previousPoint = p
        // this.drawArc(ctx, midPoint, pointC, pointD)
    }
    let last = points[pl-1]
    ctx.lineTo(last.x, last.y);

    // ctx.stroke();
}

/*
Mercury #1a1a1a Yes it is really that dark

Venus #e6e6e6 or perhaps a bit darker

Earth tricky as it is a mix of colors, and changes over the yea
r seems to average out as about #2f6a69

Mars #993d00

Jupiter #b07f35

Saturn #b08f36

Uranus #5580aa

Neptune #366896
const planetColors = [
    { planet: "Mercury", color: "#918E85" },
    { planet: "Venus", color: "#EEDDAA" },
    { planet: "Earth", color: "#7EC8E3" },
    { planet: "Mars", color: "#D14A28" },
    { planet: "Jupiter", color: "#C6906E" },
    { planet: "Saturn", color: "#D9C48B" },
    { planet: "Uranus", color: "#7FD1B9" },
    { planet: "Neptune", color: "#2C4D97" },
    { planet: "Pluto", color: "#B2A393" }
];
 */

const settings = {
    zoom: .0006
    // Pixel distance per planet
    // if sun AU is not a factor
    // , distanceMultiplier: 150

    // if au is a factor
    , distanceMultiplier: .16

}



================================================================================
END: sun.js
================================================================================



================================================================================
FILE: svg-example.js
================================================================================

/*
title: SVG Example
categories: svg
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    mouse
    dragging
    stroke
    ../theatre/a.js
---

 */


var newSVG = function(id, parent) {
    let home = parent || 'body'
    //let $svg = $("<svg/>", )
    let $svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    $svg.id = id
    $svg.setAttribute('height', 0)
    $svg.setAttribute('width', 0)
    // document.querySelector(home).appendChild($svg)

    return $svg;
}



let pathSetPathFunction = function(d) {
    /* Apply as `path.setPath` as a helper to set the `d` attribute of a
    Path node.
     */
    this.setAttribute('d', d)
    return d
}



const newNode = function(type='path', id, p){
    let nsUri = "http://www.w3.org/2000/svg"
    var $node = document.createElementNS(nsUri, type); //Create a path in SVG's namespace
    $node.id = id
    $node.setPath = pathSetPathFunction
    $node.setPath(getInitD(p)); //Set path's data
    $node.style.stroke = "#000"; //Set stroke colour
    $node.style.strokeWidth = "5px"; //Set stroke width
    return $node
}

const getInitD = function(p){
    let width = p.radius
        , rad = width*2
        , neg_rad = -rad
        // , a = this.coords.a
        , a = p
        ;

        let arc = commands.arc;
    // debugger;
    let b = [
        `M ${a.x}, ${a.y}`
        , ` m -${width}, 0`
        , ` ${arc.rel} ${width}, ${width} 0 1, 0 ${rad}, 0`
        , ` ${arc.rel} ${width}, ${width} 0 1, 0 -${rad}, 0`
    ].join('')

    return b
}

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 , radius: 20, rotation: 45})
        this.dragging.add(this.point)
        this.svg = newSVG('new-svg')

        this.svg.setAttribute('height', 300)
        this.svg.setAttribute('width', 400)
        this.canvas.parentElement.appendChild(this.svg)

        let path = newNode('path', 'foobar', this.point)
        this.svg.appendChild(path)
    }

    onMousedown(ev) {
        // this.iPoint.rotation = random.int(180)
        commands.move(...this.point.xy)
    }



================================================================================
END: svg-example.js
================================================================================



================================================================================
FILE: svg-path-data.js
================================================================================

/*
categories: svg
title: SVG Path Data
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/image.js

---

Load vector commands (SVG commands) as a path using `PathData`.

The instance has a data and a point, used for position, scale, and rotation.

    const path = new PathData("M395.065.638c-.445...")

    path.position.rotation += 1
    path.draw(ctx)
    path.position.pen.circle(ctx)

*/

let path = `M395.065.638c-.445-.068-2.723-.343-3.789.907a2.37,2.37,0,0,0-.344,
            2.4.49.49,0,0,1-.032.436,3.829,3.829,0,0,1-2.1,
            1.154c-.027.006-.046.024-.072.032a9.326,9.326,0,0,0-6.309-2.092,
            10.548,10.548,0,0,0-7.077,3.135l-8.115,8.115c-4,4-4.2,10.293-.457,
            14.036a9.252,9.252,0,0,0,6.6,2.679A10.55,10.55,0,0,0,380.8,
            28.3l8.114-8.114a10.061,10.061,0,0,0,1.32-13.018,4.693,4.693,
            0,0,0,2.4-1.8,2.482,2.482,0,0,0,
            .2-2.039c-.086-.268-.082-.441-.042-.488a3.093,3.093,0,0,1,1.968-.229,
            1,1,0,1,0,.3-1.977ZM382.486,5.469c.1,0,.2,0,.294,0a7.257,7.257,0,0,
            1,4.808,1.763l-3.531,3.531a1.473,1.473,0,0,
            0-1.685.235l-.976.975-4.281-4.281A8.508,8.508,0,0,1,
            382.486,5.469Zm-.53,8.84a.462.462,0,0,1-.634,0l-.11-.109a.45.45,
            0,0,1,0-.634l1.867-1.866a.46.46,0,0,1,.632,0l.111.111a.448.448,
            0,0,1,0,.633Zm-2.568,12.576c-3.218,3.217-8.247,
            3.419-11.209.457s-2.759-7.992.457-11.208l7.756-7.755,4.3,
            4.3-.184.184a1.451,1.451,0,0,0,0,2.048l.11.109h0a1.452,1.452,0,0,
            0,2.048,0l.183-.184,4.3,4.3Zm8.446-8.479-4.28-4.281.975-.975a1.442,
            1.442,0,0,0,.424-1.024,1.414,1.414,0,0,
            0-.185-.666l3.525-3.525A7.951,7.951,0,0,1,387.834,18.406Z`

class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.path = new PathData(path)
        this.dragging.add(this.path.position)
    }

    draw(ctx){
        this.clear(ctx)
        this.path.position.rotation += 1
        this.path.position.pen.circle(ctx)
        this.path.draw(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: svg-path-data.js
================================================================================



================================================================================
FILE: tangent-2.js
================================================================================

/*
title: Tangent 2
categories: tangents
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/tangents.js

 */

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.rawPointConf = { circle: { color: 'orange', width: 1}}
        this.generate()
        this.doLines()
        // this.dragging.add(...this.randomPoints)
        this.dragging.addPoints(...this.points)//, ...this.la, ...this.lb)
        // this.dragging.onDragEnd = this.onDragEnd.bind(this)
        this.dragging.onDragMove = this.onDragMove.bind(this)
        this.dragging.onWheel = this.onWheel.bind(this)
    }

    generate(pointCount=3){
        /* Generate a list. In this random... */
        this.points = PointList.generate.radius(pointCount, 100, point(200,200))
        /* Customise the points, randomising the mass and rotation. */
        this.points.forEach(p => {
                // p.rotation = Math.random() * 360
                p.radius = Math.max(5, 20)
            })
    }

    doLines() {
        // let lines = calculateAdjustedRotatedTangentLines(...this.points)
        let a = this.points[0]
        let b = this.points[1]
        let c = this.points[2]

        this.lines = [
             this.asPointList(a.tangent.outerLines(b))
            , this.asPointList(b.tangent.outerLines(c))
            , this.asPointList(c.tangent.outerLines(a))
        ]

    }

    asPointList(tLines) {

        return [new PointList(
            new Point(tLines.a[0])
            , new Point(tLines.a[1])
        )
        , new PointList(
            new Point(tLines.b[0])
            , new Point(tLines.b[1])
        )]
    }

    onDragEnd(){
        this.doLines()
    }

    onDragMove(){
        this.doLines()
    }

    onWheel(ev, p) {
        this.doLines()
    }

    draw(ctx){
        this.clear(ctx)
        this.drawView(ctx)
        this.dragging.getPoint()?.pen.circle(ctx)
    }

    drawView(ctx){
        /* Draw a circle at the origin points */
        ctx.strokeStyle = '#555'
        ctx.lineWidth = 2
        this.points.pen.stroke(ctx)
        // this.others.pen.indicators(ctx, this.rawPointConf)


================================================================================
END: tangent-2.js
================================================================================



================================================================================
FILE: tangent-3.js
================================================================================

/*
title: Tangent 3
categories: tangents
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/tangents.js

 */

class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        let a = this.a = new Point(200, 200, 90)
        let b = this.b = new Point(600, 200, 100)
        this.updateLines(a,b)
        this.dragging.add(a,b)
        this.rLength = 70
    }

    updateLines(a=this.a, b=this.b){
        this.dragging.onDragMove = this.onDragMove.bind(this)
        // this.dragging.onDragEnd = this.onDragEnd.bind(this)

        this.updateTangents(a,b)

        // this.updateArcs(a, b)
        this.updateArcs2(a, b)
    }

    updateTangents(a,b){
        this.lineAA = PointList.from(a.tangent.aa(b)).cast()
        this.lineBB = PointList.from(a.tangent.bb(b)).cast()
        this.lineAB = PointList.from(a.tangent.ab(b)).cast()
        this.lineBA = PointList.from(a.tangent.ba(b)).cast()
    }

    updateArcs2(a, b){
        // this.c1 = calculateInnerArcTangents(a, b, this.rLength, 1)
        this.c1 = calculateConvexInnerArcTangents(a, b, this.rLength, 1)

        // this.c1 = calculateExternalArcTangents(a, b, this.rLength, 1)

    }

    updateArcs(a, b){
        this.c1 = calculateConcaveArcTangents(b, a, this.rLength, 0)
        this.c2 = calculateConcaveArcTangents(b, a, this.rLength, 1)

        this.c3 = calculateConcaveArcTangents(a, b, this.rLength, 0)
        this.c4 = calculateConcaveArcTangents(a, b, this.rLength, 1)

        // this.lineArcAB = PointList.from(this.c.ab).cast()

        // this.arcA = new Point(c.center.x,c.center.y, c.radius)
    }

    onDragMove(ev) {
        this.updateLines()
    }

    draw(ctx){
        this.clear(ctx)
        this.a.pen.circle(ctx, undefined, 'green', 2)
        this.b.pen.circle(ctx, undefined, 'green', 2)
        // this.lineAA.pen.line(ctx, {color:'#999', width: 3})
        // this.lineBB.pen.line(ctx, {color:'#4433DD', width: 3})
        // this.lineAB.pen.line(ctx, {color:'#DD6688', width: 3})
        // this.lineBA.pen.line(ctx, {color:'#DD6688', width: 3})
        // this.arcA.pen.indicator(ctx)

        this.drawArcUnit(ctx, this.c1, 'pink')
        this.drawArcUnit(ctx, this.c2, 'pink')

        this.drawArcUnit(ctx, this.c3, '#666')
        this.drawArcUnit(ctx, this.c4, '#666')

        // this.arcA.pen.indicator(ctx)

        // arc(x, y, radius, startAngle, endAngle, counterclockwise)
        // ctx.fillStyle = '#999'
        ctx.strokeStyle = '#AAA'
        if(this?.c1?.tangentA){
            Point.from(this.c1.tangentA).pen.indicator(ctx)


================================================================================
END: tangent-3.js
================================================================================



================================================================================
FILE: tangent-arc-concave.js
================================================================================

/*
title: Tangent Arc Concave
categories: tangents
files:
    head
    point
    stroke
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/curve-extras.js
    ../point_src/mirror.js
    ../point_src/stage.js
    ../point_src/text/label.js
    ../point_src/intersections.js


 */


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = new Point({x:200,y:300, radius:70})
        this.pointB = new Point({x:500,y:300, radius:100})
        this.dragging.addPoints(this.pointA, this.pointB)
        // this.events.wake()

        this.lines = []
        this.rLength = 200
    }

    draw(ctx){
        this.clear(ctx)

        let a = this.pointA;
        let b = this.pointB;

        let ts = getTangents(a,b, this.rLength)

        if(ts == undefined) {
            a.pen.indicator(ctx)
            b.pen.indicator(ctx, {color: this.pointB.color})
            return
        }

        return this.drawArcs(ctx, ts)
    }

    drawArcs(ctx, ts){
        let a = this.pointA;
        let b = this.pointB;

        let color = 'green'
        let [t1, t2] = ts.a
        let [t3, t4] = ts.b

        /* Touch points. */
        t1.pen.fill(ctx, color) // top left
        t2.pen.fill(ctx, color) // bottom left
        t3.pen.fill(ctx, color) // top right
        t4.pen.fill(ctx, color) // bottom left

        // c.pen.circle(ctx, undefined, '#777')
        // d.pen.circle(ctx, undefined, '#777')

        /* The two primary indicators. */
        a.pen.indicator(ctx)
        b.pen.indicator(ctx)

        /* The straight lines to the protractor points.*/
        ts.lines.forEach(l=>l.render(ctx))

        ctx.strokeStyle = 'yellow'
        /* draw an arc, with the origin at o4,
        then from the end point, to the start point (because we're sweeping
        backward).
        get the angle of the origin to t2 (left),
        then get the angle of origin to t4 (right). */

        let o4 = ts.o4
            , o3 = ts.o3
            , r3 = ts.r3
            ;
        const t2Angle = twoPointsAngle(o4, t2)
        const t4Angle = twoPointsAngle(o4, t4)
        ctx.beginPath()
        ctx.arc(o4.x, o4.y, r3, t4Angle, t2Angle, 1);

        ctx.stroke()
        ctx.beginPath()

        const t3Angle = twoPointsAngle(o3, t3)
        const t1Angle = twoPointsAngle(o3, t1)
        ctx.arc(o3.x, o3.y, r3, t1Angle, t3Angle, 1);


================================================================================
END: tangent-arc-concave.js
================================================================================



================================================================================
FILE: tangent-arc-convex.js
================================================================================

/*
title: Tangent Arc Convex
categories: tangents
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/angle.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/curve-extras.js
    ../point_src/mirror.js
    ../point_src/stage.js
    ../point_src/intersections.js
    ../point_src/tangents.js

 */


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.pointA = new Point({x:200,y:300, radius:70})
        this.pointB = new Point({x:500,y:300, radius:100})
        this.dragging.addPoints(this.pointA, this.pointB)
        // this.events.wake()

        this.lines = []
        this.rLength = 400
    }

    draw(ctx){
        this.clear(ctx)

        let a = this.pointA;
        let b = this.pointB;

        let ts = arcTangents(a, b, this.rLength, 0)

        if(ts == undefined) {
            /* No tangents - too far away. */
            a.pen.indicator(ctx)
            b.pen.indicator(ctx, {color: this.pointB.color})
            return
        }

        /* The points.*/
        a.pen.indicator(ctx)
        b.pen.indicator(ctx)

        /* The big protractor angles.*/
        ts.c?.pen.indicator(ctx, {color:'#333'})
        ts.d?.pen.indicator(ctx, {color:'#333'})

        /* Tangent start and end points. */
        ts.n.forEach(p=>p.pen.indicator(ctx,'orange'))

        ctx.strokeStyle = 'yellow'

        /* draw an arc, with the origin at o4,
        then from the end point, to the start point (because we're sweeping
        backward).
        get the angle of the origin to t2 (left),
        then get the angle of origin to t4 (right). */
        let origin0 = ts.origin0
            , origin1 = ts.origin1
            , sharedRadius = ts.sharedRadius
            , p0Rads = ts.n[0].radians
            , p1Rads = ts.n[1].radians
            , p2Rads = ts.n[2].radians
            , p3Rads = ts.n[3].radians
            ;

        ctx.beginPath()
        // ctx.arc(origin0.x, origin0.y, sharedRadius, p1Rads, p0Rads, 1);
        origin0.draw.arc(ctx, sharedRadius, p1Rads, p0Rads, 1);
        // origin0.draw.arc(ctx, sharedRadius, p0Rads, p1Rads, 0);
        ctx.stroke()

        ctx.beginPath()
        // ctx.arc(origin1.x, origin1.y, sharedRadius, p2Rads, p3Rads, 1);
        origin1.draw.arc(ctx, sharedRadius, p2Rads, p3Rads, 1);
        ctx.stroke()

        ctx.strokeStyle = 'grey'

        origin1 && (origin1).pen.fill(ctx, '#CC00BB')
        origin0 && (new Point(origin0)).pen.fill(ctx, '#CC00BB')
    }
}



================================================================================
END: tangent-arc-convex.js
================================================================================



================================================================================
FILE: tangent-derivative.js
================================================================================

/*
---
title: Split
categories: tangents
files:
    ../point_src/math.js
    head
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    pointlist
    ../point_src/point.js
    mouse
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    dragging
    stroke
    ../point_src/split.js
    ../point_src/curve-extras.js
    ../point_src/iter/alpha.js
    ../point_src/text/beta.js
    ../point_src/velocity.js
*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.point = new Point(300, 400, 100)
        this.count = 20
        this.offset = undefined
        let lpoints3 = [new Point(100, 300, 400, 50), new Point(500, 300, 200, 250)]
        this.curve = new BezierCurve(...lpoints3)
        this.dragging.add(this.point, ...lpoints3)

        this.tick = 0

        addControl('tangent', {
            type: 'range'
            , field:  'input'
            , stage: this
            , onchange(ev) {
                /*slider changed. */
                // debugger;
                let sval = ev.currentTarget.value
                this.stage.offset = parseFloat(sval) * .01
            }
        })


        this.tl = new Point(100, 100)
        this.spot = new Point(100, 200)
        let v = this.spot.velocity
        v.x = 1
        v.y = 1
    }

    draw(ctx){
        this.clear(ctx)

        let pos = this.mouse.position
        pos.pen.circle(ctx)

        // let v = this.lerper.step(1)
        let offset = this.offset

        if(offset == undefined) {
            offset = Math.sin((this.tick++ * .005) % Math.PI)
        }

        let l = this.curve
        let ps = l.points
        ps.pen.indicators(ctx, {color:'#333'})
        l.render(ctx, {color: 'green'})
        l.getControlPoints().forEach(p=>p.pen.fill(ctx, 'darkred'))

        let {dx,dy} = this.getDerivative(l, offset)
        let theta = Math.atan2(dy, dx)
        let spot = this.plotPoint(l, offset, theta)

        spot.pen.fill(ctx, 'purple')
        let p = new Point(200, 300, 40)
        p.xy = spot.project(30).xy
        p.radians = theta

        let wt = `${dx.toFixed(2)}, ${dy.toFixed(2)}, ${theta.toFixed(1)}`
        this.tl.text.string(ctx, wt)
        p.pen.indicator(ctx)
        // this.curve.splitInner(this.count, degToRad(0)).pen.indicators(ctx)
        // this.curve.splitHinted(this.count).pen.indicators(ctx, {color:'red'})
    }

    getDerivative(curve, offset){
        // let { dx, dy } = get_bezier_derivative(l.a, ...l.getControlPoints(), l.b, offset)
        return get_bezier_derivative(
                curve.a
                , ...curve.getControlPoints()
                , curve.b
                , offset


================================================================================
END: tangent-derivative.js
================================================================================



================================================================================
FILE: tangent.js
================================================================================

/*
title: Tangent
categories: tangents
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/setunset.js
    ../point_src/stroke.js

---

https://www.youtube.com/watch?v=m1zmWiboxzU
 */

function calculateEdgeToEdgeLine(pointA, pointB) {
    // Destructure points
    const { x: x1, y: y1, radius: r1 } = pointA;
    const { x: x2, y: y2, radius: r2 } = pointB;

    // Calculate the distance between the centers
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Normalize the direction
    const nx = dx / dist;
    const ny = dy / dist;

    // Calculate the edge points by moving along the direction vector scaled by the radius
    const pointAEdge = {
        x: x1 + nx * r1,
        y: y1 + ny * r1
    };
    const pointBEdge = {
        x: x2 - nx * r2,
        y: y2 - ny * r2
    };

    return { pointAEdge, pointBEdge };
}


function rawCalculateAdjustedRotatedTangentLines(pointA, pointB) {
    const { x: x1, y: y1, radius: r1 } = pointA;
    const { x: x2, y: y2, radius: r2 } = pointB;

    // Calculate distance between centers
    const dx = x2 - x1;
    const dy = y2 - y1;
    const dist = Math.sqrt(dx * dx + dy * dy);

    // Normalize the direction vector
    const nx = dx / dist;
    const ny = dy / dist;

    // Calculate the angle between the points
    const angle = Math.atan2(dy, dx);

    const extra = 0// -Math.PI
    // Calculate the angle offset to adjust for size differences
    const angleOffset = (-Math.asin((r1 - r2) / dist) ) + extra || 0;

    // Rotate the direction vectors by +90 and -90 degrees (perpendicular) based on the relative angle
    const perpNx1 = Math.cos(angle + Math.PI / 2 + angleOffset);
    const perpNy1 = Math.sin(angle + Math.PI / 2 + angleOffset);

    const perpNx2 = Math.cos(angle - Math.PI / 2 - angleOffset);
    const perpNy2 = Math.sin(angle - Math.PI / 2 - angleOffset);

    // Calculate the tangent points for both sides of pointA (adjusted with angle)
    const lineA1 = {
        x: x1 + perpNx1 * r1,
        y: y1 + perpNy1 * r1
    };
    const lineA2 = {
        x: x1 + perpNx2 * r1,
        y: y1 + perpNy2 * r1
    };

    // Calculate the tangent points for both sides of pointB (adjusted with angle)
    const lineB1 = {
        x: x2 + perpNx1 * r2,
        y: y2 + perpNy1 * r2
    };
    const lineB2 = {
        x: x2 + perpNx2 * r2,
        y: y2 + perpNy2 * r2


================================================================================
END: tangent.js
================================================================================



================================================================================
FILE: tethered-point.js
================================================================================

/*
title: Tethered Controller Point
categories: binding
files:
    head
    point
    pointlist
    mouse
    stage
    dragging
    ../point_src/distances.js
    ../point_src/tethers.js
    ../point_src/stage-clock.js
---

You can "tether" two points, such that the _parent_ will manipulate the child.
This is a _semi-hierarchical link_ or I prefer to say 1.5 directional from
parent to child.

*/


class MainStage extends Stage {
    canvas='playspace'
    live = true

    mounted(){
        // this.createPoints()
        // this.dragging.add(...this.points, ...this.controlPoints)
        this.point = new Point(200, 200, 100)
        let cp = this.point.tethers.add({ x: 100, y: 50})
        this.dragging.add(this.point, cp)
    }

    draw(ctx){
        this.clear(ctx)
        if(this.clock.tick % 1 == 0) {
            this.point.tethers.step()
        }

        this.point.pen.indicator(ctx, {color: '#336600'})
        this.point.tethers.points.pen.fill(ctx, '#33DDAA')
    }
}



;stage = MainStage.go();

================================================================================
END: tethered-point.js
================================================================================



================================================================================
FILE: tethered-poly.js
================================================================================

/*
title: Tethered Controller Point
categories: binding
files:
    head
    point
    pointlist
    mouse
    stage
    dragging
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/tethers.js
    ../point_src/stage-clock.js
    stroke
---

*/
addButton('Add Point',{
    onclick(){
        stage.addNewPoint()
    }
})


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        // this.createPoints()
        // this.dragging.add(...this.points, ...this.controlPoints)
        this.point = new Point(200, 200, 100)
        this.dragging.add(this.point)
        this.addNewPoint()
        this.addNewPoint()
    }

    addNewPoint() {
        let pos = random.within(this.point, 1)
        let cp = this.point.tethers.add(pos)
        this.dragging.add(cp)
    }

    draw(ctx){
        this.clear(ctx)
        let p = this.point
        let ps = p.tethers.points
        if(this.clock.tick % 1 == 0) {
            p.tethers.step()
        }

        p.pen.indicator(ctx, {color: '#336600'})
        ps.forEach((tp)=>{
            p.pen.line(ctx, tp, '#880000', 2)
        });

        // p.tethers.points.pen.fill(ctx, '#33DDAA')
        ps.pen.indicator(ctx, '#33DDAA')
        ps.pen.quadCurve(ctx, {color: '#33DDAA', loop: true})
    }
}



;stage = MainStage.go();

================================================================================
END: tethered-poly.js
================================================================================



================================================================================
FILE: text-aligned-example.js
================================================================================

/*
title: Text Aligned Example
categories: collisions
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    stroke
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/text/beta.js


*/
let rotationPoint = new Point(300, 300)


class MainStage extends Stage {
    canvas = 'playspace'
    rot = 0

    mounted(){
        this.points = new PointList(
                  [200, 300, 10, 170]
                , [200, 400, 10, 0]
                , [200, 400, 10, 0]
                , [240, 200, 10, 0]
            ).cast()
        this.dragging.add(...this.points)
    }

    firstDraw(ctx) {
        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px inter`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
    }

    draw(ctx){
        this.clear(ctx)

        let ps = this.points;

        ps.pen.indicators(ctx)


        // p.lerp(pB).text.fill(ctx, "Fill Label")
        // p.lerp(pB).text.string(ctx, "String Label")
        let tp = ps[0].midpoint(ps[1])
        tp.lookAt(ps[1])
        tp.text.label(ctx, "Label Label")

        ps[0].pen.line(ctx, ps[1])
        ps[2].pen.line(ctx, ps[3])
        let tp2 = ps[2].midpoint(ps[3])
        tp2.text.label(ctx, "Label Label")
        /* A label, with offset. */
        ps[0].text.label(ctx, "label Label")

        ps[2].midpoint(ps[3], .3).text.string(ctx, "String Label")

    }

}


;stage = MainStage.go()

================================================================================
END: text-aligned-example.js
================================================================================



================================================================================
FILE: text-class-example-2.js
================================================================================

/*
title: TextAlpha Class
categories: text
files:
    head
    point
    pointlist
    stroke
    stage
    mouse
    dragging
    ../point_src/point-content.js
    ../point_src/text/alpha.js
    ../point_src/random.js
*/

class LogoText extends TextAlpha {
    text = 'POLYPOINT'
    fontSize = 120
    // fontName = "Noto Sans"
    fontWeight = 400
    generateGrad() {
        let pos = this.position
        let gradient = this.ctx.createLinearGradient(
                    pos.x,
                    pos.y,
                    pos.x + this.width,
                    pos.y + this.fontSize
                )
        gradient.addColorStop(0, "hsl(299deg 62% 44%)");
        gradient.addColorStop(1, "hsl(244deg 71% 56%)");
        return gradient
    }

    writeText(fillStyle=this.generateGrad(), ctx=this.ctx){
        ctx.fillStyle = fillStyle
        ctx.strokeStyle = fillStyle // 'hsl(244deg 12% 60%)'
        ctx.lineWidth = 1
        // ctx.lineCap = 'round'
        ctx.lineJoin = 'bevel'
        // ctx.lineJoin = 'round'
        this.configureCtx(ctx)
        let pos = this.position
        // ctx.fillText(this.text, pos.x, pos.y)

        ctx.fillText(this.text, pos.x, pos.y)
        // ctx.strokeText(this.text, pos.x, pos.y)
    }

}


class MainStage extends Stage {
    rot = 0
    canvas = 'playspace'

    mounted(){
        this.p1 = new Point(400, 200)
        let h = new LogoText(this.ctx)
        h.position = new Point(400, 200)
        this.logo = h;
    }

    draw(ctx){
        this.clear(ctx)
        let h = this.logo
        this.p1.draw.circle(ctx)
        let p = this.p1
        // ctx.fill()
        ctx.ellipse(p.x, p.y, 100, 100, 0, 0, Math.PI2, true)
        h.writeText()
    }
}


stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: text-class-example-2.js
================================================================================



================================================================================
FILE: text-class-example.js
================================================================================

/*
title: TextAlpha Class
categories: text
files:
    head
    ../point_src/point-content.js
    point
    pointlist
    stage
    ../point_src/text/alpha.js
*/
const canvas = document.getElementById('playspace');
// const ctx = canvas.getContext('2d');
// Point.mouse.listen(canvas)

let stage;


const automain = function(){
    stage = new MainStage()
    stage.prepare(canvas)
    stage.loopDraw()

}

let rotationPoint = new Point(300, 300)


class HyperwayLogo extends TextAlpha {
    text = 'HYPERWAY'
    fontSize = 50
    _letterSpacing = undefined //'normal'

    constructor(ctx, t) {
        super(ctx, t)
    }

    set letterSpacing(v){
        this._letterSpacing = v
    }

    get letterSpacing() {

        if(this._letterSpacing == undefined) {
            return `${this.fontSize*.333}px`
        }

        return this._letterSpacing
    }

    generateGrad() {
        let pos = this.position
        let gradient = this.ctx.createLinearGradient(
                    pos.x,
                    pos.y,
                    pos.x + this.width,
                    pos.y + this.fontSize
                )

        gradient.addColorStop(0,"hsl(299deg 62% 44%)");
        gradient.addColorStop(1,"hsl(244deg 71% 56%)");
        return gradient
    }

    writeText(fillStyle, ctx){
        if(fillStyle == undefined) {
            fillStyle = this.generateGrad()
        }
        return super.writeText(fillStyle, ctx)
    }

}


class MainStage extends Stage {
    rot = 0

    mounted(){
        let h = new HyperwayLogo(this.ctx)
        h.position = new Point(0, 0)
        h.rotation = degToRad(10)
        // let t = new Text(ctx, 'Bananas')
        // t.position = new Point(100, 100)
        // t.writeText('red')
        this.logo = h;
    }

    draw(ctx){

        this.clear(ctx)
        let p = new Point(200, 200)
        p.pen.circle(ctx)
        let rot = this.rot++
        let h = this.logo
        ctx.save();

        // pos.pen.circle(ctx)
        ctx.translate(200, 300)
        // Spin the text to the desired rotation.
        ctx.rotate(h.rotation)


================================================================================
END: text-class-example.js
================================================================================



================================================================================
FILE: text-example-2.js
================================================================================

/*
title: Follow
categories: text
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    mouse
    dragging
    stroke
    ../point_src/random.js
    ../point_src/text/beta.js
---

 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 , radius: 100})
        this.point2 = new Point({x: 150, y: 150 , radius: 50})
        this.dragging.add(this.point,this.point2)
    }

    onMousedown(ev) {
        this.point.rotation = random.int(360)
        this.point2.rotation = random.int(360)
    }

    draw(ctx){
        this.clear(ctx)
        ctx.strokeStyle = ctx.fillStyle = '#ddd'
        ctx.font = '22px sans-serif'

        this.point.pen.indicator(ctx)
        this.point.text.string(ctx, 'text.string')

        this.point2.pen.indicator(ctx)
        this.point2.text.label(ctx, 'text.label', {x:10, y:10})

    }
}


stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: text-example-2.js
================================================================================



================================================================================
FILE: text-example-raw.js
================================================================================

/*
title: Text Example Raw
categories: text
files:
    ../point_src/point-content.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/text/alpha.js



 */
const canvas = document.getElementById('playspace');
// const ctx = canvas.getContext('2d');
// Point.mouse.listen(canvas)

let stage;


const automain = function(){
    stage = new MainStage()
    stage.prepare(canvas)
    stage.loopDraw()

}

let rotationPoint = new Point(300, 300)

class MainStage extends Stage {
    rot = 0
    draw(ctx){

        this.clear(ctx)
        let p = new Point(200, 200)
        p.pen.circle(ctx)
        let rot = this.rot++

        let fontSize = 50

        // The 'posisition' of the text. Notice its 0,0
        // as later we tranlate to a point. The tranlation _point_
        // performs a rotation around this origin.
        let pos = new Point(0, 0)
        let words = "HYPERWAY"

        let txtWidth = ctx.measureText(words).width;
        let fillStyle = this.generateGrad(ctx, pos, txtWidth, fontSize) // "#ff00ff"

        ctx.save();

        // The lef|Center|right anchor point of the text.
        ctx.textAlign="center";
        // Top|middle|bottom anchor of the text.
        // ctx.textBaseline="middle";
        ctx.textBaseline="middle";
        ctx.translate(rotationPoint.x, rotationPoint.y);

        // Draw the anchor of the text.
        // This is center center, due to the textBasline
        pos.pen.circle(ctx)

        // Spin the text to the desired rotation.
        ctx.rotate(Math.PI/2 + (rot * .02))

        // Render after the position manipulation.
        this.writeText(ctx, words, pos, fontSize, fillStyle)

        // Undo the translate and continue.
        ctx.restore();
    }

    generateGrad(ctx, pos, width, fontSize) {
        let gradient = ctx.createLinearGradient(pos.x, pos.y, width, fontSize)

        gradient.addColorStop(0,"hsl(299deg 62% 44%)");
        gradient.addColorStop(1,"hsl(244deg 71% 56%)");
        return gradient
    }

    writeText(ctx, words, pos, fontSize, fillStyle){
        ctx.font = `500 ${fontSize}px lexend deca`;
        ctx.letterSpacing  = `${fontSize*.333}px`;
        // ctx.letterSpacing  = `.335em`;
        ctx.fillStyle = fillStyle;
        ctx.fillText(words, pos.x, pos.y);
    }
}


;automain();


================================================================================
END: text-example-raw.js
================================================================================



================================================================================
FILE: text-simple-example.js
================================================================================

/*
title: Text Simple Example
categories: text
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/functions/clamp.js
    ../point_src/dragging.js
    ../point_src/text/beta.js


*/
let rotationPoint = new Point(300, 300)


class MainStage extends Stage {
    canvas = 'playspace'
    rot = 0

    mounted(){
        this.pointA = new Point(200, 300, 40, 170)
        this.pointB = new Point(200, 400, 20, 0)
        this.pointC = new Point(200, 400, 20, 0)
        this.dragging.add(this.pointA, this.pointB, this.pointC)
    }

    draw(ctx){
        this.clear(ctx)

        let p = this.pointA;
        let pB = this.pointB;
        let pC = this.pointC;

        let fontSize = p.radius * .5

        ctx.fillStyle = '#EEE'
        ctx.font = `400 ${fontSize}px inter`;
        ctx.textAlign = 'left' // center
        ctx.textBaseline = 'middle'

        p.rotation += .5

        let pad = fontSize
        let x = p.radius + pad

        p.text.fill(ctx, "Fill Label", {x, y: 0})

        /* A label, with offset. */
        p.text.label(ctx, "label Label", {x, y: 0, radians: 0})


        p.pen.indicator(ctx, undefined, 'red')

        ctx.textAlign = 'center'
        ctx.font = `400 14px sans-serif`;

        pB.rotation -= .5

        pB.pen.circle(ctx, undefined, 'red')
        pB.text.offsetString(ctx, "offsetString", {x:0, y: 0, radians: 0})

        ctx.textAlign = 'right'
        pC.pen.circle(ctx, undefined, 'red')
        pC.text.offsetString(ctx, "offsetString", {x:-pC.radius - pad, y: 0, radians: 0})

        // pC.rotation -= .5
        ctx.textAlign = 'left'
        pC.text.offsetString(ctx, "offsetString", {x:pC.radius + pad, y: 0, radians: 0})
    }

}


;stage = MainStage.go()

================================================================================
END: text-simple-example.js
================================================================================



================================================================================
FILE: three-point-drawarc.js
================================================================================

/*
title: Three Point Drawarc
categories: arcs
    raw
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js

*/

class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        // this.point = new Point(50, 50)
        const r = 200
        const shareSize = 15
        this.center.radius = r
        this.point0 = this.center.add(-r, 0)
        this.midPoint = this.center.add(0, r * -.5)
        this.midPoint.radius = 20

        this.point1 = this.center.add(r, 0)

        this.point0.radius = this.point1.radius = shareSize
        this.point0.color = "hsl(299deg 62% 44%)"
        this.point1.color = "hsl(244deg 71% 56%)"

        this.near = this.center.copy()
        this.regenerateGradient()

        // this.dis = new Distances
        // this.dis.addPoints(this.center, this.point0, this.point1)
        this.dis = new Dragging
        this.dis.initDragging(this)
        this.dis.onDragMove = this.onDragMove.bind(this)
        this.dis.onDragEnd = this.onDragEnd.bind(this)
        this.dis.addPoints(this.point0, this.midPoint, this.point1)

    }

    regenerateGradient() {
        this.grad = this.generateGrad(this.ctx, this.point0, this.point1)
    }

    drawArc(ctx, startPoint, midPoint, endPoint, r=midPoint.radius) {
      ctx.beginPath();
      ctx.moveTo(startPoint.x, startPoint.y);
      ctx.arcTo(midPoint.x, midPoint.y, endPoint.x, endPoint.y, r);
      ctx.lineTo(endPoint.x, endPoint.y);
      ctx.stroke();
    }

    draw(ctx){
        this.clear(ctx)

        this.drawCircles(ctx)
        ctx.strokeStyle = 'green'
        ctx.lineWidth = 3
        this.drawArc(ctx, this.point0, this.midPoint, this.point1)
        this.drawIris(ctx)

    }

    drawOriginal(ctx){
        this.clear(ctx)
        let fillstyle = this.grad
            , lineWidth = 3
            ;

        // this.center.pen.fill(ctx, this.grad)
        // this.center.pen.indicator(ctx, {color: '#fff', width: 1})
        // this.point0.pen.line(ctx, this.point1, '#ffffff22', 2)

        // The left and right line.
        // this.point0.pen.fill(ctx, '#111')
        // this.point1.pen.fill(ctx, '#111')


        /* primary straight line*/
        this.point0.pen.line(ctx, this.midPoint, fillstyle, lineWidth)
        this.midPoint.pen.line(ctx, this.point1, fillstyle, lineWidth)

        this.drawCircles(ctx)
    }

    drawCircles(ctx) {
        // let fillstyle = this.grad


================================================================================
END: three-point-drawarc.js
================================================================================



================================================================================
FILE: three-point-line.js
================================================================================

/*
title: Three Point Line
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js


 */

class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        // this.point = new Point(50, 50)
        const r = 200
        const shareSize = 15
        this.center.radius = r
        this.point0 = this.center.add(-r, 0)
        this.midPoint = this.center.add(0, r * -.5)
        this.midPoint.radius = 20

        this.point1 = this.center.add(r, 0)

        this.point0.radius = this.point1.radius = shareSize
        this.point0.color = "hsl(299deg 62% 44%)"
        this.point1.color = "hsl(244deg 71% 56%)"

        this.near = this.center.copy()
        this.regenerateGradient()

        // this.dis = new Distances
        // this.dis.addPoints(this.center, this.point0, this.point1)
        this.dis = new Dragging
        this.dis.initDragging(this)
        this.dis.onDragMove = this.onDragMove.bind(this)
        this.dis.onDragEnd = this.onDragEnd.bind(this)
        this.dis.addPoints(this.point0, this.midPoint, this.point1)

    }

    regenerateGradient() {
        this.grad = this.generateGrad(this.ctx, this.point0, this.point1)
    }

    draw(ctx){
        this.clear(ctx)

        this.drawLine(ctx)
        this.drawIris(ctx)
        this.drawCircles(ctx)
    }

    drawLine(ctx){
        this.clear(ctx)
        let fillstyle = this.grad
            , lineWidth = 3
            ;

        // this.center.pen.fill(ctx, this.grad)
        // this.center.pen.indicator(ctx, {color: '#fff', width: 1})
        // this.point0.pen.line(ctx, this.point1, '#ffffff22', 2)

        /* Each point color*/
        this.point0.pen.fill(ctx, '#111')
        this.point1.pen.fill(ctx, '#111')


        /* line to point (twice) */
        this.point0.pen.line(ctx, this.midPoint, fillstyle, lineWidth)
        this.midPoint.pen.line(ctx, this.point1, fillstyle, lineWidth)
    }

    drawCircles(ctx) {
        // let fillstyle = this.grad
        let fillstyle = "#333" // this.grad
            , lineWidth = 3
            ;

        // outer circle
        this.midPoint.pen.circle(ctx, undefined, fillstyle, lineWidth)


        this.point0.pen.circle(ctx, undefined, fillstyle, lineWidth)
        this.point1.pen.circle(ctx, undefined, fillstyle, lineWidth)

        this.drawIris(ctx)

    }



================================================================================
END: three-point-line.js
================================================================================



================================================================================
FILE: three-point-tangent-arc.js
================================================================================

/*
title: Three Point Tangent Arc
categories: arcs
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js

*/

class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        // this.point = new Point(50, 50)
        const r = 200
        const shareSize = 15
        this.center.radius = r
        this.point0 = this.center.add(-r, 0)
        this.midPoint = this.center.add(0, r * -.5)
        this.midPoint.radius = 20

        this.point1 = this.center.add(r, 0)

        this.point0.radius = this.point1.radius = shareSize
        this.point0.color = "hsl(299deg 62% 44%)"
        this.point1.color = "hsl(244deg 71% 56%)"

        this.near = this.center.copy()
        this.regenerateGradient()

        // this.dis = new Distances
        // this.dis.addPoints(this.center, this.point0, this.point1)
        this.dis = new Dragging
        this.dis.initDragging(this)
        this.dis.onDragMove = this.onDragMove.bind(this)
        this.dis.onDragEnd = this.onDragEnd.bind(this)
        this.dis.addPoints(this.point0, this.midPoint, this.point1)

    }

    regenerateGradient() {
        this.grad = this.generateGrad(this.ctx, this.point0, this.point1)
    }

    draw(ctx){
        this.clear(ctx)

        this.drawLine(ctx)
        this.drawIris(ctx)
        this.drawCircles(ctx)
    }

    drawLine(ctx){
        this.clear(ctx)
        let fillstyle = this.grad
            , lineWidth = 3
            ;

        // this.center.pen.fill(ctx, this.grad)
        // this.center.pen.indicator(ctx, {color: '#fff', width: 1})
        // this.point0.pen.line(ctx, this.point1, '#ffffff22', 2)

        /* Each point color*/
        this.point0.pen.fill(ctx, '#111')
        this.point1.pen.fill(ctx, '#111')


        /* line to point (twice) */
        this.point0.pen.line(ctx, this.midPoint, fillstyle, lineWidth)
        this.midPoint.pen.line(ctx, this.point1, fillstyle, lineWidth)
    }

    drawCircles(ctx) {
        // let fillstyle = this.grad
        let fillstyle = "#333" // this.grad
            , lineWidth = 3
            ;

        // outer circle
        this.midPoint.pen.circle(ctx, undefined, fillstyle, lineWidth)


        this.point0.pen.circle(ctx, undefined, fillstyle, lineWidth)
        this.point1.pen.circle(ctx, undefined, fillstyle, lineWidth)

        this.drawIris(ctx)

    }



================================================================================
END: three-point-tangent-arc.js
================================================================================



================================================================================
FILE: throw-old.js
================================================================================

/*
title: Point Collision with Mass and Rotation
categories: collisions
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/automouse.js
---

 */
// Function to convert angle to velocity vector
function angleToVelocity(theta, speed) {
  return {
    x: speed * Math.cos(theta),
    y: speed * Math.sin(theta)
  };
}

class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.a = new Point({ x: 200, y: 300, av: .1, vx: 1, vy: 0
                            , radius: 40, mass: 20 })
        this.b = new Point({ x: 500, y: 300, av: -.1, vx: .3, vy: 0
                            , radius: 40, mass: 20 })

        this.rotationMultiplier = 30//1-this.clock.delta
        this.friction = 4
        this.bounce = 0
    }

    addMotion(point) {
        /* Update the position of the point based on its velocity */
        point.x += point.vx
        point.y += point.vy
    }

    updatePoints(a,b) {
        a.rotation += a.av * this.rotationMultiplier
        b.rotation -= b.av * this.rotationMultiplier
        this.addMotion(a)
        this.addMotion(b)
    }

    draw(ctx) {
        this.clear(ctx)

        this.handleCollision(this.a, this.b, this.friction, this.bounce)
        this.updatePoints(this.a,this.b)

        // let mp = this.mouse.point
        // this.handleCollision(mp, this.b)

        this.a.pen.indicator(ctx)
        this.b.pen.indicator(ctx)
        // mp.pen.indicator(ctx)
    }

    handleCollision(a,b, mu=1, e=1) {

        // Coefficient of restitution (e)
        // let e = 0 // Perfectly elastic collision

        // Friction calculations
        // let mu = 100; // Coefficient of friction

        // Calculate the distance between the two points
        let dx = b.x - a.x;
        let dy = b.y - a.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        // Check for collision
        if (distance > a.radius + b.radius) {
            return
        }
        // Collision detected

        // Normal vector (unit vector from a to b)
        let nx = dx / distance;
        let ny = dy / distance;

        // Tangent vector (perpendicular to normal)
        let tx = -ny;
        let ty = nx;

        // Moments of inertia (I = 0.5 * m * r^2 for solid disks)
        let m1 = a.mass;
        let m2 = b.mass;


================================================================================
END: throw-old.js
================================================================================



================================================================================
FILE: throw.js
================================================================================

/*
title: Elastic Collision with Friction
categories: collisions
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/relative.js
    ../point_src/keyboard.js
    ../point_src/automouse.js
---

 */
// Function to convert angle to velocity vector
function angleToVelocity(theta, speed) {
  return {
    x: speed * Math.cos(theta),
    y: speed * Math.sin(theta)
  };
}


class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.a = new Point({ x: 200, y: 300, av: .1, vx: 1, vy: 0
                            , radius: 40, mass: 20 })
        this.b = new Point({ x: 500, y: 300, av: -.1, vx: .3, vy: 0
                            , radius: 40, mass: 20 })

        this.rotationMultiplier = 30//1-this.clock.delta
        this.friction = 4
        this.bounce = 0
    }

    addMotion(point) {
        /* Update the position of the point based on its velocity */
        point.x += point.vx
        point.y += point.vy
    }

    updatePoints(a,b) {
        a.rotation += a.av * this.rotationMultiplier
        b.rotation -= b.av * this.rotationMultiplier
        this.addMotion(a)
        this.addMotion(b)
    }

    draw(ctx) {
        this.clear(ctx)

        this.handleCollision(this.a, this.b, this.friction, this.bounce)
        this.updatePoints(this.a,this.b)

        // let mp = this.mouse.point
        // this.handleCollision(mp, this.b)

        this.a.pen.indicator(ctx)
        this.b.pen.indicator(ctx)
        // mp.pen.indicator(ctx)
    }

    handleCollision(a,b, mu=1, e=1) {

        // Coefficient of restitution (e)
        // let e = 0 // Perfectly elastic collision

        // Friction calculations
        // let mu = 100; // Coefficient of friction

        // Calculate the distance between the two points
        let dx = b.x - a.x;
        let dy = b.y - a.y;
        let distance = Math.sqrt(dx * dx + dy * dy);

        // Check for collision
        if (distance > a.radius + b.radius) {
            return
        }
        // Collision detected

        // Normal vector (unit vector from a to b)
        let nx = dx / distance;
        let ny = dy / distance;

        // Tangent vector (perpendicular to normal)
        let tx = -ny;
        let ty = nx;

        // Moments of inertia (I = 0.5 * m * r^2 for solid disks)
        let m1 = a.mass;


================================================================================
END: throw.js
================================================================================



================================================================================
FILE: tiling-1.js
================================================================================

/*
---
title: Spread Line
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/split.js
    ../point_src/jiggle.js
    ../point_src/random.js
---
*/


const range = function(count){
    return Array.from(Array(5).keys())
}

class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.makePl()
        let a = this.a = new Point({x:200,y:200, radius: 50, rotation: 0})
        this.dragging.add(a)
        this.events.wake()
    }

    onClick(){
        this.makePl()
    }

    makePl() {
        this.pls = this.tri(1)
    }

    cubic(rows=5) {
        let generalRadius = 40
        let count  = 10
        let spread  = 100

        let pls = []
        range(rows).forEach((i)=>{
            pls.push(
                this.genList(count, spread, {x: 100, y: 100+(100 * i)})
            )
        })
        return pls;
    }

    tri(rows=5) {
        let generalRadius = 40
        let count  = 10
        let spread  = 100

        let pls = []
        range(rows).forEach((i)=>{
            pls.push(
                this.genList(count, spread, {
                        x: 100+(50 * +( i % 2 == 0))
                        , y: 100+(60 * i)})
            )
        })
        return pls;
    }

    hexa(rows=1) {
        function hexGrid(edgeLength){
            var len = 2*edgeLength - 1,
                vx = Math.sin(Math.PI/6), vy = Math.cos(Math.PI/6),
                tl = edgeLength - 1, br = 3*edgeLength - 2,
                positions = [];

            for(var y = 0; y < len; ++y){
                for(var x = 0; x < len; ++x){
                    //you may want to remove this condition
                    //if you don't understand the code
                    if(x+y < tl || x+y >= br) continue;
                    positions.push({
                        x: vx*y + x,
                        y: vy*y
                    });
                }
            }
            return positions;
        }

        let generalRadius = 40


================================================================================
END: tiling-1.js
================================================================================



================================================================================
FILE: timeit-example.js
================================================================================

/*
title: TimeIt Class Example
categories: clock
    time
files:
    head
    pointlist
    point
    stage
    mouse
    fps
    ../point_src/random.js
    ../point_src/timeit.js

---

The `TimeIt` class helps track time between two calls.

This can be used for anything requiring fairly precise timing at a millisecond range.
See the [easing-example](./easing-example.js) for another demo.
*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.point = new Point({x: 250, y: 150 , radius: 20, rotation: 45})
        this.timer = new TimeIt('Clicker')
    }

    onClick(ev) {
        if(this.timer.running == false) {
            return this.startTime()
        };

        this.stopTime()
    }

    startTime(){
        console.log('start timer')
        this.point.x = random.int(100, 700)
        this.point.y = random.int(100, 700)
        this.timer.start()
        return
    }

    stopTime(){
        this.timer.stop()
        console.log('Stop click', this.timer.toString())
        this.timer.reset()
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.indicator(ctx)
        this.fps.drawFPS(ctx)
        // console.log('draw')
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: timeit-example.js
================================================================================



================================================================================
FILE: timeline-2.js
================================================================================

/*
---
title: Timeline (Second Attempt)
categories: timeline
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/easing.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/iter/lerp.js

    Run a Timeline, with key events.
    I wasn't satified with the other attempt. In this version we do better.

 */

/*
+ A timeline runs a X.fps, until a length.
+ It may cycle at the end
+ keyframe aligned along the timeline for each item:value
+ lerping between values (linear by default.)
+ timeline stepping is per frame tick.
+ because the timeline end is transient, if the timeline loops, the
    _old_ values from the initial set can _lerp_ into the incoming future values;
    the new future can be at 0 index.

 */

const TIMELINE_START = -1
class TimelineBase {

    constructor(stage, target) {
        this.stage = stage
        /* The _point_ if available. */
        this.target = target
        /* The _current_ tick value. A _null_ value is -1
        as 0 is the root keyframe.*/
        this.ticks = TIMELINE_START
        /* Value to _add_ per tick. If -1, the timeline will
        render in reverse. */
        this.tickValue = 1
        /* Every Tip hit, the bounce is +1.*/
        this.bounces = 5

        /* The internal bounce counter. */
        this._bouncesCount = 0

        this.speed = 1

        // bounce, loop, stop
        this.cycle = 'bounce'
        // this.cycle = 'loop'

        this.tickFunction = ()=>{}
        this.keyframeMap = new NestedMap

        this.setup()
    }

    setup() {}

    perform(ctx) {
        /* Run _perform_ at every draw, performing a step if enabled */
        this.tickFunction.apply(this, arguments)
    }

    step() {
        this.ticks += (this.tickValue * this.speed);
    }

    start() {
        this.running = true
        console.log('start timeline')
        this.tickFunction = this.step.bind(this)
    }

    stop() {
        this.tickFunction = ()=>{}
        this.running = false
        console.log('stop timeline')
    }

    reset(){
        this.ticks = TIMELINE_START
        this.tickValue = 1
        this._bouncesCount = 0
    }

    toggleRunning() {
        if(this.running) {
            return this.stop()


================================================================================
END: timeline-2.js
================================================================================



================================================================================
FILE: timeline-example.js
================================================================================

/*
---
title: Timeline Example
categories: timeline
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/easing.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
    ../point_src/iter/lerp.js

Run a Timeline, with key events.

 */

/*

Note: I'm unhappy with this. It's too clunky and
complicated with a bug limiting the animation steps
---

A timeline should have keyframes -

    tl = new Timeline()
    tl.add(100, KeyFrame())

The keyframe has a lerpy value steped by the timeline stepper.

    tl.play()

functionally, any key value should be manipulatable.

a keyframe is a function executor.
The timeline has steps. at ~60fps.

The timeline manages time stepping, frame slotting (ordering),
and a intermediate values cache

The keyframe is dedicated to a Point, and its _frame_ values, and a curve method.

The timeline will meet a keyframe and initiate the key values,
set those values on the respective point
and step, resetting the lerp value

    timeline.step() => 50
        point.x = 100

    timeline.step() => 51
        compute line lerp to next.
        set x

---

It should only lerp <_from_ - _to_> - therefore if the keyframe does not exist
before the step time, the timeline does not lerp to the next keyframe.

Instead, the first keyframe "activates" the value, allowing lerping to occur.
If a user wants to lerp into an position, the keyframe should be applied before (e.g index 0).

---

A timeline has a cycle method to apply how the timeline will end and restart

In `cycle` mode, the timeline restarts at 0.

    A -> B -> A -> B  ...

`bounce` reverses the timeline as it hits end and start forever

    A -> B -> B -> A  ...

`reverse` reverse the timeline as it hits end and stop at frame 0

    A -> B -> B -> A

`stop` will end the animation at the last keyframe.

    A -> B

--

this infers a _limit_ to the timeline. By default, it's the _last frame_, however this can be
set to a target, such as 500. Cycling through the exact number.
Animations will end and wait accordindgly.

 */

class OrderedMap extends Map {
    /* A map with _next_ method for numerical keys */

    getNextFrame(){}


================================================================================
END: timeline-example.js
================================================================================



================================================================================
FILE: touch-events.js
================================================================================

/*
title: Touch Events
categories: touch
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/stage-clock.js
    ../point_src/text/alpha.js
    ../point_src/text/fps.js
    ../point_src/functions/clamp.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/rotate.js
---

Detect finger touch events.
*/
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.touches = new Map
    }

    step() {

    }

    onTouchstart(ev){
        let touches = this.touches;
        ev.preventDefault()
        for(let touch of ev.touches) {
            let _id = touch.identifier
            if(touches.has(_id)){
                console.log('Existing touch')
                continue
            }
            let  yOffset = (touch.radiusX * 2) * 4

            let touchPoint = {
                color: colorForTouch(touch)
                , touch
                , yOffset
                , startPoint: new Point({
                    x: touch.pageX
                    , y: touch.pageY - yOffset
                    , radius: touch.radiusX
                    , radians: touch.rotationAngle
                })
                , movePoint: new Point({
                    x: touch.pageX
                    , y: touch.pageY - yOffset
                    , radius: touch.radiusX * touch.force
                    , radians: touch.rotationAngle
                })
            }
            console.log('start', _id)
            touches.set(_id, touchPoint)
            this.lastPoint = touchPoint
        }
    }

    onTouchend(ev){
        let local = this.touches;

        const touches = ev.changedTouches;
        for(let touch of touches) {
            let _id = touch.identifier
            console.log('end', _id)
            local.delete(_id)
        }
    }

    onTouchcancel(ev){
        console.log('onTouchcancel', ev)
    }

    onTouchmove(ev){
        // console.log('onTouchmove', ev)
        let touches = this.touches
        for(let touch of ev.touches) {
            let t = touches.get(touch.identifier)
            t.touch = touch
            t.movePoint.update({
                x: touch.pageX
                , y: touch.pageY  - t.yOffset


================================================================================
END: touch-events.js
================================================================================



================================================================================
FILE: trail.js
================================================================================

/*
title: Trail
categories: emitter
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/text/beta.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/functions/clamp.js
    ../point_src/random.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/stage.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/text/styler.js
    ../point_src/relative.js
    ../point_src/velocity.js
    ../point_src/emitter.js
---
 */
class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = new Point(100, 100, 20)
        this.textPos = new Point(100, 100, 20)

        let e1 = this.e1 = new TrailPointEmitter(400,400, 60)
        e1.wake()
        this.e1 = e1

        this.dragging.add(this.point, this.e1)
    }

    draw(ctx){
        this.clear(ctx)

        let e1 = this.e1
            , point = this.point
            , pointSpeed = point.speed2D
            , direction = pointSpeed.direction()
            , speedFloat = pointSpeed.absFloat()
            , props = [undefined, undefined, point]
            ;


        if(speedFloat > 0){
            props = [direction, speedFloat, point]
        }

        e1.step.apply(e1, props)

        e1.pen.indicator(ctx, '#aaa')
        e1.points.pen.indicator(ctx, undefined, '#aaa')
        // e1.pen.fill(ctx, '#aaa')
        // e1.points.pen.circle(ctx, undefined, '#aaa')

        point.pen.indicator(ctx, '#880000')

        ctx.fillStyle = 'white';
        ctx.font = `500 16px arial`;
        this.textPos.text.fill(ctx, speedFloat)
    }
}


stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: trail.js
================================================================================



================================================================================
FILE: turtle.js
================================================================================

/*
title: Example
categories: basic
    dragging
files:
    head
    point
    pointlist
    stage
    mouse
    dragging
    stroke
    ../point_src/constrain-distance.js
    ../point_src/functions/range.js
    ../point_src/split.js
    ../point_src/relative-xy.js
---

*/


class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    steps() {
        return [
            ['forward', 1] // unit of width
            , ['down']
            , ['rotate', 10] // degree
            , ['forward', 4] // degree
            , ['up'] // degree
            , ['goto', 0]
        ]
    }

    mounted(){
        this.points = new PointList(
                        [250 , 50, 20]
                        // , [250 , 170, 20, -90]
                        // , [250 , 290, 20]
                    ).cast()
        this.dragging.add(...this.points)
        this.stepTick = 0
    }

    draw(ctx){
        this.clear(ctx)
        this.points.pen.indicator(ctx, 'green')
        this.performStep(ctx, this.stepTick++, 20)
    }

    performStep(ctx, tick, stepCount=1) {
        let items = this.steps()
        let item = items[Math.floor(tick % items.length)]
        range(stepCount).forEach(()=>{
            this.performAction(item)
        })
    }

    performAction(item) {
        let func = `${item[0]}_Action`
        let args = item.slice(1,)
        return this[func].apply(this, args)
    }

    forward_Action(distance) {
        let item = this.points.last()
        item.relative.forward(item.radius * 2 * distance)
    }

    down_Action() {
        // let item = this.points.last()
        // item.relative.forward(item.radius * 2 * distance)
    }

    rotate_Action() {}
    forward_Action() {}
    up_Action() {}
    goto_Action() {}
}


stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: turtle.js
================================================================================



================================================================================
FILE: twist-cube.js
================================================================================

/*
---
title: 3D Points
categories: pseudo3D
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/rotate.js
    stroke
    ../point_src/distances.js
    ../point_src/dragging.js

---

*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        let depth = this.depth = 1000
        /* Generate 100 points, within a 500px box, at origin 0,0 */
        this.points = PointList.generate.random(100, 500, this.center.subtract(500))
        this.points.each.z = () => -900 + Math.random() * depth + 500

        this.projectionPoint = this.points.center.copy()
        this.projectionLength = 1000
        this.perspectiveCenter = this.center.copy()

        this.rotSize = 0
        this.performSpin = false
        this.zFix = false
        let stage = this;
        addButton('Z Fix', {
            label: 'Z FIX'
            , onclick(e) {
                stage.zFix = !stage.zFix
                e.target.text = `${this.label} (${stage.zFix})`
            }
        })
    }

    step(){
        let spin = this.spin = {
                x: 0
                , y:  this.rotSize
                , z: 0
            }

        this.spunPoints = this.points.pseudo3d.perspective(
                  this.spin
                , this.projectionPoint
                , this.projectionLength
                , this.perspectiveCenter
            )
        let maxDepth = this.depth
        let deepColor = 200
        this.spunPoints.forEach((p, i)=>{
            let z = p.z
            let red = deepColor - ((z / maxDepth) * deepColor)
            // let colorBlue = "hsl(184 50% 40%)"
            // let colorRed = "hsl(0 66% 40%)"
            let color = `hsl(${red} 66% 35%)`
            p.color = color
        })
        this.zFix && this.spunPoints.sortByZ()
        // this.perspectiveCenter = this.spunPoints.copy().add(0, 0)


    }

    onMousedown(){
        this.performSpin = !this.performSpin
    }

    draw(ctx){
        this.clear(ctx)
        let sv = 0.02
        if(this.performSpin){
            sv = .2
        }
        this.rotSize += sv
        this.step()
        // let color = '#666'
        // this.points.pen.indicators(ctx, {color})
        // this.spunPoints.pen.indicators(ctx)
        let maxDepth = this.depth
        let deepColor = 200

        this.spunPoints.forEach((p, i)=>{
            let z = p.z


================================================================================
END: twist-cube.js
================================================================================



================================================================================
FILE: two-point-chord-example.js
================================================================================

/*
title: Two Point Circle Segment
category: chords
files:
    head
    ../point_src/extras.js
    pointlist
    point
    stage
    mouse
    dragging
    stroke
    ../point_src/random.js
    ../point_src/chords.js
---

A _segment_, is a non-equidistant chord. !here the points are _anywhere_ around the edge.

In this example the the two points project a chord within the area point.
*/

class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.areaPoint = new Point({x: 250, y: 150 , radius: 100})
        this.iPoint = new Point({x: 250, y: 150 , radius: 10, rotation: 0})
        this.iPoint2 = new Point({x: 350, y: 150 , radius: 10, rotation: 0})
        this.dragging.add(this.areaPoint, this.iPoint, this.iPoint2)
    }

    draw(ctx){
        this.clear(ctx)

        let p = this.areaPoint
        let chord = this.iPoint
        let chord2 = this.iPoint2
        chord.pen.indicator(ctx)
        chord2.pen.indicator(ctx)
        let r = chordEndpoints2(p, chord, chord2)
        p.pen.circle(ctx, undefined, 'purple')

        if(r) {
            new Point(r[0]).pen.line(ctx, r[1], 'green')

            r.forEach(d=>{
                new Point(d).pen.fill(ctx, 'purple')
            });
        }
    }
}


stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: two-point-chord-example.js
================================================================================



================================================================================
FILE: ui-controls.js
================================================================================

/*
---
title: UI Controls
categories: widgets
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/stage.js
    ../point_src/distances.js
    ../point_src/dragging.js

---

An example of creating basic interactive controls. For these examples the page
utilises "Petite Vue" for minimal HTML templating

The function `addControl` emits an event for the _mini app_ to collect.
*/
class MainStage extends Stage {
    canvas='playspace'
    // live=false
    live = true
    mounted(){
        this.point = new Point(300, 400, 100)
        this.dragging.add(this.point)

        // this.lerper = new Iterator(0, .1, 1)
        this.tick = 0

        addButton('button', {
            label: 'my button'
        })

        addControl('text', {
            field: 'input'
            , value: 'Bananana'
            , onchange(ev) {}
        })

        addControl('number type', {
            field: 'input'
            , value: 20
            , type: 'number'
            , onchange(ev) {}
        })

        addControl('choice', {
            field: 'select'
            , options: [
                'eggs'
                , 'butter'
                , 'bacon'
                , 'bread'
            ]
            , stage: this
            , onchange(ev) {
                let sval = ev.currentTarget.value
            }
        })

        addControl('slider', {
            field: 'range'
            , stage: this
            , onchange(ev, unit) {
                /*slider changed. */
                let sval = ev.currentTarget.value
                unit.value = "sval"
            }
        })

    }

    draw(ctx){
        this.clear(ctx)

        let pos = this.mouse.position
        pos.pen.circle(ctx)

        this.point.pen.indicator(ctx)
    }
}


;stage = MainStage.go();

================================================================================
END: ui-controls.js
================================================================================



================================================================================
FILE: utils/snapshots.js
================================================================================

/*
title: Snapshots
*/

// In your js file you can include this code block
function getCookie(name) {
    var cookieValue = null;
    if (document.cookie && document.cookie != '') {
        var cookies = document.cookie.split(';');
        for (var i = 0; i < cookies.length; i++) {
            var cookie = cookies[i].trim();
            // Does this cookie string begin with the name we want?
            if (cookie.substring(0, name.length + 1) == (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}

const csrf_token = getCookie("csrftoken");

const sendCache = {
    series_index: 0
}

const trimAsyncPost = async function(url, body) {

    let prom = new Promise(async (resolve, reject) => {

        try {
            const response = await fetch(url, {
                method: "POST",
                // DO NOT SET 'Content-Type' when using FormData!
                body: body
            })
            let d = await response.json()
            resolve(response);
        } catch (err) {
            reject(err);
        }
    });

    return prom
}


let runTrimForm = function(){
    let tf = new TrimForm()
    tf.addFields({
        "csrfmiddlewaretoken": csrf_token
        ,"theatre_filename": "gif-recorder"
        ,"series_index": sendCache.series_index
        // ,"image_file": [new Blob(), "filename.png"]
    });

    let url = "/examples/upload/image/"
    tf.post(url).then(console.log)
    return tf
};

class TrimForm extends FormData {
    /* This provides an interface to using form data for
    fast ajaxy posts to django

    */
    populateBody(fieldData=this._fieldBodyData, body=this) {
        for(let k in fieldData) {
            body.append(k, fieldData[k])
        }

        return body
    }

    addFields(dict) {
        for(let k in dict) {
            this.addField(k, dict[k])
        }
    }

    addField(name, value) {
        // if(this._fieldBodyData == undefined) {
        //     this._fieldBodyData = {}
        // }
        // this._fieldBodyData[name] = value
        this.append(name, value)

    }

    post(url) {
        // this.populateBody()
        return trimAsyncPost(url, this).then(console.log)
    }
}


const sendImage = async function(canvas) {
    return new Promise((resolve, reject) => {
        canvas.toBlob(async (b) => {


================================================================================
END: utils/snapshots.js
================================================================================



================================================================================
FILE: vad-example.js
================================================================================

/*
title: Most Minimal Example
categories: minimal
files:
    head
    point
    stage
    mouse
    ../point_src/easing.js
    ../theatre/vad-wave.js
---

The minimal requirements include the _head_, _stage_, and the _point_.
*/


class MainStage extends Stage {
    canvas = 'playspace'
    mounted() {
        this.point = this.center.copy()
        this.point.radius = 50

        this.color = '#44DD88'
        this.events.on('speechStart', this.onSpeechStart.bind(this))
        this.events.on('speechEnd', this.onSpeechEnd.bind(this))
        this.events.on('frameProcessed', this.onFrameProcessed.bind(this))
    }

    onSpeechStart() {
        console.log('start')
        this.point.radius += 30
        this.color = 'orange'
    }

    onSpeechEnd() {
        console.log('end')
        this.point.radius = 50
        this.color = '#4488DD'
    }

    onFrameProcessed(){
        console.log('frameProcessed')
    }

    draw(ctx){
        this.clear(ctx)
        this.point.pen.fill(ctx, {color:this.color, width: 3})
    }
}

stage = MainStage.go(/*{ loop: true }*/)



================================================================================
END: vad-example.js
================================================================================



================================================================================
FILE: vad-wave.js
================================================================================

/*
title: VAD Wave
*/
async function micMonitorMain() {
    const myvad = await vad.MicVAD.new({
        onSpeechStart(){
            stage.events.emit('speechStart')
        }
        , onFrameProcessed(){
            /*
                probabilities: {
                    isSpeech: float
                    notSpeech: float
                }
                frame: Float32Array
             */
            stage.events.emit('frameProcessed')
        }
        , onVADMisfire(){
            console.log('misfire')
        }
        , onSpeechRealStart(){
            console.log('RealStart')
        }
        // number  0.5 see algorithm configuration
        , positiveSpeechThreshold: 0.3
        // number  0.35    see algorithm configuration
        , negativeSpeechThreshold: .15
        //    number  8   see algorithm configuration
        , redemptionFrames: 8
        //    number  1536    see algorithm configuration
        , frameSamples: 1536
        //  number  1   see algorithm configuration
        , preSpeechPadFrames: 1
        // number  3   see algorithm configuration
        , minSpeechFrames: 3
        //   "v5" or "legacy"    "legacy"    whether to use the new Silero model or not
        , model: 'legacy'

        , onSpeechEnd(audio){
            // do something with `audio` (Float32Array of audio samples at sample rate 16000)...
            stage.events.emit('speechEnd', { audio })
            onSpeechEnd(audio)
        }
    });

    myvad.start()
}


console.log('Run micMonitorMain.')
micMonitorMain()


function floatTo16BitPCM(output, offset, input) {
  for (let i = 0; i < input.length; i++, offset += 2) {
    // Clamp between -1 and 1
    let s = Math.max(-1, Math.min(1, input[i]));
    // Scale to 16-bit signed integer
    s = s < 0 ? s * 0x8000 : s * 0x7FFF;
    output.setInt16(offset, s, true); // little-endian
  }
}


function writeWAVHeader(view, sampleRate, numSamples) {
  const numChannels = 1;
  const bitsPerSample = 16;
  const blockAlign = numChannels * bitsPerSample / 8;
  const byteRate = sampleRate * blockAlign;
  const dataSize = numSamples * blockAlign;

  // RIFF chunk descriptor
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true); // file length - 8
  writeString(view, 8, 'WAVE');

  // fmt sub-chunk
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true); // Subchunk1Size
  view.setUint16(20, 1, true); // AudioFormat (PCM)
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitsPerSample, true);

  // data sub-chunk
  writeString(view, 36, 'data');
  view.setUint32(40, dataSize, true);
}


function writeString(view, offset, string) {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}




================================================================================
END: vad-wave.js
================================================================================



================================================================================
FILE: vector-field.js
================================================================================

/*
title: Example
categories: velocity
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/extras.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/point.js
    ../point_src/stage.js
    mouse
    dragging
    stroke
    ../point_src/velocity.js
---

*/


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        let rowCount = 20
        this.ps = PointList.generate.grid(200, rowCount, 30)
        this.gt = this.ps.generate.getGridTool(rowCount)
        this.ps.each.radius = 10
        this.dragging.add(...this.ps)
        this.ps.forEach(p=> p.velocity.set(1,1))
        console.log('mounted')
        this.actives = []
        this.subVal = .99
    }

    onMousedown(ev) {
        let p = this.dragging.getPoint()
        p && this.pushVelocities(p)
    }

    pushVelocities(origin) {
        let power = 20
        let ps = this.ps;
        let i = ps.indexOf(origin)

        pushVelocities(ps, this.gt, origin)
    }

    step() {
        let gt = this.gt
        let ps = this.ps
        let actives = this.actives
        // let newActives = []
        ps.forEach(function(p, i){
            let siblings = gt.getSiblings(i)
            // p.velocity.mutableMul({x:.99, y:.99})
            // let p = ps[i]
            let v = p.velocity

            /* Add all the velocities together. */
            let c = 1
            siblings.forEach(function(j){
                let ot = ps[j].velocity
                if(ot.x + ot.y < 0.3) {
                    return /* skip blanks */
                }

                c += 1
                v = v.add(ot)
            })
            /* Then divide to add to _self_. */
            v = v.div({x:c, y:c})
            v.x = clamp(v.x, 1, 10)
            v.y = clamp(v.y, 1, 10)

            p.velocity.copy(v)
            // newActives = newActives.concat(siblings)
        })
    }

    draw(ctx){
        this.clear(ctx)
        // this.step()
        this.ps.pen.circle(ctx, undefined, 'purple')
        let subVal = this.subVal
        this.ps.forEach(function(p){
            p.pen.line(ctx, p.add(p.velocity), 'red')
            // p.velocity.mutableSub({x:subVal, y:subVal})
            p.velocity.mutableMul({x:subVal, y:subVal})
        })
    }
}


const pushVelocities = function(ps, gt, origin) {
    let power = 20;          // initial velocity magnitude
    let damping = 0.8;      // how much velocity is reduced each neighbor


================================================================================
END: vector-field.js
================================================================================



================================================================================
FILE: widget-examples.js
================================================================================

/*
title: Widget Examples
files:
    head
    point
    stage
    dragging
    pointlist
    mouse
    stroke
    fps
    ../point_src/functions/signedNorm.js
    ../theatre/objects/vectorpoint.js
    ../theatre/objects/spinplotter.js
---

*/

addWidget('multi', {
    fields: {
        alpha: { value: 0 }
        , beta: { value: 0 }
        , charlie: { value: 0 }
    }
})


addButton('button', {
    label: "Toggle Run"
    , onclick(){
        stage.buttonToggle = !stage.buttonToggle

}})

addSliderControlSet({
    alpha: { value: 1 }
    , beta: { value: 22 }
    , charlie: { value: 15 }
})

addSliderControl('Slider', {})

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.buttonToggle = true
        setInterval(()=>{
            if(this.buttonToggle) { this.updateMultiWidget() }
        }, 500)
    }

    updateMultiWidget() {
        updateWidgetValues('multi', {
            alpha: random.int(0, 1000).toFixed(2)
            , beta: random.int(0, 1000)
            , charlie: random.float(-1, 1).toFixed(3)
        })
    }

    draw(ctx){
        this.clear(ctx)
        this.fps.print(ctx)
    }
}

stage = MainStage.go()


================================================================================
END: widget-examples.js
================================================================================



================================================================================
FILE: windings-example-raw.js
================================================================================

/*
title: Windings Example Raw
categories:
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    mouse
    ../point_src/bisector.js
    ../point_src/random.js
    dragging
    ../point_src/l.js
    ../point_src/protractor.js
    ../point_src/text/beta.js
    stage

---

Calculate _windings_ of a point. Detect the point rotation and diff against
the previous value.

The value is independant of the point and accounts for rotation through the
0 degree, and the _initial_ rotation of the point.

*/

addWidget('diff', {
    fields: {
        diff: { value: 0 }
        , total: { value: 0 }
        , total_mod: { value: 0 }
    }
})



function calculateAngleDiffWrapped(primaryPoint, secondaryPoint) {
    let rads = radiansDiff2(primaryPoint.radians, secondaryPoint.radians);
    return radiansToDegrees(rads);
}

function radiansDiff2(primaryRads, secondaryRads) {
    let diff = (primaryRads - secondaryRads + Math.PI) % (Math.PI * 2) - Math.PI;
    if (diff < -Math.PI) diff += Math.PI * 2;
    return diff;
}


class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        console.log('drag-point')
        this.spot = this.center.copy()
        this.spot.radius = 300
        this.spot.rotation = random.int(360)
        this.dragging.addPoints(this.spot)
        this.total = 0
        this.last_rot = 0
    }

    firstDraw(ctx) {
        ctx.strokeStyle = 'yellow'
        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px inter`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
    }

    draw(ctx){
        this.clear(ctx)
        // this.fps.drawFPS(ctx)
        this.updateRadians()
        this.drawCircles(ctx)

        ctx.fillStyle = '#EEE'
        this.drawIris(ctx)
    }

    updateRadians() {
        let last_radians = this.last_radians
        if(last_radians == undefined) {
            last_radians = this.spot.radians
        };

        let rotW = calculateAngleDiffWrapped({radians:last_radians}, this.spot)
        let rot = calculateAngleDiff({radians:last_radians}, this.spot)
        if(rot != this.last_rot) {
            // console.log(rot, rotW)
            let diff = (this.last_rot - rot)
            if (diff < -180 || diff > 180) {
                // skip it.
                diff = ((this.last_rot - 360) % 360 ) + rot
            } else {
                this.total += diff;


================================================================================
END: windings-example-raw.js
================================================================================



================================================================================
FILE: windings-example.js
================================================================================

/*
title: Windings Example
categories:
    angles
files:
    head
    stroke
    ../point_src/point-content.js
    pointlist
    point
    mouse
    ../point_src/bisector.js
    ../point_src/random.js
    dragging
    ../point_src/l.js
    ../point_src/protractor.js
    ../point_src/windings.js
    ../point_src/text/beta.js
    stage

---

Calculate _windings_ of a point. Detect the point rotation and diff against
the previous value.

The value is independant of the point and accounts for rotation through the
0 degree, and the _initial_ rotation of the point.

*/

addWidget('diff', {
    fields: {
        diff: { value: 0 }
        , total: { value: 0 }
        , total_mod: { value: 0 }
    }
})


class MainStage extends Stage {
    canvas='playspace'

    // live=false
    live = true
    mounted(){
        console.log('drag-point')
        this.spot = this.center.copy().update({
            radius: 300
            ,rotation: random.int(360)
        })

        this.dragging.addPoints(this.spot)

        this.total = 0
        this.lastDiff = 0
    }

    firstDraw(ctx) {
        ctx.strokeStyle = 'yellow'
        ctx.fillStyle = '#EEE'
        ctx.font = `400 16px inter`;
        ctx.textAlign = 'center'
        ctx.textBaseline = 'middle'
    }

    draw(ctx){
        this.clear(ctx)
        this.updateRadians()

        updateWidgetValues('diff', {
            diff: this.lastDiff.toFixed(2)
            , total: this.total.toFixed(0)
            , total_mod: (this.total % 360).toFixed(0)
        })

        this.drawCircles(ctx)

        ctx.fillStyle = '#EEE'
        this.drawIris(ctx)
    }

    updateRadians() {
        let p = this.spot;
        let w = p.windings
        let total = w.calculate()
        this.lastDiff =  w.lastDiff
        this.total =  total
    }

    drawCircles(ctx) {
        this.spot.pen.fill(ctx, '#333')
        this.spot.pen.indicator(ctx, { color: '#111'})
    }

    drawIris(ctx) {
        /* The dynamic highlighter. */
        this.dragging.drawAll(ctx)
    }

}


================================================================================
END: windings-example.js
================================================================================



================================================================================
FILE: within-polygon-test.js
================================================================================

/*
title: Polgon hit-test
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/stagepen.js
    ../point_src/point.js
    ../point_src/distances.js
    ../point_src/pointlist.js
    ../point_src/pointlistpen.js
    ../point_src/events.js
    ../point_src/functions/clamp.js
    ../point_src/curve-extras.js
    ../point_src/random.js
    dragging
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/functions/within.js
    ../point_src/automouse.js

---

Click to draw connected lines (filling a `PointList`)
Then check the mouse is within the drawn _polygon_ using the `withinPolygon` function
 */

addButton('Toggle Line', {
    onclick() {
        stage.drawLine = !stage.drawLine
    }
})
addButton('Toggle Fill', {
    onclick() {
        stage.fillPolygon = !stage.fillPolygon
    }
})

class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.drawn = []
        // this.events.wake()

        this.stroke = new Stroke({
            color: '#b32bb6'
            , width: 2
            , dash: [7, 4]
        })

        this.fillPolygon = true
        this.drawLine = false
        this.line = new PointList
        this.dragging.wake()
    }

    onEmptyDown(ev) {
    // onClick(ev, point) {
        // if(point == undefined) {
        console.log('Down')
        let np = Point.from(ev)
        this.line.push(np)
        this.dragging.add(np)
        // }
    }

    draw(ctx){
        this.clear(ctx)

        this.stroke.set(ctx)

        let l = this.line;
        if(l) {
            let f = l.first()
            f && f.pen.circle(ctx)
            l.draw.line(ctx)
        }

        if(this.fillPolygon) {
            this.pen.fill(ctx, '#621763')
        }

        if(l && this.drawLine){
            l.pen.line(ctx, '#b32bb6')
            l[0].pen.line(ctx, l.last(), '#b32bb6')
        }

        /* Start texting if we have enough points.*/
        if(l?.length > 2) {
            let within = withinPolygon(this.mouse.point, l)
            if(within) {
                this.mouse.point.pen.fill(ctx, this.fillPolygon? 'purple': 'orange')
            }
        } else {


================================================================================
END: within-polygon-test.js
================================================================================



================================================================================
FILE: x-1-GPT-fail.js
================================================================================

/*
---
title: Experimental: 1 Gpt Fail
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/setunset.js
    ../point_src/stroke.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/events.js
    ../point_src/automouse.js
    ../point_src/distances.js
    ../point_src/dragging.js
    ../point_src/functions/clamp.js
    ../point_src/stage.js
 */


class MainStage extends Stage {
    canvas='playspace'

    mounted(){
        this.point = new Point({x:300,y:200, radius: 10})

        this.dragging.addPoints(this.point)
    }

    draw(ctx){
        this.clear(ctx)

        let a = this.point;
        let m = this.mouse.point

        a.pen.indicator(ctx)
        // m.pen.indicator(ctx)
        let v = Point.from(get_elbow_pos_local(200, 100, a,))

        v.x += 300
        v.y += 200
        v.pen.indicator(ctx)
    }
}

const get_elbow_pos_local = function(l1=1.0, l2=1.0, local_end_affector={x:1,y:1}, elbow_direction_sign=1){
    let numerator = l1 * l1
                    + local_end_affector.x * local_end_affector.y
                    + local_end_affector.y * local_end_affector.y
                    - l2 * l2
                    ;
    let demonimator = 2 * l1
                      * Math.sqrt(local_end_affector.y * local_end_affector.x
                      + local_end_affector.y * local_end_affector.y
                    )
                    ;

    let elbow_angle_relative = Math.acos(numerator / demonimator)
    // hmm.
    // if(elbow_angle_relative != elbow_angle_relative) elbow_angle_relative = 0.f

    if(elbow_direction_sign == 0) {
        elbow_direction_sign = 1
    }

    let r = polar(1 * elbow_angle_relative + angleOf(local_end_affector), l1)


    return r
}

function angleOf(vec) {
  // Returns the angle in radians from the X-axis
  return Math.atan2(vec.y, vec.x);
}


function polar(angle, length) {
  return {
    x: length * Math.cos(angle),
    y: length * Math.sin(angle),
  };
}

;stage = MainStage.go();

================================================================================
END: x-1-GPT-fail.js
================================================================================



================================================================================
FILE: x-a.js
================================================================================

/*
title: Experimental: SVG Path Command Builder
*/

const namedCommands = function(name, letter, ...positions){
    let res = {
        rel: letter.toLowerCase(),
        abs: letter.toUpperCase(),
        positions,
        name,
    }

    return buildCaller(res)
}


const buildCaller = function(info) {
    let handler = {
        info
        , get(target, prop, receiver) {
            return this.info[prop]
            // return Reflect.get(...arguments);
        }

        , apply(target, thisArg, argumentsList) {
            // console.log('Caller upon', thisArg, argumentsList)
            return magicCall(info, argumentsList, {owner: thisArg})
        }

    }

    return (new Proxy(function(){}, handler))
}


var removeAll = (arr, keys) => {for (prop of keys) arr.delete(prop); return arr};


const magicCall = function(info, argumentsList, options) {
    /* return a call if possible for the given object and args.
    the options may be a callable parent or dict with options to adapt */

    let positions = info.positions
    let shortArgs = argumentsList.length < positions.length
    let a0 = argumentsList[0]
    let objArgs = (argumentsList.length == 1)
                    && (
                        (a0 instanceof Object)
                        || (typeof(cg.coords) ==  'object')
                    )
    // console.log('magicCall', 'short:', shortArgs,  'isObj', objArgs)

    /*
        First convert positional or object arguments to an object of expected
        keys.
     */

    if((!objArgs) && shortArgs) {
        let missing = positions.slice(argumentsList.length)
        throw Error(`Expected Positional: ${positions} missing: ${missing} `)
    }

    let res = Object.assign({}, a0)
    // Pack args into a dict
    if(!objArgs) {
        var i;
        for (i = 0; i < positions.length; i++) {
            let name = positions[i];
            res[name] = argumentsList[i]
        }
    }

    // rebind additionals
    let extra = argumentsList.slice(i)
    extra = extra.length > 0? extra[0]: {} // one dictionary
    extra = Object.assign(extra, {case: 'rel'}, options)

    let missing = removeAll(new Set(positions), new Set(Object.keys(res)))
    missing = Array.from(missing)
    // console.log(res, 'missing', missing)

    if(missing.length > 0) {
        throw Error(`"${info.name}" Expected: ${positions} missing: ${missing}`)
    }

    /*
     now call upon the script putting the keys in position.
     */
    return new Command(res, info, extra)
}


class Command {

    constructor(data, header, options) {
        this.data = data
        this.header = header
        this.options = options
    }



================================================================================
END: x-a.js
================================================================================



================================================================================
FILE: x-arc-line-3.js
================================================================================

/*
category: arcs
title: Experimental: Arc Line 3
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/pointlistpen.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/text/beta.js
    mouse
    ../point_src/random.js
    dragging
    stage
    stroke
    ../point_src/split.js
    ../point_src/bisector.js
    ../point_src/angle.js
    ../point_src/tangents.js
*/

const isOuterPoint = function(p, nextPoint) {
    return calculateAngle(p, nextPoint) > 180
    // return obtuseBisect(previousPoint, p, nextPoint) > -1
}


class MainStage extends Stage {
    canvas = 'playspace'

    mounted(){
        this.point = this.center.copy().update({radius: 100})
        this.points = new PointList(
                [233, 325, 20]
                , [189, 169, 30]
                , [442, 113, 30]
                , [626, 215, 70]
                , [525, 419, 20]
            ).cast()

        this.regenerate()
        this.dragging.add(...this.points)
    }

    regenerate() {
        this.biPoints = this.generate(this.points)
        this.tangentPoints = this.generateTangents(this.biPoints)
    }

    generateTangents(biPoints) {
        /* Built tangent lines to later plot*/
        let res = []
        biPoints.forEach((pair, i, items)=>{
            let [a, b] = pair
            let [c, d] = items[i+1] == undefined? items[0]: items[i+1]
            let m1 = items[i-1] == undefined? items[items.length-1]: items[i-1]
            // let outer = a.isOuterPoint = calculateAngle(a, c)
            let outer = acuteBisect(m1[1], items[i][1], c)
            outer = convertAngle180Split(radiansToDegrees(outer))
            //[a.radius, b.radius, c.radius, d.radius]
            if(outer < 0) {
                res.push(b.tangent.bb(d))
            }else {
                res.push(b.tangent.aa(d))
            }

            // res.push(b.tangent.outerLines(d).b)
        })

        return res;
    }

    generate(points) {
        let res = [];

        points.forEach((p, i, a)=>{
            // two points for each given.
            if(i==0) {
                // manual _lookat_, then 90 degree rotated.
                // let rads = p.directionTo(points[i+1])
                // p.rotation = (new Angle(rads, 'rad').deg) + 90

                // Looped
                p.radians = acuteBisect(points[points.length-1], points[i], points[i+1])

            } else if(points[i+1] == undefined){
                // let rads = p.directionTo(points[i-1])
                // p.rotation = (new Angle(rads, 'rad').deg) - 90
                p.radians = acuteBisect(points[i-1], points[i], points[0])
            } else {
                p.radians = acuteBisect(points[i-1], points[i], points[i+1])
            }

            let pins = p.split(2)
            pins.each.radius = p.radius
            res.push(pins)
        })


================================================================================
END: x-arc-line-3.js
================================================================================



================================================================================
FILE: x-point-direction.js
================================================================================

/*
title: Experimental: Point Direction
files:
    ../point_src/math.js
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/point-content.js
    ../point_src/pointlist.js
    ../point_src/point.js
    ../point_src/stage.js


 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        this.points = new PointList(
            new Point({
                name: "up"
                , rotation: UP_DEG
                , x: 50, y: 50
            })
            , new Point({
                name: "right"
                , rotation: RIGHT_DEG
                , x: 100, y: 50
            })
            , new Point({
                name: "down"
                , rotation: DOWN_DEG
                , x: 150, y: 50
            })
            , new Point({
                name: "left"
                , rotation: LEFT_DEG
                , x: 200, y: 50
            })
            , new Point({
                name: "spinner"
                , x: 250, y: 50
            })
        )
    }

    draw(ctx){
        this.clear(ctx)
        this.points.last().rotation += 2
        for(let p in this.points) {
            this.points[p].pen.indicator(ctx)
        }
    }
}

stage = MainStage.go(/*{ loop: true }*/)


================================================================================
END: x-point-direction.js
================================================================================



================================================================================
FILE: x-projected-circle.js
================================================================================

/*
src_dir: ../point_src/
title: Experimental: Projected Circle
files:
    ../point_src/core/head.js
    ../point_src/pointpen.js
    ../point_src/pointdraw.js
    ../point_src/extras.js
    ../point_src/math.js
    ../point_src/point-content.js
    ../point_src/stage.js
    ../point_src/point.js
    ../point_src/distances.js
    pointlist
    ../point_src/events.js
    ../point_src/functions/clamp.js
    dragging
    stroke
    ../point_src/split.js
    ../point_src/curve-extras.js
    ../point_src/stage-clock.js
    ../point_src/protractor.js
    ../point_src/relative.js
    ../point_src/automouse.js
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){
        let radius = 100

        // let count = 10
        // this.tick = 9


        let count = 4
        this.tick = 9

        this.pointA = this.center.copy().update({ radius})
        this.pointB = this.center.copy().update({radius: 100})
        this.pointA.x -= 150
        this.pointB.x += 150

        this.pointsA = this.pointA.split(4).pairs(0)

        this.pointsB = this.pointB.split(count, degToRad(90)).siblings(1)

        this.curves = []
        this.pointsB.forEach(pl=>{
            pl[0].radius = radius * 1
            pl[1] = pl[1].copy()
            pl[1].lookAt(pl[0])
            let c = new BezierCurve(...pl)
            c.doTips = false

            // c.useCache = false
            this.curves.push(c)
        })

        this.dragging.add(this.pointA, this.pointB, this.pointsA, this.pointsB)
        this.pointsA.forEach( pl => this.dragging.add(...pl))
        this.pointsB.forEach( pl => this.dragging.add(...pl))
    }

    draw(ctx){
        this.clear(ctx)

        // this.pointA.pen.indicator(ctx)
        // this.pointB.pen.indicator(ctx)

        this.pointsA.forEach(pl=>{
            pl.pen.indicators(ctx)
            pl.pen.line(ctx)
        });

        let d = 0// this.tick || this.clock.tick * .04
        let t = this.clock.tick * .04
        this.pointsB.forEach(pl=>{
            pl.forEach((p, i)=>{
                p.rel.rotation = (Math.sin(d) + (Math.cos(d) * .2)) * 30
                p.rel.x = (Math.cos(t) * 3)
                p.rel.y = (Math.sin(t) * 3)
            })
        })

        // this.points.pen.indicators(ctx)

        this.curves.forEach(pl=>{
            pl.render(ctx)
            // pl.getControlPoints().forEach((p)=>p.pen.indicator(ctx))
        })

    }
}

;stage = MainStage.go();


================================================================================
END: x-projected-circle.js
================================================================================



================================================================================
FILE: zoom-lines.js
================================================================================

/*
---
title: Zooming Points
src_dir: ../point_src/
categories: scaling
files:
    ../point_src/math.js
    ../point_src/core/head.js
    point
    pointlist
    mouse
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    stroke
    dragging
    ../point_src/zoom.js
---

Zoom many points.
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){

        let radius = 7
        let count = 200
        const pointList = PointList.generate.random(count, 600, {x: 300, y:100})
        pointList.each.color = ()=>random.color([100, 230], [40,80], [40,60])
        this.factor = 1.2

        pointList.forEach(p=>p.radius = random.int(2, 5))
        this.points = pointList
        this.dis = new Distances
        this.dis.addPoints(...pointList)

        this.zoom = new Zoom(this, pointList)
        this.zoom.lens = -.6
        // this.zoom.add(...pointList)

        this.dragging.add(...pointList)
        this.dragging.onEmptyDown = this.onEmptyDown.bind(this)
        this.dragging.onWheelEmpty = this.onWheelEmpty.bind(this)
        this.events.wake()

        this.isPanning = true
        this.innerZoom = 1
        this.origin = this.center.copy()
        this.zoom.update(this.origin, this.factor)

    }

    onWheelEmpty(ev) {
        this.innerZoom += ev.deltaY
        let factor = this.factor = 1 + (this.innerZoom * -.001)
        console.log(factor)
        if(this.origin) {
            this.zoom.update(this.origin, factor)
        }
    }

    onEmptyDown(ev) {
        // console.log('onEmptyDown')
        this.isPanning = true
        this.origin = Point.from(ev)
        this.zoom.update(this.origin, this.factor)
    }

    onMousemove(ev) {
        if(!this.isPanning) {
            return
        }

        this.origin.copy(this.mouse.position)
        // let d = Point.from(ev).distance2D(this.origin)
        // console.log('Pan', d)
    }

    onMouseup(ev) {
        this.isPanning = false
    }

    draw(ctx){
        this.clear(ctx)
        if(this.origin){
            this.zoom.update3(this.origin, this.factor)
        }

        let mousePoint = Point.mouse.position
        this.points.lookAt(mousePoint)
        /* Draw each point; wrapping the _draw_ call_ with our own functionality.*/
        this.points.pen.circle(ctx, { color: '#444', width: 1})
        let zps = this.zoom.zoomPoints

        this.points.forEach((p, i)=>{
            zps[i].pen.line(ctx, p, '#222')

        })


================================================================================
END: zoom-lines.js
================================================================================



================================================================================
FILE: zoom.js
================================================================================

/*
---
title: Zooming Points
src_dir: ../point_src/
categories: scaling
files:
    ../point_src/math.js
    ../point_src/core/head.js
    point
    pointlist
    mouse
    ../point_src/stage.js
    ../point_src/extras.js
    ../point_src/random.js
    stroke
    dragging
    ../point_src/zoom.js
---

Zoom many points.
 */
class MainStage extends Stage {
    // canvas = document.getElementById('playspace');
    canvas = 'playspace'

    mounted(){

        let radius = 7
        let count = 100
        const pointList = PointList.generate.random(count, 600, {x: 300, y:100})
        this.factor = 1

        pointList.forEach(p=>p.radius = random.int(20))
        this.points = pointList
        this.dis = new Distances
        this.dis.addPoints(...pointList)

        this.zoom = new Zoom(this, pointList)
        // this.zoom.add(...pointList)

        this.dragging.add(...pointList)
        this.dragging.onEmptyDown = this.onEmptyDown.bind(this)
        this.dragging.onWheelEmpty = this.onWheelEmpty.bind(this)
        this.events.wake()

        this.innerZoom = 0
    }

    onWheelEmpty(ev) {
        this.innerZoom += ev.deltaY
        let factor = this.factor = 1 + (this.innerZoom * -.001)

        if(this.origin) {
            this.zoom.update(this.origin, factor)
        }
    }

    onEmptyDown(ev) {
        // console.log('onEmptyDown')
        this.isPanning = true
        this.origin = Point.from(ev)
        this.zoom.update(this.origin, this.factor)
    }

    onMousemove(ev) {
        if(!this.isPanning) {
            return
        }

        this.origin.copy(this.mouse.position)
        // let d = Point.from(ev).distance2D(this.origin)
        // console.log('Pan', d)
    }

    onMouseup(ev) {
        this.isPanning = false
    }

    draw(ctx){
        this.clear(ctx)
        if(this.origin){
            this.zoom.update(this.origin, this.factor)
        }

        let mousePoint = Point.mouse.position
        this.points.lookAt(mousePoint)
        /* Draw each point; wrapping the _draw_ call_ with our own functionality.*/
        this.points.pen.indicators(ctx, { color: '#444', width: 1})

        this.zoom.zoomPoints.pen.indicators(ctx, { color: 'gray', width: 1})

        this.origin?.pen.circle(ctx, 5, 'red')
        // let v = this.dis.closest(mousePoint)
        let v = this.dis.near(mousePoint, 200)

        for(const p of v){
            p.pen.indicator(ctx, { color: 'green', width: 3})
        }
        // console.log(v.length)
    }


================================================================================
END: zoom.js
================================================================================


